// =================================================================
//
//                           * WARNING *
//
//                    This file is generated!
//
//  Changes made to this file will be overwritten. If changes are
//  required to the generated code, the service_crategen project
//  must be updated to generate the changes.
//
// =================================================================
#![allow(warnings)]

use futures::future;
use futures::Future;
use rusoto_core::credential::ProvideAwsCredentials;
use rusoto_core::region;
use rusoto_core::request::{BufferedHttpResponse, DispatchSignedRequest};
use rusoto_core::{Client, RusotoError, RusotoFuture};
use std::error::Error;
use std::fmt;

use rusoto_core::param::{Params, ServiceParams};
use rusoto_core::proto;
use rusoto_core::signature::SignedRequest;
use serde_json;
/// <p>Details of abort criteria to abort the job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AbortConfig {
    /// <p>The list of abort criteria to define rules to abort the job.</p>
    #[serde(rename = "criteriaList")]
    pub criteria_list: Vec<AbortCriteria>,
}

/// <p>Details of abort criteria to define rules to abort the job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AbortCriteria {
    /// <p>The type of abort action to initiate a job abort.</p>
    #[serde(rename = "action")]
    pub action: String,
    /// <p>The type of job execution failure to define a rule to initiate a job abort.</p>
    #[serde(rename = "failureType")]
    pub failure_type: String,
    /// <p>Minimum number of executed things before evaluating an abort rule.</p>
    #[serde(rename = "minNumberOfExecutedThings")]
    pub min_number_of_executed_things: i64,
    /// <p>The threshold as a percentage of the total number of executed things that will initiate a job abort.</p> <p>AWS IoT supports up to two digits after the decimal (for example, 10.9 and 10.99, but not 10.999).</p>
    #[serde(rename = "thresholdPercentage")]
    pub threshold_percentage: f64,
}

/// <p>The input for the AcceptCertificateTransfer operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AcceptCertificateTransferRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>Specifies whether the certificate is active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
}

/// <p>Describes the actions associated with a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Action {
    /// <p>Change the state of a CloudWatch alarm.</p>
    #[serde(rename = "cloudwatchAlarm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cloudwatch_alarm: Option<CloudwatchAlarmAction>,
    /// <p>Capture a CloudWatch metric.</p>
    #[serde(rename = "cloudwatchMetric")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cloudwatch_metric: Option<CloudwatchMetricAction>,
    /// <p>Write to a DynamoDB table.</p>
    #[serde(rename = "dynamoDB")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamo_db: Option<DynamoDBAction>,
    /// <p>Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.</p>
    #[serde(rename = "dynamoDBv2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dynamo_d_bv_2: Option<DynamoDBv2Action>,
    /// <p>Write data to an Amazon Elasticsearch Service domain.</p>
    #[serde(rename = "elasticsearch")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub elasticsearch: Option<ElasticsearchAction>,
    /// <p>Write to an Amazon Kinesis Firehose stream.</p>
    #[serde(rename = "firehose")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub firehose: Option<FirehoseAction>,
    /// <p>Send data to an HTTPS endpoint.</p>
    #[serde(rename = "http")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub http: Option<HttpAction>,
    /// <p>Sends message data to an AWS IoT Analytics channel.</p>
    #[serde(rename = "iotAnalytics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iot_analytics: Option<IotAnalyticsAction>,
    /// <p>Sends an input to an AWS IoT Events detector.</p>
    #[serde(rename = "iotEvents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iot_events: Option<IotEventsAction>,
    /// <p>Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.</p>
    #[serde(rename = "iotSiteWise")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iot_site_wise: Option<IotSiteWiseAction>,
    /// <p>Write data to an Amazon Kinesis stream.</p>
    #[serde(rename = "kinesis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kinesis: Option<KinesisAction>,
    /// <p>Invoke a Lambda function.</p>
    #[serde(rename = "lambda")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lambda: Option<LambdaAction>,
    /// <p>Publish to another MQTT topic.</p>
    #[serde(rename = "republish")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub republish: Option<RepublishAction>,
    /// <p>Write to an Amazon S3 bucket.</p>
    #[serde(rename = "s3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_3: Option<S3Action>,
    /// <p>Send a message to a Salesforce IoT Cloud Input Stream.</p>
    #[serde(rename = "salesforce")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub salesforce: Option<SalesforceAction>,
    /// <p>Publish to an Amazon SNS topic.</p>
    #[serde(rename = "sns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sns: Option<SnsAction>,
    /// <p>Publish to an Amazon SQS queue.</p>
    #[serde(rename = "sqs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sqs: Option<SqsAction>,
    /// <p>Starts execution of a Step Functions state machine.</p>
    #[serde(rename = "stepFunctions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub step_functions: Option<StepFunctionsAction>,
}

/// <p>Information about an active Device Defender security profile behavior violation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ActiveViolation {
    /// <p>The behavior which is being violated.</p>
    #[serde(rename = "behavior")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behavior: Option<Behavior>,
    /// <p>The time the most recent violation occurred.</p>
    #[serde(rename = "lastViolationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_violation_time: Option<f64>,
    /// <p>The value of the metric (the measurement) which caused the most recent violation.</p>
    #[serde(rename = "lastViolationValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_violation_value: Option<MetricValue>,
    /// <p>The security profile whose behavior is in violation.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The name of the thing responsible for the active violation.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The ID of the active violation.</p>
    #[serde(rename = "violationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_id: Option<String>,
    /// <p>The time the violation started.</p>
    #[serde(rename = "violationStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_start_time: Option<f64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AddThingToBillingGroupRequest {
    /// <p>The ARN of the billing group.</p>
    #[serde(rename = "billingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_arn: Option<String>,
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_name: Option<String>,
    /// <p>The ARN of the thing to be added to the billing group.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The name of the thing to be added to the billing group.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AddThingToBillingGroupResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AddThingToThingGroupRequest {
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
    #[serde(rename = "overrideDynamicGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub override_dynamic_groups: Option<bool>,
    /// <p>The ARN of the thing to add to a group.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The ARN of the group to which you are adding a thing.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The name of the group to which you are adding a thing.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
    /// <p>The name of the thing to add to a group.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AddThingToThingGroupResponse {}

/// <p>Parameters used when defining a mitigation action that move a set of things to a thing group.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AddThingsToThingGroupParams {
    /// <p>Specifies if this mitigation action can move the things that triggered the mitigation action even if they are part of one or more dynamic things groups.</p>
    #[serde(rename = "overrideDynamicGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub override_dynamic_groups: Option<bool>,
    /// <p>The list of groups to which you want to add the things that triggered the mitigation action. You can add a thing to a maximum of 10 groups, but you cannot add a thing to more than one group in the same hierarchy.</p>
    #[serde(rename = "thingGroupNames")]
    pub thing_group_names: Vec<String>,
}

/// <p>A structure containing the alert target ARN and the role ARN.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertTarget {
    /// <p>The ARN of the notification target to which alerts are sent.</p>
    #[serde(rename = "alertTargetArn")]
    pub alert_target_arn: String,
    /// <p>The ARN of the role that grants permission to send alerts to the notification target.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>Contains information that allowed the authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct Allowed {
    /// <p>A list of policies that allowed the authentication.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>An asset property timestamp entry containing the following information.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AssetPropertyTimestamp {
    /// <p>Optional. A string that contains the nanosecond time offset. Accepts substitution templates.</p>
    #[serde(rename = "offsetInNanos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub offset_in_nanos: Option<String>,
    /// <p>A string that contains the time in seconds since epoch. Accepts substitution templates.</p>
    #[serde(rename = "timeInSeconds")]
    pub time_in_seconds: String,
}

/// <p>An asset property value entry containing the following information.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AssetPropertyValue {
    /// <p>Optional. A string that describes the quality of the value. Accepts substitution templates. Must be <code>GOOD</code>, <code>BAD</code>, or <code>UNCERTAIN</code>.</p>
    #[serde(rename = "quality")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quality: Option<String>,
    /// <p>The asset property value timestamp.</p>
    #[serde(rename = "timestamp")]
    pub timestamp: AssetPropertyTimestamp,
    /// <p>The value of the asset property.</p>
    #[serde(rename = "value")]
    pub value: AssetPropertyVariant,
}

/// <p>Contains an asset property value (of a single type).</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AssetPropertyVariant {
    /// <p>Optional. A string that contains the boolean value (<code>true</code> or <code>false</code>) of the value entry. Accepts substitution templates.</p>
    #[serde(rename = "booleanValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub boolean_value: Option<String>,
    /// <p>Optional. A string that contains the double value of the value entry. Accepts substitution templates.</p>
    #[serde(rename = "doubleValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub double_value: Option<String>,
    /// <p>Optional. A string that contains the integer value of the value entry. Accepts substitution templates.</p>
    #[serde(rename = "integerValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub integer_value: Option<String>,
    /// <p>Optional. The string value of the value entry. Accepts substitution templates.</p>
    #[serde(rename = "stringValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub string_value: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AssociateTargetsWithJobRequest {
    /// <p>An optional comment string describing why the job was associated with the targets.</p>
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>A list of thing group ARNs that define the targets of the job.</p>
    #[serde(rename = "targets")]
    pub targets: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AssociateTargetsWithJobResponse {
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>An ARN identifying the job.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachPolicyRequest {
    /// <p>The name of the policy to attach.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-security-identity.html">identity</a> to which the policy is attached.</p>
    #[serde(rename = "target")]
    pub target: String,
}

/// <p>The input for the AttachPrincipalPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachPrincipalPolicyRequest {
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachSecurityProfileRequest {
    /// <p>The security profile that is attached.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
    /// <p>The ARN of the target (thing group) to which the security profile is attached.</p>
    #[serde(rename = "securityProfileTargetArn")]
    pub security_profile_target_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AttachSecurityProfileResponse {}

/// <p>The input for the AttachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct AttachThingPrincipalRequest {
    /// <p>The principal, which can be a certificate ARN (as returned from the CreateCertificate operation) or an Amazon Cognito ID.</p>
    #[serde(rename = "principal")]
    pub principal: String,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the AttachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AttachThingPrincipalResponse {}

/// <p>The attribute payload.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AttributePayload {
    /// <p>A JSON string containing up to three key-value pair in JSON format. For example:</p> <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p><p>Specifies whether the list of attributes provided in the <code>AttributePayload</code> is merged with the attributes stored in the registry, instead of overwriting them.</p> <p>To remove an attribute, call <code>UpdateThing</code> with an empty attribute value.</p> <note> <p>The <code>merge</code> attribute is only valid when calling <code>UpdateThing</code> or <code>UpdateThingGroup</code>.</p> </note></p>
    #[serde(rename = "merge")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub merge: Option<bool>,
}

/// <p>Which audit checks are enabled and disabled for this account.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuditCheckConfiguration {
    /// <p>True if this audit check is enabled for this account.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// <p>Information about the audit check.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuditCheckDetails {
    /// <p>True if the check is complete and found all resources compliant.</p>
    #[serde(rename = "checkCompliant")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_compliant: Option<bool>,
    /// <p>The completion status of this check. One of "IN_PROGRESS", "WAITING_FOR_DATA_COLLECTION", "CANCELED", "COMPLETED_COMPLIANT", "COMPLETED_NON_COMPLIANT", or "FAILED".</p>
    #[serde(rename = "checkRunStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_run_status: Option<String>,
    /// <p>The code of any error encountered when this check is performed during this audit. One of "INSUFFICIENT_PERMISSIONS" or "AUDIT_CHECK_DISABLED".</p>
    #[serde(rename = "errorCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    /// <p>The message associated with any error encountered when this check is performed during this audit.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// <p>The number of resources that were found noncompliant during the check.</p>
    #[serde(rename = "nonCompliantResourcesCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_compliant_resources_count: Option<i64>,
    /// <p>The number of resources on which the check was performed.</p>
    #[serde(rename = "totalResourcesCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_resources_count: Option<i64>,
}

/// <p>The findings (results) of the audit.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuditFinding {
    /// <p>The audit check that generated this result.</p>
    #[serde(rename = "checkName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_name: Option<String>,
    /// <p>A unique identifier for this set of audit findings. This identifier is used to apply mitigation tasks to one or more sets of findings.</p>
    #[serde(rename = "findingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding_id: Option<String>,
    /// <p>The time the result (finding) was discovered.</p>
    #[serde(rename = "findingTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding_time: Option<f64>,
    /// <p>The resource that was found to be noncompliant with the audit check.</p>
    #[serde(rename = "nonCompliantResource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_compliant_resource: Option<NonCompliantResource>,
    /// <p>The reason the resource was noncompliant.</p>
    #[serde(rename = "reasonForNonCompliance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason_for_non_compliance: Option<String>,
    /// <p>A code that indicates the reason that the resource was noncompliant.</p>
    #[serde(rename = "reasonForNonComplianceCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason_for_non_compliance_code: Option<String>,
    /// <p>The list of related resources.</p>
    #[serde(rename = "relatedResources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub related_resources: Option<Vec<RelatedResource>>,
    /// <p>The severity of the result (finding).</p>
    #[serde(rename = "severity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub severity: Option<String>,
    /// <p>The ID of the audit that generated this result (finding).</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The time the audit started.</p>
    #[serde(rename = "taskStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_start_time: Option<f64>,
}

/// <p>Returned by ListAuditMitigationActionsTask, this object contains information that describes a mitigation action that has been started.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuditMitigationActionExecutionMetadata {
    /// <p>The unique identifier for the mitigation action being applied by the task.</p>
    #[serde(rename = "actionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_id: Option<String>,
    /// <p>The friendly name of the mitigation action being applied by the task.</p>
    #[serde(rename = "actionName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_name: Option<String>,
    /// <p>The date and time when the task was completed or canceled. Blank if the task is still running.</p>
    #[serde(rename = "endTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<f64>,
    /// <p>If an error occurred, the code that indicates which type of error occurred.</p>
    #[serde(rename = "errorCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_code: Option<String>,
    /// <p>The unique identifier for the findings to which the task and associated mitigation action are applied.</p>
    #[serde(rename = "findingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding_id: Option<String>,
    /// <p>If an error occurred, a message that describes the error.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// <p>The date and time when the task was started.</p>
    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<f64>,
    /// <p>The current status of the task being executed.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The unique identifier for the task that applies the mitigation action.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

/// <p>Information about an audit mitigation actions task that is returned by <code>ListAuditMitigationActionsTasks</code>.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuditMitigationActionsTaskMetadata {
    /// <p>The time at which the audit mitigation actions task was started.</p>
    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<f64>,
    /// <p>The unique identifier for the task.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The current state of the audit mitigation actions task.</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
}

/// <p>Used in MitigationActionParams, this information identifies the target findings to which the mitigation actions are applied. Only one entry appears.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuditMitigationActionsTaskTarget {
    /// <p>Specifies a filter in the form of an audit check and set of reason codes that identify the findings from the audit to which the audit mitigation actions task apply.</p>
    #[serde(rename = "auditCheckToReasonCodeFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_check_to_reason_code_filter: Option<::std::collections::HashMap<String, Vec<String>>>,
    /// <p>If the task will apply a mitigation action to findings from a specific audit, this value uniquely identifies the audit.</p>
    #[serde(rename = "auditTaskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_task_id: Option<String>,
    /// <p>If the task will apply a mitigation action to one or more listed findings, this value uniquely identifies those findings.</p>
    #[serde(rename = "findingIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding_ids: Option<Vec<String>>,
}

/// <p>Information about the targets to which audit notifications are sent.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuditNotificationTarget {
    /// <p>True if notifications to the target are enabled.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// <p>The ARN of the role that grants permission to send notifications to the target.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The ARN of the target (SNS topic) to which audit notifications are sent.</p>
    #[serde(rename = "targetArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_arn: Option<String>,
}

/// <p>The audits that were performed.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuditTaskMetadata {
    /// <p>The ID of this audit.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The status of this audit. One of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
    /// <p>The type of this audit. One of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
    #[serde(rename = "taskType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_type: Option<String>,
}

/// <p>A collection of authorization information.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuthInfo {
    /// <p>The type of action for which the principal is being authorized.</p>
    #[serde(rename = "actionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_type: Option<String>,
    /// <p>The resources for which the principal is being authorized to perform the specified action.</p>
    #[serde(rename = "resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resources: Option<Vec<String>>,
}

/// <p>The authorizer result.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuthResult {
    /// <p>The policies and statements that allowed the specified action.</p>
    #[serde(rename = "allowed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed: Option<Allowed>,
    /// <p>The final authorization decision of this scenario. Multiple statements are taken into account when determining the authorization decision. An explicit deny statement can override multiple allow statements.</p>
    #[serde(rename = "authDecision")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_decision: Option<String>,
    /// <p>Authorization information.</p>
    #[serde(rename = "authInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_info: Option<AuthInfo>,
    /// <p>The policies and statements that denied the specified action.</p>
    #[serde(rename = "denied")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub denied: Option<Denied>,
    /// <p>Contains any missing context values found while evaluating policy.</p>
    #[serde(rename = "missingContextValues")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub missing_context_values: Option<Vec<String>>,
}

/// <p>An object that specifies the authorization service for a domain.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuthorizerConfig {
    /// <p>A Boolean that specifies whether the domain configuration's authorization service can be overridden.</p>
    #[serde(rename = "allowAuthorizerOverride")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_authorizer_override: Option<bool>,
    /// <p>The name of the authorization service for a domain configuration.</p>
    #[serde(rename = "defaultAuthorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_authorizer_name: Option<String>,
}

/// <p>The authorizer description.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuthorizerDescription {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer's Lambda function ARN.</p>
    #[serde(rename = "authorizerFunctionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_function_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
    /// <p>The UNIX timestamp of when the authorizer was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The UNIX timestamp of when the authorizer was last updated.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>Specifies whether AWS IoT validates the token signature in an authorization request.</p>
    #[serde(rename = "signingDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signing_disabled: Option<bool>,
    /// <p>The status of the authorizer.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The key used to extract the token from the HTTP headers.</p>
    #[serde(rename = "tokenKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_key_name: Option<String>,
    /// <p>The public keys used to validate the token signature returned by your custom authentication service.</p>
    #[serde(rename = "tokenSigningPublicKeys")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_signing_public_keys: Option<::std::collections::HashMap<String, String>>,
}

/// <p>The authorizer summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct AuthorizerSummary {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

/// <p>Configuration for the rollout of OTA updates.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AwsJobExecutionsRolloutConfig {
    /// <p>The maximum number of OTA update job executions started per minute.</p>
    #[serde(rename = "maximumPerMinute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum_per_minute: Option<i64>,
}

/// <p>A Device Defender security profile behavior.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Behavior {
    /// <p>The criteria that determine if a device is behaving normally in regard to the <code>metric</code>.</p>
    #[serde(rename = "criteria")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub criteria: Option<BehaviorCriteria>,
    /// <p>What is measured by the behavior.</p>
    #[serde(rename = "metric")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metric: Option<String>,
    /// <p>The name you have given to the behavior.</p>
    #[serde(rename = "name")]
    pub name: String,
}

/// <p>The criteria by which the behavior is determined to be normal.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BehaviorCriteria {
    /// <p>The operator that relates the thing measured (<code>metric</code>) to the criteria (containing a <code>value</code> or <code>statisticalThreshold</code>).</p>
    #[serde(rename = "comparisonOperator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comparison_operator: Option<String>,
    /// <p>If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.</p>
    #[serde(rename = "consecutiveDatapointsToAlarm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consecutive_datapoints_to_alarm: Option<i64>,
    /// <p>If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.</p>
    #[serde(rename = "consecutiveDatapointsToClear")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consecutive_datapoints_to_clear: Option<i64>,
    /// <p>Use this to specify the time duration over which the behavior is evaluated, for those criteria which have a time dimension (for example, <code>NUM_MESSAGES_SENT</code>). For a <code>statisticalThreshhold</code> metric comparison, measurements from all devices are accumulated over this time duration before being used to calculate percentiles, and later, measurements from an individual device are also accumulated over this time duration before being given a percentile rank.</p>
    #[serde(rename = "durationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration_seconds: Option<i64>,
    /// <p>A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.</p>
    #[serde(rename = "statisticalThreshold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statistical_threshold: Option<StatisticalThreshold>,
    /// <p>The value to be compared with the <code>metric</code>.</p>
    #[serde(rename = "value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<MetricValue>,
}

/// <p>Additional information about the billing group.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct BillingGroupMetadata {
    /// <p>The date the billing group was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
}

/// <p>The properties of a billing group.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BillingGroupProperties {
    /// <p>The description of the billing group.</p>
    #[serde(rename = "billingGroupDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_description: Option<String>,
}

/// <p>A CA certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CACertificate {
    /// <p>The ARN of the CA certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the CA certificate.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The date the CA certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The status of the CA certificate.</p> <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>Describes a CA certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CACertificateDescription {
    /// <p>Whether the CA certificate configured for auto registration of device certificates. Valid values are "ENABLE" and "DISABLE"</p>
    #[serde(rename = "autoRegistrationStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_registration_status: Option<String>,
    /// <p>The CA certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The CA certificate ID.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The CA certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The date the CA certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The customer version of the CA certificate.</p>
    #[serde(rename = "customerVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer_version: Option<i64>,
    /// <p>The generation ID of the CA certificate.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>The date the CA certificate was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The owner of the CA certificate.</p>
    #[serde(rename = "ownedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owned_by: Option<String>,
    /// <p>The status of a CA certificate.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>When the CA certificate is valid.</p>
    #[serde(rename = "validity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity: Option<CertificateValidity>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelAuditMitigationActionsTaskRequest {
    /// <p>The unique identifier for the task that you want to cancel. </p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CancelAuditMitigationActionsTaskResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelAuditTaskRequest {
    /// <p>The ID of the audit you want to cancel. You can only cancel an audit that is "IN_PROGRESS".</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CancelAuditTaskResponse {}

/// <p>The input for the CancelCertificateTransfer operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelCertificateTransferRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelJobExecutionRequest {
    /// <p>(Optional) The expected current version of the job execution. Each time you update the job execution, its version is incremented. If the version of the job execution stored in Jobs does not match, the update is rejected with a VersionMismatch error, and an ErrorResponse that contains the current job execution status data is returned. (This makes it unnecessary to perform a separate DescribeJobExecution request in order to obtain the job execution status data.)</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>(Optional) If <code>true</code> the job execution will be canceled if it has status IN_PROGRESS or QUEUED, otherwise the job execution will be canceled only if it has status QUEUED. If you attempt to cancel a job execution that is IN_PROGRESS, and you do not set <code>force</code> to <code>true</code>, then an <code>InvalidStateTransitionException</code> will be thrown. The default is <code>false</code>.</p> <p>Canceling a job execution which is "IN_PROGRESS", will cause the device to be unable to update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The ID of the job to be canceled.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>A collection of name/value pairs that describe the status of the job execution. If not specified, the statusDetails are unchanged. You can specify at most 10 name/value pairs.</p>
    #[serde(rename = "statusDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_details: Option<::std::collections::HashMap<String, String>>,
    /// <p>The name of the thing whose execution of the job will be canceled.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CancelJobRequest {
    /// <p>An optional comment string describing why the job was canceled.</p>
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// <p>(Optional) If <code>true</code> job executions with status "IN_PROGRESS" and "QUEUED" are canceled, otherwise only job executions with status "QUEUED" are canceled. The default is <code>false</code>.</p> <p>Canceling a job which is "IN_PROGRESS", will cause a device which is executing the job to be unable to update the job execution status. Use caution and ensure that each device executing a job which is canceled is able to recover to a valid state.</p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>(Optional)A reason code string that explains why the job was canceled.</p>
    #[serde(rename = "reasonCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason_code: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CancelJobResponse {
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The job ARN.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

/// <p>Information about a certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct Certificate {
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The date and time the certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The status of the certificate.</p> <p>The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>Describes a certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CertificateDescription {
    /// <p>The certificate ID of the CA certificate used to sign this certificate.</p>
    #[serde(rename = "caCertificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ca_certificate_id: Option<String>,
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The date and time the certificate was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The customer version of the certificate.</p>
    #[serde(rename = "customerVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customer_version: Option<i64>,
    /// <p>The generation ID of the certificate.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>The date and time the certificate was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ID of the AWS account that owns the certificate.</p>
    #[serde(rename = "ownedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owned_by: Option<String>,
    /// <p>The ID of the AWS account of the previous owner of the certificate.</p>
    #[serde(rename = "previousOwnedBy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_owned_by: Option<String>,
    /// <p>The status of the certificate.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The transfer data.</p>
    #[serde(rename = "transferData")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_data: Option<TransferData>,
    /// <p>When the certificate is valid.</p>
    #[serde(rename = "validity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validity: Option<CertificateValidity>,
}

/// <p>When the certificate is valid.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CertificateValidity {
    /// <p>The certificate is not valid after this date.</p>
    #[serde(rename = "notAfter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_after: Option<f64>,
    /// <p>The certificate is not valid before this date.</p>
    #[serde(rename = "notBefore")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub not_before: Option<f64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ClearDefaultAuthorizerRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ClearDefaultAuthorizerResponse {}

/// <p>Describes an action that updates a CloudWatch alarm.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CloudwatchAlarmAction {
    /// <p>The CloudWatch alarm name.</p>
    #[serde(rename = "alarmName")]
    pub alarm_name: String,
    /// <p>The IAM role that allows access to the CloudWatch alarm.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The reason for the alarm change.</p>
    #[serde(rename = "stateReason")]
    pub state_reason: String,
    /// <p>The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.</p>
    #[serde(rename = "stateValue")]
    pub state_value: String,
}

/// <p>Describes an action that captures a CloudWatch metric.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CloudwatchMetricAction {
    /// <p>The CloudWatch metric name.</p>
    #[serde(rename = "metricName")]
    pub metric_name: String,
    /// <p>The CloudWatch metric namespace name.</p>
    #[serde(rename = "metricNamespace")]
    pub metric_namespace: String,
    /// <p>An optional <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp">Unix timestamp</a>.</p>
    #[serde(rename = "metricTimestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metric_timestamp: Option<String>,
    /// <p>The <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit">metric unit</a> supported by CloudWatch.</p>
    #[serde(rename = "metricUnit")]
    pub metric_unit: String,
    /// <p>The CloudWatch metric value.</p>
    #[serde(rename = "metricValue")]
    pub metric_value: String,
    /// <p>The IAM role that allows access to the CloudWatch metric.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>Describes the method to use when code signing a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSigning {
    /// <p>The ID of the AWSSignerJob which was created to sign the file.</p>
    #[serde(rename = "awsSignerJobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_signer_job_id: Option<String>,
    /// <p>A custom method for code signing a file.</p>
    #[serde(rename = "customCodeSigning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_code_signing: Option<CustomCodeSigning>,
    /// <p>Describes the code-signing job.</p>
    #[serde(rename = "startSigningJobParameter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_signing_job_parameter: Option<StartSigningJobParameter>,
}

/// <p>Describes the certificate chain being used when code signing a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSigningCertificateChain {
    /// <p>The name of the certificate.</p>
    #[serde(rename = "certificateName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_name: Option<String>,
    /// <p>A base64 encoded binary representation of the code signing certificate chain.</p>
    #[serde(rename = "inlineDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inline_document: Option<String>,
}

/// <p>Describes the signature for a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSigningSignature {
    /// <p>A base64 encoded binary representation of the code signing signature.</p>
    #[serde(rename = "inlineDocument")]
    #[serde(
        deserialize_with = "::rusoto_core::serialization::SerdeBlob::deserialize_blob",
        serialize_with = "::rusoto_core::serialization::SerdeBlob::serialize_blob",
        default
    )]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub inline_document: Option<bytes::Bytes>,
}

/// <p>Configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Configuration {
    /// <p>True to enable the configuration.</p>
    #[serde(rename = "Enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ConfirmTopicRuleDestinationRequest {
    /// <p>The token used to confirm ownership or access to the topic rule confirmation URL.</p>
    #[serde(rename = "confirmationToken")]
    pub confirmation_token: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ConfirmTopicRuleDestinationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateAuthorizerRequest {
    /// <p>The ARN of the authorizer's Lambda function.</p>
    #[serde(rename = "authorizerFunctionArn")]
    pub authorizer_function_arn: String,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
    /// <p>Specifies whether AWS IoT validates the token signature in an authorization request.</p>
    #[serde(rename = "signingDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signing_disabled: Option<bool>,
    /// <p>The status of the create authorizer request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The name of the token key used to extract the token from the HTTP headers.</p>
    #[serde(rename = "tokenKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_key_name: Option<String>,
    /// <p>The public keys used to verify the digital signature returned by your custom authentication service.</p>
    #[serde(rename = "tokenSigningPublicKeys")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_signing_public_keys: Option<::std::collections::HashMap<String, String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateAuthorizerResponse {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer's name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateBillingGroupRequest {
    /// <p>The name you wish to give to the billing group.</p>
    #[serde(rename = "billingGroupName")]
    pub billing_group_name: String,
    /// <p>The properties of the billing group.</p>
    #[serde(rename = "billingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_properties: Option<BillingGroupProperties>,
    /// <p>Metadata which can be used to manage the billing group.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateBillingGroupResponse {
    /// <p>The ARN of the billing group.</p>
    #[serde(rename = "billingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_arn: Option<String>,
    /// <p>The ID of the billing group.</p>
    #[serde(rename = "billingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_id: Option<String>,
    /// <p>The name you gave to the billing group.</p>
    #[serde(rename = "billingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_name: Option<String>,
}

/// <p>The input for the CreateCertificateFromCsr operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateCertificateFromCsrRequest {
    /// <p>The certificate signing request (CSR).</p>
    #[serde(rename = "certificateSigningRequest")]
    pub certificate_signing_request: String,
    /// <p>Specifies whether the certificate is active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
}

/// <p>The output from the CreateCertificateFromCsr operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateCertificateFromCsrResponse {
    /// <p>The Amazon Resource Name (ARN) of the certificate. You can use the ARN as a principal for policy operations.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate. Certificate management operations only take a certificateId.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateDomainConfigurationRequest {
    /// <p>An object that specifies the authorization service for a domain.</p>
    #[serde(rename = "authorizerConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_config: Option<AuthorizerConfig>,
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    #[serde(rename = "domainConfigurationName")]
    pub domain_configuration_name: String,
    /// <p>The name of the domain.</p>
    #[serde(rename = "domainName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_name: Option<String>,
    /// <p>The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS-managed domains.</p>
    #[serde(rename = "serverCertificateArns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_certificate_arns: Option<Vec<String>>,
    /// <p>The type of service delivered by the endpoint.</p>
    #[serde(rename = "serviceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_type: Option<String>,
    /// <p>The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for AWS-managed domains.</p>
    #[serde(rename = "validationCertificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validation_certificate_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateDomainConfigurationResponse {
    /// <p>The ARN of the domain configuration.</p>
    #[serde(rename = "domainConfigurationArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_arn: Option<String>,
    /// <p>The name of the domain configuration.</p>
    #[serde(rename = "domainConfigurationName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateDynamicThingGroupRequest {
    /// <p><p>The dynamic thing group index name.</p> <note> <p>Currently one index is supported: &quot;AWS_Things&quot;.</p> </note></p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The dynamic thing group search query string.</p> <p>See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html">Query Syntax</a> for information about query string syntax.</p>
    #[serde(rename = "queryString")]
    pub query_string: String,
    /// <p><p>The dynamic thing group query version.</p> <note> <p>Currently one query version is supported: &quot;2017-09-30&quot;. If not specified, the query version defaults to this value.</p> </note></p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
    /// <p>Metadata which can be used to manage the dynamic thing group.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>The dynamic thing group name to create.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
    /// <p>The dynamic thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_properties: Option<ThingGroupProperties>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateDynamicThingGroupResponse {
    /// <p>The dynamic thing group index name.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The dynamic thing group search query string.</p>
    #[serde(rename = "queryString")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_string: Option<String>,
    /// <p>The dynamic thing group query version.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
    /// <p>The dynamic thing group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The dynamic thing group ID.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>The dynamic thing group name.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateJobRequest {
    /// <p>Allows you to create criteria to abort a job.</p>
    #[serde(rename = "abortConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub abort_config: Option<AbortConfig>,
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p><p>The job document.</p> <note> <p>If the job document resides in an S3 bucket, you must use a placeholder link when specifying the document.</p> <p>The placeholder link is of the following form:</p> <p> <code>${aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>}</code> </p> <p>where <i>bucket</i> is your bucket name and <i>key</i> is the object in the bucket to which you are linking.</p> </note></p>
    #[serde(rename = "document")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document: Option<String>,
    /// <p>An S3 link to the job document.</p>
    #[serde(rename = "documentSource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document_source: Option<String>,
    /// <p>Allows you to create a staged rollout of the job.</p>
    #[serde(rename = "jobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_executions_rollout_config: Option<JobExecutionsRolloutConfig>,
    /// <p>A job identifier which must be unique for your AWS account. We recommend using a UUID. Alpha-numeric characters, "-" and "_" are valid for use here.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    #[serde(rename = "presignedUrlConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presigned_url_config: Option<PresignedUrlConfig>,
    /// <p>Metadata which can be used to manage the job.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>A list of things and thing groups to which the job should be sent.</p>
    #[serde(rename = "targets")]
    pub targets: Vec<String>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    #[serde(rename = "timeoutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout_config: Option<TimeoutConfig>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateJobResponse {
    /// <p>The job description.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The job ARN.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

/// <p>The input for the CreateKeysAndCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateKeysAndCertificateRequest {
    /// <p>Specifies whether the certificate is active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
}

/// <p>The output of the CreateKeysAndCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateKeysAndCertificateResponse {
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The ID of the certificate. AWS IoT issues a default subject name for the certificate (for example, AWS IoT Certificate).</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The generated key pair.</p>
    #[serde(rename = "keyPair")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_pair: Option<KeyPair>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateMitigationActionRequest {
    /// <p>A friendly name for the action. Choose a friendly name that accurately describes the action (for example, <code>EnableLoggingAction</code>).</p>
    #[serde(rename = "actionName")]
    pub action_name: String,
    /// <p>Defines the type of action and the parameters for that action.</p>
    #[serde(rename = "actionParams")]
    pub action_params: MitigationActionParams,
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>Metadata that can be used to manage the mitigation action.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateMitigationActionResponse {
    /// <p>The ARN for the new mitigation action.</p>
    #[serde(rename = "actionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_arn: Option<String>,
    /// <p>A unique identifier for the new mitigation action.</p>
    #[serde(rename = "actionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateOTAUpdateRequest {
    /// <p>A list of additional OTA update parameters which are name-value pairs.</p>
    #[serde(rename = "additionalParameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_parameters: Option<::std::collections::HashMap<String, String>>,
    /// <p>Configuration for the rollout of OTA updates.</p>
    #[serde(rename = "awsJobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_job_executions_rollout_config: Option<AwsJobExecutionsRolloutConfig>,
    /// <p>The description of the OTA update.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files to be streamed by the OTA update.</p>
    #[serde(rename = "files")]
    pub files: Vec<OTAUpdateFile>,
    /// <p>The ID of the OTA update to be created.</p>
    #[serde(rename = "otaUpdateId")]
    pub ota_update_id: String,
    /// <p>The IAM role that allows access to the AWS IoT Jobs service.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>Metadata which can be used to manage updates.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all the things specified as targets have completed the update (SNAPSHOT). If continuous, the update may also be run on a thing when a change is detected in a target. For example, an update will run on a thing when the thing is added to a target group, even after the update was completed by all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT.</p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>The targeted devices to receive OTA updates.</p>
    #[serde(rename = "targets")]
    pub targets: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateOTAUpdateResponse {
    /// <p>The AWS IoT job ARN associated with the OTA update.</p>
    #[serde(rename = "awsIotJobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_arn: Option<String>,
    /// <p>The AWS IoT job ID associated with the OTA update.</p>
    #[serde(rename = "awsIotJobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_id: Option<String>,
    /// <p>The OTA update ARN.</p>
    #[serde(rename = "otaUpdateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_arn: Option<String>,
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_id: Option<String>,
    /// <p>The OTA update status.</p>
    #[serde(rename = "otaUpdateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_status: Option<String>,
}

/// <p>The input for the CreatePolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreatePolicyRequest {
    /// <p>The JSON document that describes the policy. <b>policyDocument</b> must have a minimum length of 1, with a maximum length of 2048, excluding whitespace.</p>
    #[serde(rename = "policyDocument")]
    pub policy_document: String,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the CreatePolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreatePolicyResponse {
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

/// <p>The input for the CreatePolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreatePolicyVersionRequest {
    /// <p>The JSON document that describes the policy. Minimum length of 1. Maximum length of 2048, excluding whitespace.</p>
    #[serde(rename = "policyDocument")]
    pub policy_document: String,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>Specifies whether the policy version is set as the default. When this parameter is true, the new policy version becomes the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    #[serde(rename = "setAsDefault")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_default: Option<bool>,
}

/// <p>The output of the CreatePolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreatePolicyVersionResponse {
    /// <p>Specifies whether the policy version is the default.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateProvisioningClaimRequest {
    /// <p>The name of the provisioning template to use.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateProvisioningClaimResponse {
    /// <p>The ID of the certificate.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The provisioning claim certificate.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>The provisioning claim expiration time.</p>
    #[serde(rename = "expiration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiration: Option<f64>,
    /// <p>The provisioning claim key pair.</p>
    #[serde(rename = "keyPair")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_pair: Option<KeyPair>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateProvisioningTemplateRequest {
    /// <p>The description of the fleet provisioning template.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// <p>The role ARN for the role associated with the fleet provisioning template. This IoT role grants permission to provision a device.</p>
    #[serde(rename = "provisioningRoleArn")]
    pub provisioning_role_arn: String,
    /// <p><p>Metadata which can be used to manage the fleet provisioning template.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: &amp;&amp;tags &quot;key1=value1&amp;key2=value2...&quot;</p> <p>For the cli-input-json file use format: &quot;tags&quot;: &quot;key1=value1&amp;key2=value2...&quot;</p> </note></p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    #[serde(rename = "templateBody")]
    pub template_body: String,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateProvisioningTemplateResponse {
    /// <p>The default version of the fleet provisioning template.</p>
    #[serde(rename = "defaultVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_version_id: Option<i64>,
    /// <p>The ARN that identifies the provisioning template.</p>
    #[serde(rename = "templateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_arn: Option<String>,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateProvisioningTemplateVersionRequest {
    /// <p>Sets a fleet provision template version as the default version.</p>
    #[serde(rename = "setAsDefault")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_default: Option<bool>,
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    #[serde(rename = "templateBody")]
    pub template_body: String,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateProvisioningTemplateVersionResponse {
    /// <p>True if the fleet provisioning template version is the default version, otherwise false.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The ARN that identifies the provisioning template.</p>
    #[serde(rename = "templateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_arn: Option<String>,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_name: Option<String>,
    /// <p>The version of the fleet provisioning template.</p>
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateRoleAliasRequest {
    /// <p>How long (in seconds) the credentials will be valid.</p>
    #[serde(rename = "credentialDurationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential_duration_seconds: Option<i64>,
    /// <p>The role alias that points to a role ARN. This allows you to change the role without having to update the device.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
    /// <p>The role ARN.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateRoleAliasResponse {
    /// <p>The role alias.</p>
    #[serde(rename = "roleAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias: Option<String>,
    /// <p>The role alias ARN.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateScheduledAuditRequest {
    /// <p>The day of the month on which the scheduled audit takes place. Can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to "MONTHLY". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit takes place. Can be one of "SUN", "MON", "TUE", "WED", "THU", "FRI", or "SAT". This field is required if the "frequency" parameter is set to "WEEKLY" or "BIWEEKLY".</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place. Can be one of "DAILY", "WEEKLY", "BIWEEKLY" or "MONTHLY". The start time of each audit is determined by the system.</p>
    #[serde(rename = "frequency")]
    pub frequency: String,
    /// <p>The name you want to give to the scheduled audit. (Max. 128 chars)</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
    /// <p>Metadata that can be used to manage the scheduled audit.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    #[serde(rename = "targetCheckNames")]
    pub target_check_names: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateScheduledAuditResponse {
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateSecurityProfileRequest {
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here.</p>
    #[serde(rename = "additionalMetricsToRetain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_metrics_to_retain: Option<Vec<String>>,
    /// <p>Specifies the destinations to which alerts are sent. (Alerts are always sent to the console.) Alerts are generated when a device (thing) violates a behavior.</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>A description of the security profile.</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name you are giving to the security profile.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
    /// <p>Metadata that can be used to manage the security profile.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateSecurityProfileResponse {
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "securityProfileArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_arn: Option<String>,
    /// <p>The name you gave to the security profile.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateStreamRequest {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files to stream.</p>
    #[serde(rename = "files")]
    pub files: Vec<StreamFile>,
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
    /// <p>Metadata which can be used to manage streams.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateStreamResponse {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The version of the stream.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateThingGroupRequest {
    /// <p>The name of the parent thing group.</p>
    #[serde(rename = "parentGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group_name: Option<String>,
    /// <p>Metadata which can be used to manage the thing group.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>The thing group name to create.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
    /// <p>The thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_properties: Option<ThingGroupProperties>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateThingGroupResponse {
    /// <p>The thing group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The thing group ID.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>The thing group name.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
}

/// <p>The input for the CreateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateThingRequest {
    /// <p>The attribute payload, which consists of up to three name/value pairs in a JSON document. For example:</p> <p> <code>{\"attributes\":{\"string1\":\"string2\"}}</code> </p>
    #[serde(rename = "attributePayload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_payload: Option<AttributePayload>,
    /// <p>The name of the billing group the thing will be added to.</p>
    #[serde(rename = "billingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_name: Option<String>,
    /// <p>The name of the thing to create.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
    /// <p>The name of the thing type associated with the new thing.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output of the CreateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateThingResponse {
    /// <p>The ARN of the new thing.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The thing ID.</p>
    #[serde(rename = "thingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_id: Option<String>,
    /// <p>The name of the new thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

/// <p>The input for the CreateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateThingTypeRequest {
    /// <p>Metadata which can be used to manage the thing type.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
    /// <p>The ThingTypeProperties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names.</p>
    #[serde(rename = "thingTypeProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_properties: Option<ThingTypeProperties>,
}

/// <p>The output of the CreateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateThingTypeResponse {
    /// <p>The Amazon Resource Name (ARN) of the thing type.</p>
    #[serde(rename = "thingTypeArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_arn: Option<String>,
    /// <p>The thing type ID.</p>
    #[serde(rename = "thingTypeId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_id: Option<String>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateTopicRuleDestinationRequest {
    /// <p>The topic rule destination configuration.</p>
    #[serde(rename = "destinationConfiguration")]
    pub destination_configuration: TopicRuleDestinationConfiguration,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct CreateTopicRuleDestinationResponse {
    /// <p>The topic rule destination.</p>
    #[serde(rename = "topicRuleDestination")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_rule_destination: Option<TopicRuleDestination>,
}

/// <p>The input for the CreateTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct CreateTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
    /// <p><p>Metadata which can be used to manage the topic rule.</p> <note> <p>For URI Request parameters use format: ...key1=value1&amp;key2=value2...</p> <p>For the CLI command-line parameter use format: --tags &quot;key1=value1&amp;key2=value2...&quot;</p> <p>For the cli-input-json file use format: &quot;tags&quot;: &quot;key1=value1&amp;key2=value2...&quot;</p> </note></p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<String>,
    /// <p>The rule payload.</p>
    #[serde(rename = "topicRulePayload")]
    pub topic_rule_payload: TopicRulePayload,
}

/// <p>Describes a custom method used to code sign a file.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomCodeSigning {
    /// <p>The certificate chain.</p>
    #[serde(rename = "certificateChain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_chain: Option<CodeSigningCertificateChain>,
    /// <p>The hash algorithm used to code sign the file.</p>
    #[serde(rename = "hashAlgorithm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hash_algorithm: Option<String>,
    /// <p>The signature for the file.</p>
    #[serde(rename = "signature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<CodeSigningSignature>,
    /// <p>The signature algorithm used to code sign the file.</p>
    #[serde(rename = "signatureAlgorithm")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature_algorithm: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteAccountAuditConfigurationRequest {
    /// <p>If true, all scheduled audits are deleted.</p>
    #[serde(rename = "deleteScheduledAudits")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_scheduled_audits: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteAccountAuditConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteAuthorizerRequest {
    /// <p>The name of the authorizer to delete.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteAuthorizerResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteBillingGroupRequest {
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    pub billing_group_name: String,
    /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>DeleteBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteBillingGroupResponse {}

/// <p>Input for the DeleteCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteCACertificateRequest {
    /// <p>The ID of the certificate to delete. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

/// <p>The output for the DeleteCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteCACertificateResponse {}

/// <p>The input for the DeleteCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>Forces the deletion of a certificate if it is inactive and is not attached to an IoT thing.</p>
    #[serde(rename = "forceDelete")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_delete: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteDomainConfigurationRequest {
    /// <p>The name of the domain configuration to be deleted.</p>
    #[serde(rename = "domainConfigurationName")]
    pub domain_configuration_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteDomainConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteDynamicThingGroupRequest {
    /// <p>The expected version of the dynamic thing group to delete.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the dynamic thing group to delete.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteDynamicThingGroupResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteJobExecutionRequest {
    /// <p>The ID of the job execution to be deleted. The <code>executionNumber</code> refers to the execution of a particular job on a particular device.</p> <p>Note that once a job execution is deleted, the <code>executionNumber</code> may be reused by IoT, so be sure you get and use the correct value here.</p>
    #[serde(rename = "executionNumber")]
    pub execution_number: i64,
    /// <p><p>(Optional) When true, you can delete a job execution which is &quot;IN<em>PROGRESS&quot;. Otherwise, you can only delete a job execution which is in a terminal state (&quot;SUCCEEDED&quot;, &quot;FAILED&quot;, &quot;REJECTED&quot;, &quot;REMOVED&quot; or &quot;CANCELED&quot;) or an exception will occur. The default is false.</p> <note> <p>Deleting a job execution which is &quot;IN</em>PROGRESS&quot;, will cause the device to be unable to access job information or update the job execution status. Use caution and ensure that the device is able to recover to a valid state.</p> </note></p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The ID of the job whose execution on a particular device will be deleted.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>The name of the thing whose job execution will be deleted.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteJobRequest {
    /// <p><p>(Optional) When true, you can delete a job which is &quot;IN<em>PROGRESS&quot;. Otherwise, you can only delete a job which is in a terminal state (&quot;COMPLETED&quot; or &quot;CANCELED&quot;) or an exception will occur. The default is false.</p> <note> <p>Deleting a job which is &quot;IN</em>PROGRESS&quot;, will cause a device which is executing the job to be unable to access job information or update the job execution status. Use caution and ensure that each device executing a job which is deleted is able to recover to a valid state.</p> </note></p>
    #[serde(rename = "force")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
    /// <p>The ID of the job to be deleted.</p> <p>After a job deletion is completed, you may reuse this jobId when you create a new job. However, this is not recommended, and you must ensure that your devices are not using the jobId to refer to the deleted job.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteMitigationActionRequest {
    /// <p>The name of the mitigation action that you want to delete.</p>
    #[serde(rename = "actionName")]
    pub action_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteMitigationActionResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteOTAUpdateRequest {
    /// <p>Specifies if the stream associated with an OTA update should be deleted when the OTA update is deleted.</p>
    #[serde(rename = "deleteStream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_stream: Option<bool>,
    /// <p>Specifies if the AWS Job associated with the OTA update should be deleted with the OTA update is deleted.</p>
    #[serde(rename = "forceDeleteAWSJob")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_delete_aws_job: Option<bool>,
    /// <p>The OTA update ID to delete.</p>
    #[serde(rename = "otaUpdateId")]
    pub ota_update_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteOTAUpdateResponse {}

/// <p>The input for the DeletePolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeletePolicyRequest {
    /// <p>The name of the policy to delete.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The input for the DeletePolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeletePolicyVersionRequest {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    pub policy_version_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteProvisioningTemplateRequest {
    /// <p>The name of the fleet provision template to delete.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteProvisioningTemplateResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteProvisioningTemplateVersionRequest {
    /// <p>The name of the fleet provisioning template version to delete.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
    /// <p>The fleet provisioning template version ID to delete.</p>
    #[serde(rename = "versionId")]
    pub version_id: i64,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteProvisioningTemplateVersionResponse {}

/// <p>The input for the DeleteRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteRegistrationCodeRequest {}

/// <p>The output for the DeleteRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteRegistrationCodeResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteRoleAliasRequest {
    /// <p>The role alias to delete.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteRoleAliasResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteScheduledAuditRequest {
    /// <p>The name of the scheduled audit you want to delete.</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteScheduledAuditResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteSecurityProfileRequest {
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the security profile to be deleted.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteSecurityProfileResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteStreamRequest {
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteStreamResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteThingGroupRequest {
    /// <p>The expected version of the thing group to delete.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the thing group to delete.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteThingGroupResponse {}

/// <p>The input for the DeleteThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteThingRequest {
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>DeleteThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The name of the thing to delete.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output of the DeleteThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteThingResponse {}

/// <p>The input for the DeleteThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteThingTypeRequest {
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
}

/// <p>The output for the DeleteThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteThingTypeResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteTopicRuleDestinationRequest {
    /// <p>The ARN of the topic rule destination to delete.</p>
    #[serde(rename = "arn")]
    pub arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeleteTopicRuleDestinationResponse {}

/// <p>The input for the DeleteTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeleteV2LoggingLevelRequest {
    /// <p>The name of the resource for which you are configuring logging.</p>
    #[serde(rename = "targetName")]
    pub target_name: String,
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    #[serde(rename = "targetType")]
    pub target_type: String,
}

/// <p>Contains information that denied the authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct Denied {
    /// <p>Information that explicitly denies the authorization. </p>
    #[serde(rename = "explicitDeny")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub explicit_deny: Option<ExplicitDeny>,
    /// <p>Information that implicitly denies the authorization. When a policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.</p>
    #[serde(rename = "implicitDeny")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub implicit_deny: Option<ImplicitDeny>,
}

/// <p>The input for the DeprecateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DeprecateThingTypeRequest {
    /// <p>The name of the thing type to deprecate.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
    /// <p>Whether to undeprecate a deprecated thing type. If <b>true</b>, the thing type will not be deprecated anymore and you can associate it with things.</p>
    #[serde(rename = "undoDeprecate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub undo_deprecate: Option<bool>,
}

/// <p>The output for the DeprecateThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DeprecateThingTypeResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAccountAuditConfigurationRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeAccountAuditConfigurationResponse {
    /// <p>Which audit checks are enabled and disabled for this account.</p>
    #[serde(rename = "auditCheckConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_check_configurations:
        Option<::std::collections::HashMap<String, AuditCheckConfiguration>>,
    /// <p>Information about the targets to which audit notifications are sent for this account.</p>
    #[serde(rename = "auditNotificationTargetConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_notification_target_configurations:
        Option<::std::collections::HashMap<String, AuditNotificationTarget>>,
    /// <p>The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates, and other items as required when performing an audit.</p> <p>On the first call to <code>UpdateAccountAuditConfiguration</code>, this parameter is required.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAuditFindingRequest {
    /// <p>A unique identifier for a single audit finding. You can use this identifier to apply mitigation actions to the finding.</p>
    #[serde(rename = "findingId")]
    pub finding_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeAuditFindingResponse {
    #[serde(rename = "finding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding: Option<AuditFinding>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAuditMitigationActionsTaskRequest {
    /// <p>The unique identifier for the audit mitigation task.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeAuditMitigationActionsTaskResponse {
    /// <p>Specifies the mitigation actions and their parameters that are applied as part of this task.</p>
    #[serde(rename = "actionsDefinition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions_definition: Option<Vec<MitigationAction>>,
    /// <p>Specifies the mitigation actions that should be applied to specific audit checks.</p>
    #[serde(rename = "auditCheckToActionsMapping")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_check_to_actions_mapping: Option<::std::collections::HashMap<String, Vec<String>>>,
    /// <p>The date and time when the task was completed or canceled.</p>
    #[serde(rename = "endTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<f64>,
    /// <p>The date and time when the task was started.</p>
    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<f64>,
    /// <p>Identifies the findings to which the mitigation actions are applied. This can be by audit checks, by audit task, or a set of findings.</p>
    #[serde(rename = "target")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<AuditMitigationActionsTaskTarget>,
    /// <p>Aggregate counts of the results when the mitigation tasks were applied to the findings for this audit mitigation actions task.</p>
    #[serde(rename = "taskStatistics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_statistics: Option<::std::collections::HashMap<String, TaskStatisticsForAuditCheck>>,
    /// <p>The current status of the task.</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAuditTaskRequest {
    /// <p>The ID of the audit whose information you want to get.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeAuditTaskResponse {
    /// <p>Detailed information about each check performed during this audit.</p>
    #[serde(rename = "auditDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_details: Option<::std::collections::HashMap<String, AuditCheckDetails>>,
    /// <p>The name of the scheduled audit (only if the audit was a scheduled audit).</p>
    #[serde(rename = "scheduledAuditName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_name: Option<String>,
    /// <p>The time the audit started.</p>
    #[serde(rename = "taskStartTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_start_time: Option<f64>,
    /// <p>Statistical information about the audit.</p>
    #[serde(rename = "taskStatistics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_statistics: Option<TaskStatistics>,
    /// <p>The status of the audit: one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
    /// <p>The type of audit: "ON_DEMAND_AUDIT_TASK" or "SCHEDULED_AUDIT_TASK".</p>
    #[serde(rename = "taskType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeAuthorizerRequest {
    /// <p>The name of the authorizer to describe.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeAuthorizerResponse {
    /// <p>The authorizer description.</p>
    #[serde(rename = "authorizerDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_description: Option<AuthorizerDescription>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeBillingGroupRequest {
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    pub billing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeBillingGroupResponse {
    /// <p>The ARN of the billing group.</p>
    #[serde(rename = "billingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_arn: Option<String>,
    /// <p>The ID of the billing group.</p>
    #[serde(rename = "billingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_id: Option<String>,
    /// <p>Additional information about the billing group.</p>
    #[serde(rename = "billingGroupMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_metadata: Option<BillingGroupMetadata>,
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_name: Option<String>,
    /// <p>The properties of the billing group.</p>
    #[serde(rename = "billingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_properties: Option<BillingGroupProperties>,
    /// <p>The version of the billing group.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// <p>The input for the DescribeCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeCACertificateRequest {
    /// <p>The CA certificate identifier.</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

/// <p>The output from the DescribeCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeCACertificateResponse {
    /// <p>The CA certificate description.</p>
    #[serde(rename = "certificateDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_description: Option<CACertificateDescription>,
    /// <p>Information about the registration configuration.</p>
    #[serde(rename = "registrationConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_config: Option<RegistrationConfig>,
}

/// <p>The input for the DescribeCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
}

/// <p>The output of the DescribeCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeCertificateResponse {
    /// <p>The description of the certificate.</p>
    #[serde(rename = "certificateDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_description: Option<CertificateDescription>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeDefaultAuthorizerRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeDefaultAuthorizerResponse {
    /// <p>The default authorizer's description.</p>
    #[serde(rename = "authorizerDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_description: Option<AuthorizerDescription>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeDomainConfigurationRequest {
    /// <p>The name of the domain configuration.</p>
    #[serde(rename = "domainConfigurationName")]
    pub domain_configuration_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeDomainConfigurationResponse {
    /// <p>An object that specifies the authorization service for a domain.</p>
    #[serde(rename = "authorizerConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_config: Option<AuthorizerConfig>,
    /// <p>The ARN of the domain configuration.</p>
    #[serde(rename = "domainConfigurationArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_arn: Option<String>,
    /// <p>The name of the domain configuration.</p>
    #[serde(rename = "domainConfigurationName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_name: Option<String>,
    /// <p>A Boolean value that specifies the current state of the domain configuration.</p>
    #[serde(rename = "domainConfigurationStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_status: Option<String>,
    /// <p>The name of the domain.</p>
    #[serde(rename = "domainName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_name: Option<String>,
    /// <p>The type of the domain.</p>
    #[serde(rename = "domainType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_type: Option<String>,
    /// <p>A list containing summary information about the server certificate included in the domain configuration.</p>
    #[serde(rename = "serverCertificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_certificates: Option<Vec<ServerCertificateSummary>>,
    /// <p>The type of service delivered by the endpoint.</p>
    #[serde(rename = "serviceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_type: Option<String>,
}

/// <p>The input for the DescribeEndpoint operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeEndpointRequest {
    /// <p><p>The endpoint type. Valid endpoint types include:</p> <ul> <li> <p> <code>iot:Data</code> - Returns a VeriSign signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Data-ATS</code> - Returns an ATS signed data endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:CredentialProvider</code> - Returns an AWS IoT credentials provider API endpoint.</p> </li> </ul> <ul> <li> <p> <code>iot:Jobs</code> - Returns an AWS IoT device management Jobs API endpoint.</p> </li> </ul></p>
    #[serde(rename = "endpointType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_type: Option<String>,
}

/// <p>The output from the DescribeEndpoint operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeEndpointResponse {
    /// <p>The endpoint. The format of the endpoint is as follows: <i>identifier</i>.iot.<i>region</i>.amazonaws.com.</p>
    #[serde(rename = "endpointAddress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub endpoint_address: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeEventConfigurationsRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeEventConfigurationsResponse {
    /// <p>The creation date of the event configuration.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The event configurations.</p>
    #[serde(rename = "eventConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_configurations: Option<::std::collections::HashMap<String, Configuration>>,
    /// <p>The date the event configurations were last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeIndexRequest {
    /// <p>The index name.</p>
    #[serde(rename = "indexName")]
    pub index_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeIndexResponse {
    /// <p>The index name.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The index status.</p>
    #[serde(rename = "indexStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_status: Option<String>,
    /// <p><p>Contains a value that specifies the type of indexing performed. Valid values are:</p> <ul> <li> <p>REGISTRY  Your thing index contains only registry data.</p> </li> <li> <p>REGISTRY<em>AND</em>SHADOW - Your thing index contains registry data and shadow data.</p> </li> <li> <p>REGISTRY<em>AND</em>CONNECTIVITY<em>STATUS - Your thing index contains registry data and thing connectivity status data.</p> </li> <li> <p>REGISTRY</em>AND<em>SHADOW</em>AND<em>CONNECTIVITY</em>STATUS - Your thing index contains registry data, shadow data, and thing connectivity status data.</p> </li> </ul></p>
    #[serde(rename = "schema")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeJobExecutionRequest {
    /// <p>A string (consisting of the digits "0" through "9" which is used to specify a particular job execution on a particular device.</p>
    #[serde(rename = "executionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_number: Option<i64>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>The name of the thing on which the job execution is running.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeJobExecutionResponse {
    /// <p>Information about the job execution.</p>
    #[serde(rename = "execution")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution: Option<JobExecution>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeJobRequest {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeJobResponse {
    /// <p>An S3 link to the job document.</p>
    #[serde(rename = "documentSource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document_source: Option<String>,
    /// <p>Information about the job.</p>
    #[serde(rename = "job")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job: Option<Job>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeMitigationActionRequest {
    /// <p>The friendly name that uniquely identifies the mitigation action.</p>
    #[serde(rename = "actionName")]
    pub action_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeMitigationActionResponse {
    /// <p>The ARN that identifies this migration action.</p>
    #[serde(rename = "actionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_arn: Option<String>,
    /// <p>A unique identifier for this action.</p>
    #[serde(rename = "actionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_id: Option<String>,
    /// <p>The friendly name that uniquely identifies the mitigation action.</p>
    #[serde(rename = "actionName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_name: Option<String>,
    /// <p>Parameters that control how the mitigation action is applied, specific to the type of mitigation action.</p>
    #[serde(rename = "actionParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_params: Option<MitigationActionParams>,
    /// <p>The type of mitigation action.</p>
    #[serde(rename = "actionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_type: Option<String>,
    /// <p>The date and time when the mitigation action was added to your AWS account.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The date and time when the mitigation action was last changed.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the IAM role used to apply this action.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeProvisioningTemplateRequest {
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeProvisioningTemplateResponse {
    /// <p>The date when the fleet provisioning template was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The default fleet template version ID.</p>
    #[serde(rename = "defaultVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_version_id: Option<i64>,
    /// <p>The description of the fleet provisioning template.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>True if the fleet provisioning template is enabled, otherwise false.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// <p>The date when the fleet provisioning template was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.</p>
    #[serde(rename = "provisioningRoleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provisioning_role_arn: Option<String>,
    /// <p>The ARN of the fleet provisioning template.</p>
    #[serde(rename = "templateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_arn: Option<String>,
    /// <p>The JSON formatted contents of the fleet provisioning template.</p>
    #[serde(rename = "templateBody")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_body: Option<String>,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeProvisioningTemplateVersionRequest {
    /// <p>The template name.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
    /// <p>The fleet provisioning template version ID.</p>
    #[serde(rename = "versionId")]
    pub version_id: i64,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeProvisioningTemplateVersionResponse {
    /// <p>The date when the fleet provisioning template version was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>True if the fleet provisioning template version is the default version.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The JSON formatted contents of the fleet provisioning template version.</p>
    #[serde(rename = "templateBody")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_body: Option<String>,
    /// <p>The fleet provisioning template version ID.</p>
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeRoleAliasRequest {
    /// <p>The role alias to describe.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeRoleAliasResponse {
    /// <p>The role alias description.</p>
    #[serde(rename = "roleAliasDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_description: Option<RoleAliasDescription>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeScheduledAuditRequest {
    /// <p>The name of the scheduled audit whose information you want to get.</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeScheduledAuditResponse {
    /// <p>The day of the month on which the scheduled audit takes place. Will be "1" through "31" or "LAST". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit takes place. One of "SUN", "MON", "TUE", "WED", "THU", "FRI", or "SAT".</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place. One of "DAILY", "WEEKLY", "BIWEEKLY", or "MONTHLY". The start time of each audit is determined by the system.</p>
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<String>,
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
    /// <p>The name of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_name: Option<String>,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    #[serde(rename = "targetCheckNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_check_names: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeSecurityProfileRequest {
    /// <p>The name of the security profile whose information you want to get.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeSecurityProfileResponse {
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here.</p>
    #[serde(rename = "additionalMetricsToRetain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_metrics_to_retain: Option<Vec<String>>,
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>The time the security profile was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The time the security profile was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "securityProfileArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_arn: Option<String>,
    /// <p>A description of the security profile (associated with the security profile when it was created or updated).</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name of the security profile.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The version of the security profile. A new version is generated whenever the security profile is updated.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeStreamRequest {
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeStreamResponse {
    /// <p>Information about the stream.</p>
    #[serde(rename = "streamInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_info: Option<StreamInfo>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingGroupRequest {
    /// <p>The name of the thing group.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeThingGroupResponse {
    /// <p>The dynamic thing group index name.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The dynamic thing group search query string.</p>
    #[serde(rename = "queryString")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_string: Option<String>,
    /// <p>The dynamic thing group query version.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
    /// <p>The dynamic thing group status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The thing group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The thing group ID.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>Thing group metadata.</p>
    #[serde(rename = "thingGroupMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_metadata: Option<ThingGroupMetadata>,
    /// <p>The name of the thing group.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
    /// <p>The thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_properties: Option<ThingGroupProperties>,
    /// <p>The version of the thing group.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingRegistrationTaskRequest {
    /// <p>The task ID.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeThingRegistrationTaskResponse {
    /// <p>The task creation date.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The number of things that failed to be provisioned.</p>
    #[serde(rename = "failureCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failure_count: Option<i64>,
    /// <p>The S3 bucket that contains the input file.</p>
    #[serde(rename = "inputFileBucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_file_bucket: Option<String>,
    /// <p>The input file key.</p>
    #[serde(rename = "inputFileKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_file_key: Option<String>,
    /// <p>The date when the task was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// <p>The progress of the bulk provisioning task expressed as a percentage.</p>
    #[serde(rename = "percentageProgress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percentage_progress: Option<i64>,
    /// <p>The role ARN that grants access to the input file bucket.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The status of the bulk thing provisioning task.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The number of things successfully provisioned.</p>
    #[serde(rename = "successCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success_count: Option<i64>,
    /// <p>The task ID.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
    /// <p>The task's template.</p>
    #[serde(rename = "templateBody")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_body: Option<String>,
}

/// <p>The input for the DescribeThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingRequest {
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the DescribeThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeThingResponse {
    /// <p>The thing attributes.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The name of the billing group the thing belongs to.</p>
    #[serde(rename = "billingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_name: Option<String>,
    /// <p>The default client ID.</p>
    #[serde(rename = "defaultClientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_client_id: Option<String>,
    /// <p>The ARN of the thing to describe.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The ID of the thing to describe.</p>
    #[serde(rename = "thingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_id: Option<String>,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The thing type name.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p><p>The current version of the thing record in the registry.</p> <note> <p>To avoid unintentional changes to the information in the registry, you can pass the version information in the <code>expectedVersion</code> parameter of the <code>UpdateThing</code> and <code>DeleteThing</code> calls.</p> </note></p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// <p>The input for the DescribeThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DescribeThingTypeRequest {
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    pub thing_type_name: String,
}

/// <p>The output for the DescribeThingType operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DescribeThingTypeResponse {
    /// <p>The thing type ARN.</p>
    #[serde(rename = "thingTypeArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_arn: Option<String>,
    /// <p>The thing type ID.</p>
    #[serde(rename = "thingTypeId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_id: Option<String>,
    /// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.</p>
    #[serde(rename = "thingTypeMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_metadata: Option<ThingTypeMetadata>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p>The ThingTypeProperties contains information about the thing type including description, and a list of searchable thing attribute names.</p>
    #[serde(rename = "thingTypeProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_properties: Option<ThingTypeProperties>,
}

/// <p>Describes the location of the updated firmware.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Destination {
    /// <p>Describes the location in S3 of the updated firmware.</p>
    #[serde(rename = "s3Destination")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_3_destination: Option<S3Destination>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachPolicyRequest {
    /// <p>The policy to detach.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The target from which the policy will be detached.</p>
    #[serde(rename = "target")]
    pub target: String,
}

/// <p>The input for the DetachPrincipalPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachPrincipalPolicyRequest {
    /// <p>The name of the policy to detach.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The principal.</p> <p>If the principal is a certificate, specify the certificate ARN. If the principal is an Amazon Cognito identity, specify the identity ID.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachSecurityProfileRequest {
    /// <p>The security profile that is detached.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
    /// <p>The ARN of the thing group from which the security profile is detached.</p>
    #[serde(rename = "securityProfileTargetArn")]
    pub security_profile_target_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DetachSecurityProfileResponse {}

/// <p>The input for the DetachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DetachThingPrincipalRequest {
    /// <p>If the principal is a certificate, this value must be ARN of the certificate. If the principal is an Amazon Cognito identity, this value must be the ID of the Amazon Cognito identity.</p>
    #[serde(rename = "principal")]
    pub principal: String,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the DetachThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DetachThingPrincipalResponse {}

/// <p>The input for the DisableTopicRuleRequest operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct DisableTopicRuleRequest {
    /// <p>The name of the rule to disable.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

/// <p><p>The summary of a domain configuration. A domain configuration specifies custom IoT-specific information about a domain. A domain configuration can be associated with an AWS-managed domain (for example, dbc123defghijk.iot.us-west-2.amazonaws.com), a customer managed domain, or a default endpoint.</p> <ul> <li> <p>Data</p> </li> <li> <p>Jobs</p> </li> <li> <p>CredentialProvider</p> </li> </ul> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct DomainConfigurationSummary {
    /// <p>The ARN of the domain configuration.</p>
    #[serde(rename = "domainConfigurationArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_arn: Option<String>,
    /// <p>The name of the domain configuration. This value must be unique to a region.</p>
    #[serde(rename = "domainConfigurationName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_name: Option<String>,
    /// <p>The type of service delivered by the endpoint.</p>
    #[serde(rename = "serviceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_type: Option<String>,
}

/// <p>Describes an action to write to a DynamoDB table.</p> <p>The <code>tableName</code>, <code>hashKeyField</code>, and <code>rangeKeyField</code> values must match the values used when you created the table.</p> <p>The <code>hashKeyValue</code> and <code>rangeKeyvalue</code> fields use a substitution template syntax. These templates provide data at runtime. The syntax is as follows: ${<i>sql-expression</i>}.</p> <p>You can specify any valid expression in a WHERE or SELECT clause, including JSON properties, comparisons, calculations, and functions. For example, the following field uses the third level of the topic:</p> <p> <code>"hashKeyValue": "${topic(3)}"</code> </p> <p>The following field uses the timestamp:</p> <p> <code>"rangeKeyValue": "${timestamp()}"</code> </p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DynamoDBAction {
    /// <p>The hash key name.</p>
    #[serde(rename = "hashKeyField")]
    pub hash_key_field: String,
    /// <p>The hash key type. Valid values are "STRING" or "NUMBER"</p>
    #[serde(rename = "hashKeyType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hash_key_type: Option<String>,
    /// <p>The hash key value.</p>
    #[serde(rename = "hashKeyValue")]
    pub hash_key_value: String,
    /// <p>The type of operation to be performed. This follows the substitution template, so it can be <code>${operation}</code>, but the substitution must result in one of the following: <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>.</p>
    #[serde(rename = "operation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub operation: Option<String>,
    /// <p>The action payload. This name can be customized.</p>
    #[serde(rename = "payloadField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub payload_field: Option<String>,
    /// <p>The range key name.</p>
    #[serde(rename = "rangeKeyField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range_key_field: Option<String>,
    /// <p>The range key type. Valid values are "STRING" or "NUMBER"</p>
    #[serde(rename = "rangeKeyType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range_key_type: Option<String>,
    /// <p>The range key value.</p>
    #[serde(rename = "rangeKeyValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub range_key_value: Option<String>,
    /// <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the DynamoDB table.</p>
    #[serde(rename = "tableName")]
    pub table_name: String,
}

/// <p>Describes an action to write to a DynamoDB table.</p> <p>This DynamoDB action writes each attribute in the message payload into it's own column in the DynamoDB table.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DynamoDBv2Action {
    /// <p>Specifies the DynamoDB table to which the message data will be written. For example:</p> <p> <code>{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }</code> </p> <p>Each attribute in the message payload will be written to a separate column in the DynamoDB database.</p>
    #[serde(rename = "putItem")]
    pub put_item: PutItemInput,
    /// <p>The ARN of the IAM role that grants access to the DynamoDB table.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>The policy that has the effect on the authorization results.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct EffectivePolicy {
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The IAM policy document.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}

/// <p>Describes an action that writes data to an Amazon Elasticsearch Service domain.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ElasticsearchAction {
    /// <p>The endpoint of your Elasticsearch domain.</p>
    #[serde(rename = "endpoint")]
    pub endpoint: String,
    /// <p>The unique identifier for the document you are storing.</p>
    #[serde(rename = "id")]
    pub id: String,
    /// <p>The Elasticsearch index where you want to store your data.</p>
    #[serde(rename = "index")]
    pub index: String,
    /// <p>The IAM role ARN that has access to Elasticsearch.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The type of document you are storing.</p>
    #[serde(rename = "type")]
    pub type_: String,
}

/// <p>Parameters used when defining a mitigation action that enable AWS IoT logging.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnableIoTLoggingParams {
    /// <p>Specifies the types of information to be logged.</p>
    #[serde(rename = "logLevel")]
    pub log_level: String,
    /// <p>The ARN of the IAM role used for logging.</p>
    #[serde(rename = "roleArnForLogging")]
    pub role_arn_for_logging: String,
}

/// <p>The input for the EnableTopicRuleRequest operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct EnableTopicRuleRequest {
    /// <p>The name of the topic rule to enable.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

/// <p>Error information.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ErrorInfo {
    /// <p>The error code.</p>
    #[serde(rename = "code")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    /// <p>The error message.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// <p>Information that explicitly denies authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ExplicitDeny {
    /// <p>The policies that denied the authorization.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>Allows you to create an exponential rate of rollout for a job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ExponentialRolloutRate {
    /// <p>The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.</p>
    #[serde(rename = "baseRatePerMinute")]
    pub base_rate_per_minute: i64,
    /// <p>The exponential factor to increase the rate of rollout for a job.</p>
    #[serde(rename = "incrementFactor")]
    pub increment_factor: f64,
    /// <p>The criteria to initiate the increase in rate of rollout for a job.</p> <p>AWS IoT supports up to one digit after the decimal (for example, 1.5, but not 1.55).</p>
    #[serde(rename = "rateIncreaseCriteria")]
    pub rate_increase_criteria: RateIncreaseCriteria,
}

/// <p>Describes the name and data type at a field.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Field {
    /// <p>The name of the field.</p>
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// <p>The datatype of the field.</p>
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub type_: Option<String>,
}

/// <p>The location of the OTA update.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FileLocation {
    /// <p>The location of the updated firmware in S3.</p>
    #[serde(rename = "s3Location")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_3_location: Option<S3Location>,
    /// <p>The stream that contains the OTA update.</p>
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream: Option<Stream>,
}

/// <p>Describes an action that writes data to an Amazon Kinesis Firehose stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FirehoseAction {
    /// <p>The delivery stream name.</p>
    #[serde(rename = "deliveryStreamName")]
    pub delivery_stream_name: String,
    /// <p>The IAM role that grants access to the Amazon Kinesis Firehose stream.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).</p>
    #[serde(rename = "separator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub separator: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetCardinalityRequest {
    /// <p>The field to aggregate.</p>
    #[serde(rename = "aggregationField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aggregation_field: Option<String>,
    /// <p>The name of the index to search.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The search query.</p>
    #[serde(rename = "queryString")]
    pub query_string: String,
    /// <p>The query version.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetCardinalityResponse {
    /// <p>The approximate count of unique values that match the query.</p>
    #[serde(rename = "cardinality")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cardinality: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetEffectivePoliciesRequest {
    /// <p>The Cognito identity pool ID.</p>
    #[serde(rename = "cognitoIdentityPoolId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cognito_identity_pool_id: Option<String>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principal: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetEffectivePoliciesResponse {
    /// <p>The effective policies.</p>
    #[serde(rename = "effectivePolicies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub effective_policies: Option<Vec<EffectivePolicy>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetIndexingConfigurationRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetIndexingConfigurationResponse {
    /// <p>The index configuration.</p>
    #[serde(rename = "thingGroupIndexingConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_indexing_configuration: Option<ThingGroupIndexingConfiguration>,
    /// <p>Thing indexing configuration.</p>
    #[serde(rename = "thingIndexingConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_indexing_configuration: Option<ThingIndexingConfiguration>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetJobDocumentRequest {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetJobDocumentResponse {
    /// <p>The job document content.</p>
    #[serde(rename = "document")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub document: Option<String>,
}

/// <p>The input for the GetLoggingOptions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetLoggingOptionsRequest {}

/// <p>The output from the GetLoggingOptions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetLoggingOptionsResponse {
    /// <p>The logging level.</p>
    #[serde(rename = "logLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_level: Option<String>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetOTAUpdateRequest {
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    pub ota_update_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetOTAUpdateResponse {
    /// <p>The OTA update info.</p>
    #[serde(rename = "otaUpdateInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_info: Option<OTAUpdateInfo>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetPercentilesRequest {
    /// <p>The field to aggregate.</p>
    #[serde(rename = "aggregationField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aggregation_field: Option<String>,
    /// <p>The name of the index to search.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The percentile groups returned.</p>
    #[serde(rename = "percents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percents: Option<Vec<f64>>,
    /// <p>The query string.</p>
    #[serde(rename = "queryString")]
    pub query_string: String,
    /// <p>The query version.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetPercentilesResponse {
    /// <p>The percentile values of the aggregated fields.</p>
    #[serde(rename = "percentiles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percentiles: Option<Vec<PercentPair>>,
}

/// <p>The input for the GetPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetPolicyRequest {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the GetPolicy operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetPolicyResponse {
    /// <p>The date the policy was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The default policy version ID.</p>
    #[serde(rename = "defaultVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_version_id: Option<String>,
    /// <p>The generation ID of the policy.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>The date the policy was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}

/// <p>The input for the GetPolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetPolicyVersionRequest {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    pub policy_version_id: String,
}

/// <p>The output from the GetPolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetPolicyVersionResponse {
    /// <p>The date the policy was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The generation ID of the policy version.</p>
    #[serde(rename = "generationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_id: Option<String>,
    /// <p>Specifies whether the policy version is the default.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The date the policy was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The JSON document that describes the policy.</p>
    #[serde(rename = "policyDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_document: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

/// <p>The input to the GetRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetRegistrationCodeRequest {}

/// <p>The output from the GetRegistrationCode operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetRegistrationCodeResponse {
    /// <p>The CA certificate registration code.</p>
    #[serde(rename = "registrationCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_code: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetStatisticsRequest {
    /// <p>The aggregation field name.</p>
    #[serde(rename = "aggregationField")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aggregation_field: Option<String>,
    /// <p>The name of the index to search. The default value is <code>AWS_Things</code>.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The query used to search. You can specify "*" for the query string to get the count of all indexed things in your AWS account.</p>
    #[serde(rename = "queryString")]
    pub query_string: String,
    /// <p>The version of the query used to search.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetStatisticsResponse {
    /// <p>The statistics returned by the Fleet Indexing service based on the query and aggregation field.</p>
    #[serde(rename = "statistics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statistics: Option<Statistics>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetTopicRuleDestinationRequest {
    /// <p>The ARN of the topic rule destination.</p>
    #[serde(rename = "arn")]
    pub arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetTopicRuleDestinationResponse {
    /// <p>The topic rule destination.</p>
    #[serde(rename = "topicRuleDestination")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_rule_destination: Option<TopicRuleDestination>,
}

/// <p>The input for the GetTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
}

/// <p>The output from the GetTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetTopicRuleResponse {
    /// <p>The rule.</p>
    #[serde(rename = "rule")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule: Option<TopicRule>,
    /// <p>The rule ARN.</p>
    #[serde(rename = "ruleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct GetV2LoggingOptionsRequest {}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GetV2LoggingOptionsResponse {
    /// <p>The default log level.</p>
    #[serde(rename = "defaultLogLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_log_level: Option<String>,
    /// <p>Disables all logs.</p>
    #[serde(rename = "disableAllLogs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_all_logs: Option<bool>,
    /// <p>The IAM role ARN AWS IoT uses to write to your CloudWatch logs.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>The name and ARN of a group.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct GroupNameAndArn {
    /// <p>The group ARN.</p>
    #[serde(rename = "groupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_arn: Option<String>,
    /// <p>The group name.</p>
    #[serde(rename = "groupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub group_name: Option<String>,
}

/// <p>Send data to an HTTPS endpoint.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct HttpAction {
    /// <p>The authentication method to use when sending data to an HTTPS endpoint.</p>
    #[serde(rename = "auth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth: Option<HttpAuthorization>,
    /// <p>The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substituion template before traffic is allowed to your endpoint URL.</p>
    #[serde(rename = "confirmationUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confirmation_url: Option<String>,
    /// <p>The HTTP headers to send with the message data.</p>
    #[serde(rename = "headers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<Vec<HttpActionHeader>>,
    /// <p>The endpoint URL. If substitution templates are used in the URL, you must also specify a <code>confirmationUrl</code>. If this is a new destination, a new <code>TopicRuleDestination</code> is created if possible.</p>
    #[serde(rename = "url")]
    pub url: String,
}

/// <p>The HTTP action header.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct HttpActionHeader {
    /// <p>The HTTP header key.</p>
    #[serde(rename = "key")]
    pub key: String,
    /// <p>The HTTP header value. Substitution templates are supported.</p>
    #[serde(rename = "value")]
    pub value: String,
}

/// <p>The authorization method used to send messages.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct HttpAuthorization {
    /// <p>Use Sig V4 authorization. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">Signature Version 4 Signing Process</a>.</p>
    #[serde(rename = "sigv4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sigv_4: Option<SigV4Authorization>,
}

/// <p>Specifies the HTTP context to use for the test authorizer request.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct HttpContext {
    /// <p>The header keys and values in an HTTP authorization request.</p>
    #[serde(rename = "headers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers: Option<::std::collections::HashMap<String, String>>,
    /// <p>The query string keys and values in an HTTP authorization request.</p>
    #[serde(rename = "queryString")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_string: Option<String>,
}

/// <p>HTTP URL destination configuration used by the topic rule's HTTP action.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct HttpUrlDestinationConfiguration {
    /// <p>The URL AWS IoT uses to confirm ownership of or access to the topic rule destination URL.</p>
    #[serde(rename = "confirmationUrl")]
    pub confirmation_url: String,
}

/// <p>HTTP URL destination properties.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct HttpUrlDestinationProperties {
    /// <p>The URL used to confirm the HTTP topic rule destination URL.</p>
    #[serde(rename = "confirmationUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confirmation_url: Option<String>,
}

/// <p>Information about an HTTP URL destination.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct HttpUrlDestinationSummary {
    /// <p>The URL used to confirm ownership of or access to the HTTP topic rule destination URL.</p>
    #[serde(rename = "confirmationUrl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub confirmation_url: Option<String>,
}

/// <p>Information that implicitly denies authorization. When policy doesn't explicitly deny or allow an action on a resource it is considered an implicit deny.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ImplicitDeny {
    /// <p>Policies that don't contain a matching allow or deny statement for the specified action on the specified resource. </p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>Sends message data to an AWS IoT Analytics channel.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IotAnalyticsAction {
    /// <p>(deprecated) The ARN of the IoT Analytics channel to which message data will be sent.</p>
    #[serde(rename = "channelArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_arn: Option<String>,
    /// <p>The name of the IoT Analytics channel to which message data will be sent.</p>
    #[serde(rename = "channelName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub channel_name: Option<String>,
    /// <p>The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>Sends an input to an AWS IoT Events detector.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IotEventsAction {
    /// <p>The name of the AWS IoT Events input.</p>
    #[serde(rename = "inputName")]
    pub input_name: String,
    /// <p>[Optional] Use this to ensure that only one input (message) with a given messageId will be processed by an AWS IoT Events detector.</p>
    #[serde(rename = "messageId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,
    /// <p>The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>Describes an action to send data from an MQTT message that triggered the rule to AWS IoT SiteWise asset properties.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IotSiteWiseAction {
    /// <p>A list of asset property value entries.</p>
    #[serde(rename = "putAssetPropertyValueEntries")]
    pub put_asset_property_value_entries: Vec<PutAssetPropertyValueEntry>,
    /// <p>The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoTSiteWise. (<code>"Action": "iotsitewise:BatchPutAssetPropertyValue"</code>). The trust policy can restrict access to specific asset hierarchy paths.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>The <code>Job</code> object contains details about a job.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct Job {
    /// <p>Configuration for criteria to abort the job.</p>
    #[serde(rename = "abortConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub abort_config: Option<AbortConfig>,
    /// <p>If the job was updated, describes the reason for the update.</p>
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
    /// <p>The time, in seconds since the epoch, when the job was completed.</p>
    #[serde(rename = "completedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<f64>,
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>Will be <code>true</code> if the job was canceled with the optional <code>force</code> parameter set to <code>true</code>.</p>
    #[serde(rename = "forceCanceled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_canceled: Option<bool>,
    /// <p>An ARN identifying the job with format "arn:aws:iot:region:account:job/jobId".</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>Allows you to create a staged rollout of a job.</p>
    #[serde(rename = "jobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_executions_rollout_config: Option<JobExecutionsRolloutConfig>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
    /// <p>Details about the job process.</p>
    #[serde(rename = "jobProcessDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_process_details: Option<JobProcessDetails>,
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>Configuration for pre-signed S3 URLs.</p>
    #[serde(rename = "presignedUrlConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presigned_url_config: Option<PresignedUrlConfig>,
    /// <p>If the job was updated, provides the reason code for the update.</p>
    #[serde(rename = "reasonCode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason_code: Option<String>,
    /// <p>The status of the job, one of <code>IN_PROGRESS</code>, <code>CANCELED</code>, <code>DELETION_IN_PROGRESS</code> or <code>COMPLETED</code>. </p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a device when the thing representing the device is added to a target group, even after the job was completed by all things originally in the group. </p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>A list of IoT things and thing groups to which the job should be sent.</p>
    #[serde(rename = "targets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
    #[serde(rename = "timeoutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout_config: Option<TimeoutConfig>,
}

/// <p>The job execution object represents the execution of a job on a particular device.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobExecution {
    /// <p>The estimated number of seconds that remain before the job execution status will be changed to <code>TIMED_OUT</code>. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The actual job execution timeout can occur up to 60 seconds later than the estimated duration. This value will not be included if the job execution has reached a terminal status.</p>
    #[serde(rename = "approximateSecondsBeforeTimedOut")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub approximate_seconds_before_timed_out: Option<i64>,
    /// <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used in commands which return or update job execution information. </p>
    #[serde(rename = "executionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_number: Option<i64>,
    /// <p>Will be <code>true</code> if the job execution was canceled with the optional <code>force</code> parameter set to <code>true</code>.</p>
    #[serde(rename = "forceCanceled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub force_canceled: Option<bool>,
    /// <p>The unique identifier you assigned to the job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
    /// <p>The time, in seconds since the epoch, when the job execution was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>The time, in seconds since the epoch, when the job execution was queued.</p>
    #[serde(rename = "queuedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub queued_at: Option<f64>,
    /// <p>The time, in seconds since the epoch, when the job execution started.</p>
    #[serde(rename = "startedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<f64>,
    /// <p>The status of the job execution (IN_PROGRESS, QUEUED, FAILED, SUCCEEDED, TIMED_OUT, CANCELED, or REJECTED).</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>A collection of name/value pairs that describe the status of the job execution.</p>
    #[serde(rename = "statusDetails")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_details: Option<JobExecutionStatusDetails>,
    /// <p>The ARN of the thing on which the job execution is running.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The version of the job execution. Job execution versions are incremented each time they are updated by a device.</p>
    #[serde(rename = "versionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_number: Option<i64>,
}

/// <p>Details of the job execution status.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobExecutionStatusDetails {
    /// <p>The job execution status.</p>
    #[serde(rename = "detailsMap")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details_map: Option<::std::collections::HashMap<String, String>>,
}

/// <p>The job execution summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobExecutionSummary {
    /// <p>A string (consisting of the digits "0" through "9") which identifies this particular job execution on this particular device. It can be used later in commands which return or update job execution information.</p>
    #[serde(rename = "executionNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_number: Option<i64>,
    /// <p>The time, in seconds since the epoch, when the job execution was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>The time, in seconds since the epoch, when the job execution was queued.</p>
    #[serde(rename = "queuedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub queued_at: Option<f64>,
    /// <p>The time, in seconds since the epoch, when the job execution started.</p>
    #[serde(rename = "startedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub started_at: Option<f64>,
    /// <p>The status of the job execution.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>Contains a summary of information about job executions for a specific job.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobExecutionSummaryForJob {
    /// <p>Contains a subset of information about a job execution.</p>
    #[serde(rename = "jobExecutionSummary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_execution_summary: Option<JobExecutionSummary>,
    /// <p>The ARN of the thing on which the job execution is running.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
}

/// <p>The job execution summary for a thing.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobExecutionSummaryForThing {
    /// <p>Contains a subset of information about a job execution.</p>
    #[serde(rename = "jobExecutionSummary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_execution_summary: Option<JobExecutionSummary>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
}

/// <p>Allows you to create a staged rollout of a job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct JobExecutionsRolloutConfig {
    /// <p>The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.</p>
    #[serde(rename = "exponentialRate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exponential_rate: Option<ExponentialRolloutRate>,
    /// <p>The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.</p>
    #[serde(rename = "maximumPerMinute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum_per_minute: Option<i64>,
}

/// <p>The job process details.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobProcessDetails {
    /// <p>The number of things that cancelled the job.</p>
    #[serde(rename = "numberOfCanceledThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_canceled_things: Option<i64>,
    /// <p>The number of things that failed executing the job.</p>
    #[serde(rename = "numberOfFailedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_failed_things: Option<i64>,
    /// <p>The number of things currently executing the job.</p>
    #[serde(rename = "numberOfInProgressThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_in_progress_things: Option<i64>,
    /// <p>The number of things that are awaiting execution of the job.</p>
    #[serde(rename = "numberOfQueuedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_queued_things: Option<i64>,
    /// <p>The number of things that rejected the job.</p>
    #[serde(rename = "numberOfRejectedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_rejected_things: Option<i64>,
    /// <p>The number of things that are no longer scheduled to execute the job because they have been deleted or have been removed from the group that was a target of the job.</p>
    #[serde(rename = "numberOfRemovedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_removed_things: Option<i64>,
    /// <p>The number of things which successfully completed the job.</p>
    #[serde(rename = "numberOfSucceededThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_succeeded_things: Option<i64>,
    /// <p>The number of things whose job execution status is <code>TIMED_OUT</code>.</p>
    #[serde(rename = "numberOfTimedOutThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_timed_out_things: Option<i64>,
    /// <p>The target devices to which the job execution is being rolled out. This value will be null after the job execution has finished rolling out to all the target devices.</p>
    #[serde(rename = "processingTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub processing_targets: Option<Vec<String>>,
}

/// <p>The job summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct JobSummary {
    /// <p>The time, in seconds since the epoch, when the job completed.</p>
    #[serde(rename = "completedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub completed_at: Option<f64>,
    /// <p>The time, in seconds since the epoch, when the job was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The job ARN.</p>
    #[serde(rename = "jobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_arn: Option<String>,
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_id: Option<String>,
    /// <p>The time, in seconds since the epoch, when the job was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>The job summary status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group.</p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>The ID of the thing group.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
}

/// <p>Describes a key pair.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct KeyPair {
    /// <p>The private key.</p>
    #[serde(rename = "PrivateKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub private_key: Option<String>,
    /// <p>The public key.</p>
    #[serde(rename = "PublicKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public_key: Option<String>,
}

/// <p>Describes an action to write data to an Amazon Kinesis stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct KinesisAction {
    /// <p>The partition key.</p>
    #[serde(rename = "partitionKey")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partition_key: Option<String>,
    /// <p>The ARN of the IAM role that grants access to the Amazon Kinesis stream.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the Amazon Kinesis stream.</p>
    #[serde(rename = "streamName")]
    pub stream_name: String,
}

/// <p>Describes an action to invoke a Lambda function.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LambdaAction {
    /// <p>The ARN of the Lambda function.</p>
    #[serde(rename = "functionArn")]
    pub function_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListActiveViolationsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the Device Defender security profile for which violations are listed.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The name of the thing whose active violations are listed.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListActiveViolationsResponse {
    /// <p>The list of active violations.</p>
    #[serde(rename = "activeViolations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub active_violations: Option<Vec<ActiveViolation>>,
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAttachedPoliciesRequest {
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to be returned per request.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>When true, recursively list attached policies.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
    /// <p>The group or principal for which the policies will be listed.</p>
    #[serde(rename = "target")]
    pub target: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListAttachedPoliciesResponse {
    /// <p>The token to retrieve the next set of results, or ``null`` if there are no more results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The policies.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuditFindingsRequest {
    /// <p>A filter to limit results to the findings for the specified audit check.</p>
    #[serde(rename = "checkName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub check_name: Option<String>,
    /// <p>A filter to limit results to those found before the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    #[serde(rename = "endTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end_time: Option<f64>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>Information identifying the noncompliant resource.</p>
    #[serde(rename = "resourceIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_identifier: Option<ResourceIdentifier>,
    /// <p>A filter to limit results to those found after the specified time. You must specify either the startTime and endTime or the taskId, but not both.</p>
    #[serde(rename = "startTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_time: Option<f64>,
    /// <p>A filter to limit results to the audit with the specified ID. You must specify either the taskId or the startTime and endTime, but not both.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListAuditFindingsResponse {
    /// <p>The findings (results) of the audit.</p>
    #[serde(rename = "findings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub findings: Option<Vec<AuditFinding>>,
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuditMitigationActionsExecutionsRequest {
    /// <p>Specify this filter to limit results to those with a specific status.</p>
    #[serde(rename = "actionStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_status: Option<String>,
    /// <p>Specify this filter to limit results to those that were applied to a specific audit finding.</p>
    #[serde(rename = "findingId")]
    pub finding_id: String,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>Specify this filter to limit results to actions for a specific audit mitigation actions task.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListAuditMitigationActionsExecutionsResponse {
    /// <p>A set of task execution results based on the input parameters. Details include the mitigation action applied, start time, and task status.</p>
    #[serde(rename = "actionsExecutions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions_executions: Option<Vec<AuditMitigationActionExecutionMetadata>>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuditMitigationActionsTasksRequest {
    /// <p>Specify this filter to limit results to tasks that were applied to results for a specific audit.</p>
    #[serde(rename = "auditTaskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_task_id: Option<String>,
    /// <p>Specify this filter to limit results to tasks that were completed or canceled on or before a specific date and time.</p>
    #[serde(rename = "endTime")]
    pub end_time: f64,
    /// <p>Specify this filter to limit results to tasks that were applied to a specific audit finding.</p>
    #[serde(rename = "findingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub finding_id: Option<String>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>Specify this filter to limit results to tasks that began on or after a specific date and time.</p>
    #[serde(rename = "startTime")]
    pub start_time: f64,
    /// <p>Specify this filter to limit results to tasks that are in a specific state.</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListAuditMitigationActionsTasksResponse {
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The collection of audit mitigation tasks that matched the filter criteria.</p>
    #[serde(rename = "tasks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tasks: Option<Vec<AuditMitigationActionsTaskMetadata>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuditTasksRequest {
    /// <p>The end of the time period.</p>
    #[serde(rename = "endTime")]
    pub end_time: f64,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The beginning of the time period. Audit information is retained for a limited time (180 days). Requesting a start time prior to what is retained results in an "InvalidRequestException".</p>
    #[serde(rename = "startTime")]
    pub start_time: f64,
    /// <p>A filter to limit the output to audits with the specified completion status: can be one of "IN_PROGRESS", "COMPLETED", "FAILED", or "CANCELED".</p>
    #[serde(rename = "taskStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_status: Option<String>,
    /// <p>A filter to limit the output to the specified type of audit: can be one of "ON_DEMAND_AUDIT_TASK" or "SCHEDULED__AUDIT_TASK".</p>
    #[serde(rename = "taskType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListAuditTasksResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The audits that were performed during the specified time period.</p>
    #[serde(rename = "tasks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tasks: Option<Vec<AuditTaskMetadata>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListAuthorizersRequest {
    /// <p>Return the list of authorizers in ascending alphabetical order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The status of the list authorizers request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListAuthorizersResponse {
    /// <p>The authorizers.</p>
    #[serde(rename = "authorizers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizers: Option<Vec<AuthorizerSummary>>,
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListBillingGroupsRequest {
    /// <p>The maximum number of results to return per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>Limit the results to billing groups whose names have the given prefix.</p>
    #[serde(rename = "namePrefixFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name_prefix_filter: Option<String>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListBillingGroupsResponse {
    /// <p>The list of billing groups.</p>
    #[serde(rename = "billingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_groups: Option<Vec<GroupNameAndArn>>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

/// <p>Input for the ListCACertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListCACertificatesRequest {
    /// <p>Determines the order of the results.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output from the ListCACertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListCACertificatesResponse {
    /// <p>The CA certificates registered in your AWS account.</p>
    #[serde(rename = "certificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<CACertificate>>,
    /// <p>The current position within the list of CA certificates.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

/// <p>The input to the ListCertificatesByCA operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListCertificatesByCARequest {
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The ID of the CA certificate. This operation will list all registered device certificate that were signed by this CA certificate.</p>
    #[serde(rename = "caCertificateId")]
    pub ca_certificate_id: String,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output of the ListCertificatesByCA operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListCertificatesByCAResponse {
    /// <p>The device certificates signed by the specified CA certificate.</p>
    #[serde(rename = "certificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<Certificate>>,
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

/// <p>The input for the ListCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListCertificatesRequest {
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output of the ListCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListCertificatesResponse {
    /// <p>The descriptions of the certificates.</p>
    #[serde(rename = "certificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificates: Option<Vec<Certificate>>,
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListDomainConfigurationsRequest {
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The type of service delivered by the endpoint.</p>
    #[serde(rename = "serviceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListDomainConfigurationsResponse {
    /// <p>A list of objects that contain summary information about the user's domain configurations.</p>
    #[serde(rename = "domainConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configurations: Option<Vec<DomainConfigurationSummary>>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListIndicesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListIndicesResponse {
    /// <p>The index names.</p>
    #[serde(rename = "indexNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_names: Option<Vec<String>>,
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListJobExecutionsForJobRequest {
    /// <p>The unique identifier you assigned to this job when it was created.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>The maximum number of results to be returned per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The status of the job.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListJobExecutionsForJobResponse {
    /// <p>A list of job execution summaries.</p>
    #[serde(rename = "executionSummaries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_summaries: Option<Vec<JobExecutionSummaryForJob>>,
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListJobExecutionsForThingRequest {
    /// <p>The maximum number of results to be returned per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListJobExecutionsForThingResponse {
    /// <p>A list of job execution summaries.</p>
    #[serde(rename = "executionSummaries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_summaries: Option<Vec<JobExecutionSummaryForThing>>,
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListJobsRequest {
    /// <p>The maximum number of results to return per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>An optional filter that lets you search for jobs that have the specified status.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Specifies whether the job will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the job (SNAPSHOT). If continuous, the job may also be run on a thing when a change is detected in a target. For example, a job will run on a thing when the thing is added to a target group, even after the job was completed by all things originally in the group. </p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>A filter that limits the returned jobs to those for the specified group.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListJobsResponse {
    /// <p>A list of jobs.</p>
    #[serde(rename = "jobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub jobs: Option<Vec<JobSummary>>,
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListMitigationActionsRequest {
    /// <p>Specify a value to limit the result to mitigation actions with a specific action type.</p>
    #[serde(rename = "actionType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_type: Option<String>,
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListMitigationActionsResponse {
    /// <p>A set of actions that matched the specified filter criteria.</p>
    #[serde(rename = "actionIdentifiers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_identifiers: Option<Vec<MitigationActionIdentifier>>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListOTAUpdatesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token used to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The OTA update job status.</p>
    #[serde(rename = "otaUpdateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListOTAUpdatesResponse {
    /// <p>A token to use to get the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of OTA update jobs.</p>
    #[serde(rename = "otaUpdates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_updates: Option<Vec<OTAUpdateSummary>>,
}

/// <p>The input to the ListOutgoingCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListOutgoingCertificatesRequest {
    /// <p>Specifies the order for results. If True, the results are returned in ascending order, based on the creation date.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output from the ListOutgoingCertificates operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListOutgoingCertificatesResponse {
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The certificates that are being transferred but not yet accepted.</p>
    #[serde(rename = "outgoingCertificates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outgoing_certificates: Option<Vec<OutgoingCertificate>>,
}

/// <p>The input for the ListPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPoliciesRequest {
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

/// <p>The output from the ListPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListPoliciesResponse {
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The descriptions of the policies.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>The input for the ListPolicyPrincipals operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPolicyPrincipalsRequest {
    /// <p>Specifies the order for results. If true, the results are returned in ascending creation order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the ListPolicyPrincipals operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListPolicyPrincipalsResponse {
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The descriptions of the principals.</p>
    #[serde(rename = "principals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principals: Option<Vec<String>>,
}

/// <p>The input for the ListPolicyVersions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPolicyVersionsRequest {
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

/// <p>The output from the ListPolicyVersions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListPolicyVersionsResponse {
    /// <p>The policy versions.</p>
    #[serde(rename = "policyVersions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_versions: Option<Vec<PolicyVersion>>,
}

/// <p>The input for the ListPrincipalPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPrincipalPoliciesRequest {
    /// <p>Specifies the order for results. If true, results are returned in ascending creation order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The marker for the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The result page size.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

/// <p>The output from the ListPrincipalPolicies operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListPrincipalPoliciesResponse {
    /// <p>The marker for the next set of results, or null if there are no additional results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The policies.</p>
    #[serde(rename = "policies")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policies: Option<Vec<Policy>>,
}

/// <p>The input for the ListPrincipalThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListPrincipalThingsRequest {
    /// <p>The maximum number of results to return in this operation.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    pub principal: String,
}

/// <p>The output from the ListPrincipalThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListPrincipalThingsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListProvisioningTemplateVersionsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListProvisioningTemplateVersionsResponse {
    /// <p>A token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The list of fleet provisioning template versions.</p>
    #[serde(rename = "versions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub versions: Option<Vec<ProvisioningTemplateVersionSummary>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListProvisioningTemplatesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListProvisioningTemplatesResponse {
    /// <p>A token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of fleet provisioning templates</p>
    #[serde(rename = "templates")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub templates: Option<Vec<ProvisioningTemplateSummary>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListRoleAliasesRequest {
    /// <p>Return the list of role aliases in ascending alphabetical order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListRoleAliasesResponse {
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The role aliases.</p>
    #[serde(rename = "roleAliases")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_aliases: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListScheduledAuditsRequest {
    /// <p>The maximum number of results to return at one time. The default is 25.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListScheduledAuditsResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The list of scheduled audits.</p>
    #[serde(rename = "scheduledAudits")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audits: Option<Vec<ScheduledAuditMetadata>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListSecurityProfilesForTargetRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>If true, return child groups too.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
    /// <p>The ARN of the target (thing group) whose attached security profiles you want to get.</p>
    #[serde(rename = "securityProfileTargetArn")]
    pub security_profile_target_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListSecurityProfilesForTargetResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of security profiles and their associated targets.</p>
    #[serde(rename = "securityProfileTargetMappings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_target_mappings: Option<Vec<SecurityProfileTargetMapping>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListSecurityProfilesRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListSecurityProfilesResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of security profile identifiers (names and ARNs).</p>
    #[serde(rename = "securityProfileIdentifiers")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_identifiers: Option<Vec<SecurityProfileIdentifier>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListStreamsRequest {
    /// <p>Set to true to return the list of streams in ascending order.</p>
    #[serde(rename = "ascendingOrder")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ascending_order: Option<bool>,
    /// <p>The maximum number of results to return at a time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token used to get the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListStreamsResponse {
    /// <p>A token used to get the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of streams.</p>
    #[serde(rename = "streams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub streams: Option<Vec<StreamSummary>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTagsForResourceRequest {
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The ARN of the resource.</p>
    #[serde(rename = "resourceArn")]
    pub resource_arn: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListTagsForResourceResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The list of tags assigned to the resource.</p>
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Vec<Tag>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTargetsForPolicyRequest {
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "marker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_size: Option<i64>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListTargetsForPolicyResponse {
    /// <p>A marker used to get the next set of results.</p>
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,
    /// <p>The policy targets.</p>
    #[serde(rename = "targets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTargetsForSecurityProfileRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The security profile.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListTargetsForSecurityProfileResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups to which the security profile is attached.</p>
    #[serde(rename = "securityProfileTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_targets: Option<Vec<SecurityProfileTarget>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingGroupsForThingRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingGroupsForThingResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups.</p>
    #[serde(rename = "thingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups: Option<Vec<GroupNameAndArn>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingGroupsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A filter that limits the results to those with the specified name prefix.</p>
    #[serde(rename = "namePrefixFilter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name_prefix_filter: Option<String>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A filter that limits the results to those with the specified parent group.</p>
    #[serde(rename = "parentGroup")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group: Option<String>,
    /// <p>If true, return child groups as well.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingGroupsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups.</p>
    #[serde(rename = "thingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups: Option<Vec<GroupNameAndArn>>,
}

/// <p>The input for the ListThingPrincipal operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingPrincipalsRequest {
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
}

/// <p>The output from the ListThingPrincipals operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingPrincipalsResponse {
    /// <p>The principals associated with the thing.</p>
    #[serde(rename = "principals")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principals: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingRegistrationTaskReportsRequest {
    /// <p>The maximum number of results to return per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The type of task report.</p>
    #[serde(rename = "reportType")]
    pub report_type: String,
    /// <p>The id of the task.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingRegistrationTaskReportsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The type of task report.</p>
    #[serde(rename = "reportType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub report_type: Option<String>,
    /// <p>Links to the task resources.</p>
    #[serde(rename = "resourceLinks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_links: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingRegistrationTasksRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The status of the bulk thing provisioning task.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingRegistrationTasksResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of bulk thing provisioning task IDs.</p>
    #[serde(rename = "taskIds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_ids: Option<Vec<String>>,
}

/// <p>The input for the ListThingTypes operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingTypesRequest {
    /// <p>The maximum number of results to return in this operation.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output for the ListThingTypes operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingTypesResponse {
    /// <p>The token for the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing types.</p>
    #[serde(rename = "thingTypes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_types: Option<Vec<ThingTypeDefinition>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingsInBillingGroupRequest {
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    pub billing_group_name: String,
    /// <p>The maximum number of results to return per request.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingsInBillingGroupResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A list of things in the billing group.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingsInThingGroupRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>When true, list things in this thing group and in all child groups as well.</p>
    #[serde(rename = "recursive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recursive: Option<bool>,
    /// <p>The thing group name.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingsInThingGroupResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things in the specified thing group.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<String>>,
}

/// <p>The input for the ListThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListThingsRequest {
    /// <p>The attribute name used to search for things.</p>
    #[serde(rename = "attributeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_name: Option<String>,
    /// <p>The attribute value used to search for things.</p>
    #[serde(rename = "attributeValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_value: Option<String>,
    /// <p>The maximum number of results to return in this operation.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The name of the thing type used to search for things.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output from the ListThings operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListThingsResponse {
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The things.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<ThingAttribute>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTopicRuleDestinationsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListTopicRuleDestinationsResponse {
    /// <p>Information about a topic rule destination.</p>
    #[serde(rename = "destinationSummaries")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination_summaries: Option<Vec<TopicRuleDestinationSummary>>,
    /// <p>The token to retrieve the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

/// <p>The input for the ListTopicRules operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListTopicRulesRequest {
    /// <p>The maximum number of results to return.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>A token used to retrieve the next value.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The topic.</p>
    #[serde(rename = "topic")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic: Option<String>,
}

/// <p>The output from the ListTopicRules operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListTopicRulesResponse {
    /// <p>A token used to retrieve the next value.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The rules.</p>
    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Vec<TopicRuleListItem>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListV2LoggingLevelsRequest {
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The type of resource for which you are configuring logging. Must be <code>THING_Group</code>.</p>
    #[serde(rename = "targetType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListV2LoggingLevelsResponse {
    /// <p>The logging configuration for a target.</p>
    #[serde(rename = "logTargetConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_target_configurations: Option<Vec<LogTargetConfiguration>>,
    /// <p>The token used to get the next set of results, or <b>null</b> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ListViolationEventsRequest {
    /// <p>The end time for the alerts to be listed.</p>
    #[serde(rename = "endTime")]
    pub end_time: f64,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token for the next set of results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>A filter to limit results to those alerts generated by the specified security profile.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The start time for the alerts to be listed.</p>
    #[serde(rename = "startTime")]
    pub start_time: f64,
    /// <p>A filter to limit results to those alerts caused by the specified thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ListViolationEventsResponse {
    /// <p>A token that can be used to retrieve the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The security profile violation alerts issued for this account during the given time period, potentially filtered by security profile, behavior violated, or thing (device) violating.</p>
    #[serde(rename = "violationEvents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_events: Option<Vec<ViolationEvent>>,
}

/// <p>A log target.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LogTarget {
    /// <p>The target name.</p>
    #[serde(rename = "targetName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_name: Option<String>,
    /// <p>The target type.</p>
    #[serde(rename = "targetType")]
    pub target_type: String,
}

/// <p>The target configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct LogTargetConfiguration {
    /// <p>The logging level.</p>
    #[serde(rename = "logLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_level: Option<String>,
    /// <p>A log target</p>
    #[serde(rename = "logTarget")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_target: Option<LogTarget>,
}

/// <p>Describes the logging options payload.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct LoggingOptionsPayload {
    /// <p>The log level.</p>
    #[serde(rename = "logLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub log_level: Option<String>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>The value to be compared with the <code>metric</code>.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MetricValue {
    /// <p>If the <code>comparisonOperator</code> calls for a set of CIDRs, use this to specify that set to be compared with the <code>metric</code>.</p>
    #[serde(rename = "cidrs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cidrs: Option<Vec<String>>,
    /// <p>If the <code>comparisonOperator</code> calls for a numeric value, use this to specify that numeric value to be compared with the <code>metric</code>.</p>
    #[serde(rename = "count")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// <p>If the <code>comparisonOperator</code> calls for a set of ports, use this to specify that set to be compared with the <code>metric</code>.</p>
    #[serde(rename = "ports")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ports: Option<Vec<i64>>,
}

/// <p>Describes which changes should be applied as part of a mitigation action.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct MitigationAction {
    /// <p>The set of parameters for this mitigation action. The parameters vary, depending on the kind of action you apply.</p>
    #[serde(rename = "actionParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_params: Option<MitigationActionParams>,
    /// <p>A unique identifier for the mitigation action.</p>
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    /// <p>A user-friendly name for the mitigation action.</p>
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// <p>The IAM role ARN used to apply this mitigation action.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>Information that identifies a mitigation action. This information is returned by ListMitigationActions.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct MitigationActionIdentifier {
    /// <p>The IAM role ARN used to apply this mitigation action.</p>
    #[serde(rename = "actionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_arn: Option<String>,
    /// <p>The friendly name of the mitigation action.</p>
    #[serde(rename = "actionName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_name: Option<String>,
    /// <p>The date when this mitigation action was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
}

/// <p>The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MitigationActionParams {
    /// <p>Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.</p>
    #[serde(rename = "addThingsToThingGroupParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub add_things_to_thing_group_params: Option<AddThingsToThingGroupParams>,
    /// <p>Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.</p>
    #[serde(rename = "enableIoTLoggingParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enable_io_t_logging_params: Option<EnableIoTLoggingParams>,
    /// <p>Parameters to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.</p>
    #[serde(rename = "publishFindingToSnsParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub publish_finding_to_sns_params: Option<PublishFindingToSnsParams>,
    /// <p>Parameters to define a mitigation action that adds a blank policy to restrict permissions.</p>
    #[serde(rename = "replaceDefaultPolicyVersionParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replace_default_policy_version_params: Option<ReplaceDefaultPolicyVersionParams>,
    /// <p>Parameters to define a mitigation action that changes the state of the CA certificate to inactive.</p>
    #[serde(rename = "updateCACertificateParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub update_ca_certificate_params: Option<UpdateCACertificateParams>,
    /// <p>Parameters to define a mitigation action that changes the state of the device certificate to inactive.</p>
    #[serde(rename = "updateDeviceCertificateParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub update_device_certificate_params: Option<UpdateDeviceCertificateParams>,
}

/// <p>Specifies the MQTT context to use for the test authorizer request</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct MqttContext {
    /// <p>The value of the <code>clientId</code> key in an MQTT authorization request.</p>
    #[serde(rename = "clientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    /// <p>The value of the <code>password</code> key in an MQTT authorization request.</p>
    #[serde(rename = "password")]
    #[serde(
        deserialize_with = "::rusoto_core::serialization::SerdeBlob::deserialize_blob",
        serialize_with = "::rusoto_core::serialization::SerdeBlob::serialize_blob",
        default
    )]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub password: Option<bytes::Bytes>,
    /// <p>The value of the <code>username</code> key in an MQTT authorization request.</p>
    #[serde(rename = "username")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub username: Option<String>,
}

/// <p>Information about the resource that was noncompliant with the audit check.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct NonCompliantResource {
    /// <p>Other information about the noncompliant resource.</p>
    #[serde(rename = "additionalInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_info: Option<::std::collections::HashMap<String, String>>,
    /// <p>Information that identifies the noncompliant resource.</p>
    #[serde(rename = "resourceIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_identifier: Option<ResourceIdentifier>,
    /// <p>The type of the noncompliant resource.</p>
    #[serde(rename = "resourceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_type: Option<String>,
}

/// <p>Describes a file to be associated with an OTA update.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OTAUpdateFile {
    /// <p>A list of name/attribute pairs.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The code signing method of the file.</p>
    #[serde(rename = "codeSigning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code_signing: Option<CodeSigning>,
    /// <p>The location of the updated firmware.</p>
    #[serde(rename = "fileLocation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_location: Option<FileLocation>,
    /// <p>The name of the file.</p>
    #[serde(rename = "fileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_name: Option<String>,
    /// <p>The file version.</p>
    #[serde(rename = "fileVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_version: Option<String>,
}

/// <p>Information about an OTA update.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct OTAUpdateInfo {
    /// <p>A collection of name/value pairs</p>
    #[serde(rename = "additionalParameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_parameters: Option<::std::collections::HashMap<String, String>>,
    /// <p>The AWS IoT job ARN associated with the OTA update.</p>
    #[serde(rename = "awsIotJobArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_arn: Option<String>,
    /// <p>The AWS IoT job ID associated with the OTA update.</p>
    #[serde(rename = "awsIotJobId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_job_id: Option<String>,
    /// <p>Configuration for the rollout of OTA updates.</p>
    #[serde(rename = "awsJobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_job_executions_rollout_config: Option<AwsJobExecutionsRolloutConfig>,
    /// <p>The date when the OTA update was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>A description of the OTA update.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>Error information associated with the OTA update.</p>
    #[serde(rename = "errorInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_info: Option<ErrorInfo>,
    /// <p>The date when the OTA update was last updated.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The OTA update ARN.</p>
    #[serde(rename = "otaUpdateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_arn: Option<String>,
    /// <p>A list of files associated with the OTA update.</p>
    #[serde(rename = "otaUpdateFiles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_files: Option<Vec<OTAUpdateFile>>,
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_id: Option<String>,
    /// <p>The status of the OTA update.</p>
    #[serde(rename = "otaUpdateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_status: Option<String>,
    /// <p>Specifies whether the OTA update will continue to run (CONTINUOUS), or will be complete after all those things specified as targets have completed the OTA update (SNAPSHOT). If continuous, the OTA update may also be run on a thing when a change is detected in a target. For example, an OTA update will run on a thing when the thing is added to a target group, even after the OTA update was completed by all things originally in the group. </p>
    #[serde(rename = "targetSelection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_selection: Option<String>,
    /// <p>The targets of the OTA update.</p>
    #[serde(rename = "targets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub targets: Option<Vec<String>>,
}

/// <p>An OTA update summary.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct OTAUpdateSummary {
    /// <p>The date when the OTA update was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The OTA update ARN.</p>
    #[serde(rename = "otaUpdateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_arn: Option<String>,
    /// <p>The OTA update ID.</p>
    #[serde(rename = "otaUpdateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ota_update_id: Option<String>,
}

/// <p>A certificate that has been transferred but not yet accepted.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct OutgoingCertificate {
    /// <p>The certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The certificate ID.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
    /// <p>The certificate creation date.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The date the transfer was initiated.</p>
    #[serde(rename = "transferDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_date: Option<f64>,
    /// <p>The transfer message.</p>
    #[serde(rename = "transferMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_message: Option<String>,
    /// <p>The AWS account to which the transfer was made.</p>
    #[serde(rename = "transferredTo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transferred_to: Option<String>,
}

/// <p>Describes the percentile and percentile value.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct PercentPair {
    /// <p>The percentile.</p>
    #[serde(rename = "percent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub percent: Option<f64>,
    /// <p>The value of the percentile.</p>
    #[serde(rename = "value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
}

/// <p>Describes an AWS IoT policy.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct Policy {
    /// <p>The policy ARN.</p>
    #[serde(rename = "policyArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_arn: Option<String>,
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
}

/// <p>Describes a policy version.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct PolicyVersion {
    /// <p>The date and time the policy was created.</p>
    #[serde(rename = "createDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub create_date: Option<f64>,
    /// <p>Specifies whether the policy version is the default.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The policy version ID.</p>
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<String>,
}

/// <p>Information about the version of the policy associated with the resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PolicyVersionIdentifier {
    /// <p>The name of the policy.</p>
    #[serde(rename = "policyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_name: Option<String>,
    /// <p>The ID of the version of the policy associated with the resource.</p>
    #[serde(rename = "policyVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_id: Option<String>,
}

/// <p>Configuration for pre-signed S3 URLs.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PresignedUrlConfig {
    /// <p>How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.</p>
    #[serde(rename = "expiresInSec")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expires_in_sec: Option<i64>,
    /// <p>The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>A summary of information about a fleet provisioning template.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ProvisioningTemplateSummary {
    /// <p>The date when the fleet provisioning template summary was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The description of the fleet provisioning template.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>True if the fleet provision template is enabled, otherwise false.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// <p>The date when the fleet provisioning template summary was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the fleet provisioning template.</p>
    #[serde(rename = "templateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_arn: Option<String>,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_name: Option<String>,
}

/// <p>A summary of information about a fleet provision template version.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ProvisioningTemplateVersionSummary {
    /// <p>The date when the fleet provisioning template version was created</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>True if the fleet provisioning template version is the default version, otherwise false.</p>
    #[serde(rename = "isDefaultVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_default_version: Option<bool>,
    /// <p>The ID of the fleet privisioning template version.</p>
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<i64>,
}

/// <p>Parameters to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PublishFindingToSnsParams {
    /// <p>The ARN of the topic to which you want to publish the findings.</p>
    #[serde(rename = "topicArn")]
    pub topic_arn: String,
}

/// <p>An asset property value entry containing the following information.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutAssetPropertyValueEntry {
    /// <p>The ID of the AWS IoT SiteWise asset. You must specify either a <code>propertyAlias</code> or both an <code>analiasId</code> and a <code>propertyId</code>. Accepts substitution templates.</p>
    #[serde(rename = "assetId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub asset_id: Option<String>,
    /// <p>Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.</p>
    #[serde(rename = "entryId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entry_id: Option<String>,
    /// <p>The name of the property alias associated with your asset property. You must specify either a <code>propertyAlias</code> or both an <code>aliasId</code> and a <code>propertyId</code>. Accepts substitution templates.</p>
    #[serde(rename = "propertyAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub property_alias: Option<String>,
    /// <p>The ID of the asset's property. You must specify either a <code>propertyAlias</code> or both an <code>analiasId</code> and a <code>propertyId</code>. Accepts substitution templates.</p>
    #[serde(rename = "propertyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub property_id: Option<String>,
    /// <p>A list of property values to insert that each contain timestamp, quality, and value (TQV) information.</p>
    #[serde(rename = "propertyValues")]
    pub property_values: Vec<AssetPropertyValue>,
}

/// <p>The input for the DynamoActionVS action that specifies the DynamoDB table to which the message data will be written.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutItemInput {
    /// <p>The table where the message data will be written.</p>
    #[serde(rename = "tableName")]
    pub table_name: String,
}

/// <p>Allows you to define a criteria to initiate the increase in rate of rollout for a job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RateIncreaseCriteria {
    /// <p>The threshold for number of notified things that will initiate the increase in rate of rollout.</p>
    #[serde(rename = "numberOfNotifiedThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_notified_things: Option<i64>,
    /// <p>The threshold for number of succeeded things that will initiate the increase in rate of rollout.</p>
    #[serde(rename = "numberOfSucceededThings")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub number_of_succeeded_things: Option<i64>,
}

/// <p>The input to the RegisterCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RegisterCACertificateRequest {
    /// <p>Allows this CA certificate to be used for auto registration of device certificates.</p>
    #[serde(rename = "allowAutoRegistration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_auto_registration: Option<bool>,
    /// <p>The CA certificate.</p>
    #[serde(rename = "caCertificate")]
    pub ca_certificate: String,
    /// <p>Information about the registration configuration.</p>
    #[serde(rename = "registrationConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_config: Option<RegistrationConfig>,
    /// <p>A boolean value that specifies if the CA certificate is set to active.</p>
    #[serde(rename = "setAsActive")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub set_as_active: Option<bool>,
    /// <p>The private key verification certificate.</p>
    #[serde(rename = "verificationCertificate")]
    pub verification_certificate: String,
}

/// <p>The output from the RegisterCACertificateResponse operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RegisterCACertificateResponse {
    /// <p>The CA certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The CA certificate identifier.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
}

/// <p>The input to the RegisterCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RegisterCertificateRequest {
    /// <p>The CA certificate used to sign the device certificate being registered.</p>
    #[serde(rename = "caCertificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ca_certificate_pem: Option<String>,
    /// <p>The certificate data, in PEM format.</p>
    #[serde(rename = "certificatePem")]
    pub certificate_pem: String,
    /// <p>The status of the register certificate request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
}

/// <p>The output from the RegisterCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RegisterCertificateResponse {
    /// <p>The certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The certificate identifier.</p>
    #[serde(rename = "certificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RegisterThingRequest {
    /// <p>The parameters for provisioning a thing. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html">Programmatic Provisioning</a> for more information.</p>
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<::std::collections::HashMap<String, String>>,
    /// <p>The provisioning template. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html">Programmatic Provisioning</a> for more information.</p>
    #[serde(rename = "templateBody")]
    pub template_body: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RegisterThingResponse {
    /// <p>.</p>
    #[serde(rename = "certificatePem")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_pem: Option<String>,
    /// <p>ARNs for the generated resources.</p>
    #[serde(rename = "resourceArns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_arns: Option<::std::collections::HashMap<String, String>>,
}

/// <p>The registration configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RegistrationConfig {
    /// <p>The ARN of the role.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The template body.</p>
    #[serde(rename = "templateBody")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_body: Option<String>,
}

/// <p>The input for the RejectCertificateTransfer operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RejectCertificateTransferRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The reason the certificate transfer was rejected.</p>
    #[serde(rename = "rejectReason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
}

/// <p>Information about a related resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RelatedResource {
    /// <p>Other information about the resource.</p>
    #[serde(rename = "additionalInfo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_info: Option<::std::collections::HashMap<String, String>>,
    /// <p>Information that identifies the resource.</p>
    #[serde(rename = "resourceIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_identifier: Option<ResourceIdentifier>,
    /// <p>The type of resource.</p>
    #[serde(rename = "resourceType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resource_type: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RemoveThingFromBillingGroupRequest {
    /// <p>The ARN of the billing group.</p>
    #[serde(rename = "billingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_arn: Option<String>,
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub billing_group_name: Option<String>,
    /// <p>The ARN of the thing to be removed from the billing group.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The name of the thing to be removed from the billing group.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RemoveThingFromBillingGroupResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct RemoveThingFromThingGroupRequest {
    /// <p>The ARN of the thing to remove from the group.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The group ARN.</p>
    #[serde(rename = "thingGroupArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_arn: Option<String>,
    /// <p>The group name.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
    /// <p>The name of the thing to remove from the group.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RemoveThingFromThingGroupResponse {}

/// <p>Parameters to define a mitigation action that adds a blank policy to restrict permissions.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReplaceDefaultPolicyVersionParams {
    /// <p>The name of the template to be applied. The only supported value is <code>BLANK_POLICY</code>.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

/// <p>The input for the ReplaceTopicRule operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ReplaceTopicRuleRequest {
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    pub rule_name: String,
    /// <p>The rule payload.</p>
    #[serde(rename = "topicRulePayload")]
    pub topic_rule_payload: TopicRulePayload,
}

/// <p>Describes an action to republish to another topic.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepublishAction {
    /// <p>The Quality of Service (QoS) level to use when republishing messages. The default value is 0.</p>
    #[serde(rename = "qos")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qos: Option<i64>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the MQTT topic.</p>
    #[serde(rename = "topic")]
    pub topic: String,
}

/// <p>Information that identifies the noncompliant resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ResourceIdentifier {
    /// <p>The account with which the resource is associated.</p>
    #[serde(rename = "account")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account: Option<String>,
    /// <p>The ID of the CA certificate used to authorize the certificate.</p>
    #[serde(rename = "caCertificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ca_certificate_id: Option<String>,
    /// <p>The client ID.</p>
    #[serde(rename = "clientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    /// <p>The ID of the Amazon Cognito identity pool.</p>
    #[serde(rename = "cognitoIdentityPoolId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cognito_identity_pool_id: Option<String>,
    /// <p>The ID of the certificate attached to the resource.</p>
    #[serde(rename = "deviceCertificateId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub device_certificate_id: Option<String>,
    /// <p>The ARN of the IAM role that has overly permissive actions.</p>
    #[serde(rename = "iamRoleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub iam_role_arn: Option<String>,
    /// <p>The version of the policy associated with the resource.</p>
    #[serde(rename = "policyVersionIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_version_identifier: Option<PolicyVersionIdentifier>,
    /// <p>The ARN of the role alias that has overly permissive actions.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
}

/// <p>Role alias description.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct RoleAliasDescription {
    /// <p>The UNIX timestamp of when the role alias was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The number of seconds for which the credential is valid.</p>
    #[serde(rename = "credentialDurationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential_duration_seconds: Option<i64>,
    /// <p>The UNIX timestamp of when the role alias was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The role alias owner.</p>
    #[serde(rename = "owner")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub owner: Option<String>,
    /// <p>The role alias.</p>
    #[serde(rename = "roleAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias: Option<String>,
    /// <p>The ARN of the role alias.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
    /// <p>The role ARN.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>Describes an action to write data to an Amazon S3 bucket.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct S3Action {
    /// <p>The Amazon S3 bucket.</p>
    #[serde(rename = "bucketName")]
    pub bucket_name: String,
    /// <p>The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl">S3 canned ACLs</a>.</p>
    #[serde(rename = "cannedAcl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canned_acl: Option<String>,
    /// <p>The object key.</p>
    #[serde(rename = "key")]
    pub key: String,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
}

/// <p>Describes the location of updated firmware in S3.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct S3Destination {
    /// <p>The S3 bucket that contains the updated firmware.</p>
    #[serde(rename = "bucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// <p>The S3 prefix.</p>
    #[serde(rename = "prefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
}

/// <p>The S3 location.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct S3Location {
    /// <p>The S3 bucket.</p>
    #[serde(rename = "bucket")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub bucket: Option<String>,
    /// <p>The S3 key.</p>
    #[serde(rename = "key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// <p>The S3 bucket version.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// <p>Describes an action to write a message to a Salesforce IoT Cloud Input Stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SalesforceAction {
    /// <p>The token used to authenticate access to the Salesforce IoT Cloud Input Stream. The token is available from the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
    #[serde(rename = "token")]
    pub token: String,
    /// <p>The URL exposed by the Salesforce IoT Cloud Input Stream. The URL is available from the Salesforce IoT Cloud platform after creation of the Input Stream.</p>
    #[serde(rename = "url")]
    pub url: String,
}

/// <p>Information about the scheduled audit.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ScheduledAuditMetadata {
    /// <p>The day of the month on which the scheduled audit is run (if the <code>frequency</code> is "MONTHLY"). If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit is run (if the <code>frequency</code> is "WEEKLY" or "BIWEEKLY").</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit occurs.</p>
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<String>,
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
    /// <p>The name of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SearchIndexRequest {
    /// <p>The search index name.</p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The maximum number of results to return at one time.</p>
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i64>,
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The search query string.</p>
    #[serde(rename = "queryString")]
    pub query_string: String,
    /// <p>The query version.</p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct SearchIndexResponse {
    /// <p>The token used to get the next set of results, or <code>null</code> if there are no additional results.</p>
    #[serde(rename = "nextToken")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_token: Option<String>,
    /// <p>The thing groups that match the search query.</p>
    #[serde(rename = "thingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups: Option<Vec<ThingGroupDocument>>,
    /// <p>The things that match the search query.</p>
    #[serde(rename = "things")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub things: Option<Vec<ThingDocument>>,
}

/// <p>Identifying information for a Device Defender security profile.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct SecurityProfileIdentifier {
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "arn")]
    pub arn: String,
    /// <p>The name you have given to the security profile.</p>
    #[serde(rename = "name")]
    pub name: String,
}

/// <p>A target to which an alert is sent when a security profile behavior is violated.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct SecurityProfileTarget {
    /// <p>The ARN of the security profile.</p>
    #[serde(rename = "arn")]
    pub arn: String,
}

/// <p>Information about a security profile and the target associated with it.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct SecurityProfileTargetMapping {
    /// <p>Information that identifies the security profile.</p>
    #[serde(rename = "securityProfileIdentifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_identifier: Option<SecurityProfileIdentifier>,
    /// <p>Information about the target (thing group) associated with the security profile.</p>
    #[serde(rename = "target")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target: Option<SecurityProfileTarget>,
}

/// <p>An object that contains information about a server certificate.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ServerCertificateSummary {
    /// <p>The ARN of the server certificate.</p>
    #[serde(rename = "serverCertificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_certificate_arn: Option<String>,
    /// <p>The status of the server certificate.</p>
    #[serde(rename = "serverCertificateStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_certificate_status: Option<String>,
    /// <p>Details that explain the status of the server certificate.</p>
    #[serde(rename = "serverCertificateStatusDetail")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_certificate_status_detail: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetDefaultAuthorizerRequest {
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct SetDefaultAuthorizerResponse {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

/// <p>The input for the SetDefaultPolicyVersion operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetDefaultPolicyVersionRequest {
    /// <p>The policy name.</p>
    #[serde(rename = "policyName")]
    pub policy_name: String,
    /// <p>The policy version ID.</p>
    #[serde(rename = "policyVersionId")]
    pub policy_version_id: String,
}

/// <p>The input for the SetLoggingOptions operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetLoggingOptionsRequest {
    /// <p>The logging options payload.</p>
    #[serde(rename = "loggingOptionsPayload")]
    pub logging_options_payload: LoggingOptionsPayload,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetV2LoggingLevelRequest {
    /// <p>The log level.</p>
    #[serde(rename = "logLevel")]
    pub log_level: String,
    /// <p>The log target.</p>
    #[serde(rename = "logTarget")]
    pub log_target: LogTarget,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct SetV2LoggingOptionsRequest {
    /// <p>The default logging level.</p>
    #[serde(rename = "defaultLogLevel")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_log_level: Option<String>,
    /// <p>If true all logs are disabled. The default is false.</p>
    #[serde(rename = "disableAllLogs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disable_all_logs: Option<bool>,
    /// <p>The ARN of the role that allows IoT to write to Cloudwatch logs.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

/// <p>Use Sig V4 authorization.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SigV4Authorization {
    /// <p>The ARN of the signing role.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The service name to use while signing with Sig V4.</p>
    #[serde(rename = "serviceName")]
    pub service_name: String,
    /// <p>The signing region.</p>
    #[serde(rename = "signingRegion")]
    pub signing_region: String,
}

/// <p>Describes the code-signing profile.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SigningProfileParameter {
    /// <p>Certificate ARN.</p>
    #[serde(rename = "certificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_arn: Option<String>,
    /// <p>The location of the code-signing certificate on your device.</p>
    #[serde(rename = "certificatePathOnDevice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub certificate_path_on_device: Option<String>,
    /// <p>The hardware platform of your device.</p>
    #[serde(rename = "platform")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub platform: Option<String>,
}

/// <p>Describes an action to publish to an Amazon SNS topic.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SnsAction {
    /// <p>(Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. To read more about SNS message formats, see <a href="https://docs.aws.amazon.com/sns/latest/dg/json-formats.html">https://docs.aws.amazon.com/sns/latest/dg/json-formats.html</a> refer to their official documentation.</p>
    #[serde(rename = "messageFormat")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_format: Option<String>,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The ARN of the SNS topic.</p>
    #[serde(rename = "targetArn")]
    pub target_arn: String,
}

/// <p>Describes an action to publish data to an Amazon SQS queue.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SqsAction {
    /// <p>The URL of the Amazon SQS queue.</p>
    #[serde(rename = "queueUrl")]
    pub queue_url: String,
    /// <p>The ARN of the IAM role that grants access.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>Specifies whether to use Base64 encoding.</p>
    #[serde(rename = "useBase64")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub use_base_64: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StartAuditMitigationActionsTaskRequest {
    /// <p>For an audit check, specifies which mitigation actions to apply. Those actions must be defined in your AWS account.</p>
    #[serde(rename = "auditCheckToActionsMapping")]
    pub audit_check_to_actions_mapping: ::std::collections::HashMap<String, Vec<String>>,
    /// <p>Each audit mitigation task must have a unique client request token. If you try to start a new task with the same token as a task that already exists, an exception occurs. If you omit this value, a unique client request token is generated automatically.</p>
    #[serde(rename = "clientRequestToken")]
    pub client_request_token: String,
    /// <p>Specifies the audit findings to which the mitigation actions are applied. You can apply them to a type of audit check, to all findings from an audit, or to a speecific set of findings.</p>
    #[serde(rename = "target")]
    pub target: AuditMitigationActionsTaskTarget,
    /// <p>A unique identifier for the task. You can use this identifier to check the status of the task or to cancel it.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct StartAuditMitigationActionsTaskResponse {
    /// <p>The unique identifier for the audit mitigation task. This matches the <code>taskId</code> that you specified in the request.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StartOnDemandAuditTaskRequest {
    /// <p>Which checks are performed during the audit. The checks you specify must be enabled for your account or an exception occurs. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.</p>
    #[serde(rename = "targetCheckNames")]
    pub target_check_names: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct StartOnDemandAuditTaskResponse {
    /// <p>The ID of the on-demand audit you started.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

/// <p>Information required to start a signing job.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StartSigningJobParameter {
    /// <p>The location to write the code-signed file.</p>
    #[serde(rename = "destination")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination: Option<Destination>,
    /// <p>The code-signing profile name.</p>
    #[serde(rename = "signingProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signing_profile_name: Option<String>,
    /// <p>Describes the code-signing profile.</p>
    #[serde(rename = "signingProfileParameter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signing_profile_parameter: Option<SigningProfileParameter>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StartThingRegistrationTaskRequest {
    /// <p>The S3 bucket that contains the input file.</p>
    #[serde(rename = "inputFileBucket")]
    pub input_file_bucket: String,
    /// <p>The name of input file within the S3 bucket. This file contains a newline delimited JSON file. Each line contains the parameter values to provision one device (thing).</p>
    #[serde(rename = "inputFileKey")]
    pub input_file_key: String,
    /// <p>The IAM role ARN that grants permission the input file.</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The provisioning template.</p>
    #[serde(rename = "templateBody")]
    pub template_body: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct StartThingRegistrationTaskResponse {
    /// <p>The bulk thing provisioning task ID.</p>
    #[serde(rename = "taskId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub task_id: Option<String>,
}

/// <p>A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StatisticalThreshold {
    /// <p>The percentile which resolves to a threshold value by which compliance with a behavior is determined. Metrics are collected over the specified period (<code>durationSeconds</code>) from all reporting devices in your account and statistical ranks are calculated. Then, the measurements from a device are collected over the same period. If the accumulated measurements from the device fall above or below (<code>comparisonOperator</code>) the value associated with the percentile specified, then the device is considered to be in compliance with the behavior, otherwise a violation occurs.</p>
    #[serde(rename = "statistic")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub statistic: Option<String>,
}

/// <p>A map of key-value pairs for all supported statistics. Currently, only count is supported.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct Statistics {
    /// <p>The average of the aggregated field values.</p>
    #[serde(rename = "average")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub average: Option<f64>,
    /// <p>The count of things that match the query.</p>
    #[serde(rename = "count")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub count: Option<i64>,
    /// <p>The maximum aggregated field value.</p>
    #[serde(rename = "maximum")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maximum: Option<f64>,
    /// <p>The minimum aggregated field value.</p>
    #[serde(rename = "minimum")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minimum: Option<f64>,
    /// <p>The standard deviation of the aggregated field values.</p>
    #[serde(rename = "stdDeviation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub std_deviation: Option<f64>,
    /// <p>The sum of the aggregated field values.</p>
    #[serde(rename = "sum")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sum: Option<f64>,
    /// <p>The sum of the squares of the aggregated field values.</p>
    #[serde(rename = "sumOfSquares")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sum_of_squares: Option<f64>,
    /// <p>The variance of the aggregated field values.</p>
    #[serde(rename = "variance")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variance: Option<f64>,
}

/// <p>Starts execution of a Step Functions state machine.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StepFunctionsAction {
    /// <p>(Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.</p>
    #[serde(rename = "executionNamePrefix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_name_prefix: Option<String>,
    /// <p>The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").</p>
    #[serde(rename = "roleArn")]
    pub role_arn: String,
    /// <p>The name of the Step Functions state machine whose execution will be started.</p>
    #[serde(rename = "stateMachineName")]
    pub state_machine_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct StopThingRegistrationTaskRequest {
    /// <p>The bulk thing provisioning task ID.</p>
    #[serde(rename = "taskId")]
    pub task_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct StopThingRegistrationTaskResponse {}

/// <p>Describes a group of files that can be streamed.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Stream {
    /// <p>The ID of a file associated with a stream.</p>
    #[serde(rename = "fileId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<i64>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
}

/// <p>Represents a file to stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct StreamFile {
    /// <p>The file ID.</p>
    #[serde(rename = "fileId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_id: Option<i64>,
    /// <p>The location of the file in S3.</p>
    #[serde(rename = "s3Location")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub s_3_location: Option<S3Location>,
}

/// <p>Information about a stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct StreamInfo {
    /// <p>The date when the stream was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files to stream.</p>
    #[serde(rename = "files")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<StreamFile>>,
    /// <p>The date when the stream was last updated.</p>
    #[serde(rename = "lastUpdatedAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_updated_at: Option<f64>,
    /// <p>An IAM role AWS IoT assumes to access your S3 files.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The stream version.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

/// <p>A summary of a stream.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct StreamSummary {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The stream version.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

/// <p>A set of key/value pairs that are used to manage the resource.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Tag {
    /// <p>The tag's key.</p>
    #[serde(rename = "Key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    /// <p>The tag's value.</p>
    #[serde(rename = "Value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TagResourceRequest {
    /// <p>The ARN of the resource.</p>
    #[serde(rename = "resourceArn")]
    pub resource_arn: String,
    /// <p>The new or modified tags for the resource.</p>
    #[serde(rename = "tags")]
    pub tags: Vec<Tag>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TagResourceResponse {}

/// <p>Statistics for the checks performed during the audit.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TaskStatistics {
    /// <p>The number of checks that did not run because the audit was canceled.</p>
    #[serde(rename = "canceledChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canceled_checks: Option<i64>,
    /// <p>The number of checks that found compliant resources.</p>
    #[serde(rename = "compliantChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compliant_checks: Option<i64>,
    /// <p>The number of checks.</p>
    #[serde(rename = "failedChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failed_checks: Option<i64>,
    /// <p>The number of checks in progress.</p>
    #[serde(rename = "inProgressChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub in_progress_checks: Option<i64>,
    /// <p>The number of checks that found noncompliant resources.</p>
    #[serde(rename = "nonCompliantChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub non_compliant_checks: Option<i64>,
    /// <p>The number of checks in this audit.</p>
    #[serde(rename = "totalChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_checks: Option<i64>,
    /// <p>The number of checks waiting for data collection.</p>
    #[serde(rename = "waitingForDataCollectionChecks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub waiting_for_data_collection_checks: Option<i64>,
}

/// <p>Provides summary counts of how many tasks for findings are in a particular state. This information is included in the response from DescribeAuditMitigationActionsTask.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TaskStatisticsForAuditCheck {
    /// <p>The number of findings to which the mitigation action task was canceled when applied.</p>
    #[serde(rename = "canceledFindingsCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canceled_findings_count: Option<i64>,
    /// <p>The number of findings for which at least one of the actions failed when applied.</p>
    #[serde(rename = "failedFindingsCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub failed_findings_count: Option<i64>,
    /// <p>The number of findings skipped because of filter conditions provided in the parameters to the command.</p>
    #[serde(rename = "skippedFindingsCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub skipped_findings_count: Option<i64>,
    /// <p>The number of findings for which all mitigation actions succeeded when applied.</p>
    #[serde(rename = "succeededFindingsCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub succeeded_findings_count: Option<i64>,
    /// <p>The total number of findings to which a task is being applied.</p>
    #[serde(rename = "totalFindingsCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_findings_count: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TestAuthorizationRequest {
    /// <p>A list of authorization info objects. Simulating authorization will create a response for each <code>authInfo</code> object in the list.</p>
    #[serde(rename = "authInfos")]
    pub auth_infos: Vec<AuthInfo>,
    /// <p>The MQTT client ID.</p>
    #[serde(rename = "clientId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_id: Option<String>,
    /// <p>The Cognito identity pool ID.</p>
    #[serde(rename = "cognitoIdentityPoolId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cognito_identity_pool_id: Option<String>,
    /// <p>When testing custom authorization, the policies specified here are treated as if they are attached to the principal being authorized.</p>
    #[serde(rename = "policyNamesToAdd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_names_to_add: Option<Vec<String>>,
    /// <p>When testing custom authorization, the policies specified here are treated as if they are not attached to the principal being authorized.</p>
    #[serde(rename = "policyNamesToSkip")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_names_to_skip: Option<Vec<String>>,
    /// <p>The principal.</p>
    #[serde(rename = "principal")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principal: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TestAuthorizationResponse {
    /// <p>The authentication results.</p>
    #[serde(rename = "authResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auth_results: Option<Vec<AuthResult>>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TestInvokeAuthorizerRequest {
    /// <p>The custom authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
    /// <p>Specifies a test HTTP authorization request.</p>
    #[serde(rename = "httpContext")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub http_context: Option<HttpContext>,
    /// <p>Specifies a test MQTT authorization request.&gt;</p>
    #[serde(rename = "mqttContext")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mqtt_context: Option<MqttContext>,
    /// <p>Specifies a test TLS authorization request.</p>
    #[serde(rename = "tlsContext")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tls_context: Option<TlsContext>,
    /// <p>The token returned by your custom authentication service.</p>
    #[serde(rename = "token")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    /// <p>The signature made with the token and your custom authentication service's private key.</p>
    #[serde(rename = "tokenSignature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_signature: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TestInvokeAuthorizerResponse {
    /// <p>The number of seconds after which the connection is terminated.</p>
    #[serde(rename = "disconnectAfterInSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disconnect_after_in_seconds: Option<i64>,
    /// <p>True if the token is authenticated, otherwise false.</p>
    #[serde(rename = "isAuthenticated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_authenticated: Option<bool>,
    /// <p>IAM policy documents.</p>
    #[serde(rename = "policyDocuments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub policy_documents: Option<Vec<String>>,
    /// <p>The principal ID.</p>
    #[serde(rename = "principalId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub principal_id: Option<String>,
    /// <p>The number of seconds after which the temporary credentials are refreshed.</p>
    #[serde(rename = "refreshAfterInSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refresh_after_in_seconds: Option<i64>,
}

/// <p>The properties of the thing, including thing name, thing type name, and a list of thing attributes.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingAttribute {
    /// <p>A list of thing attributes which are name-value pairs.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>The thing ARN.</p>
    #[serde(rename = "thingArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_arn: Option<String>,
    /// <p>The name of the thing.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The name of the thing type, if the thing has been associated with a type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p>The version of the thing record in the registry.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// <p>The connectivity status of the thing.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingConnectivity {
    /// <p>True if the thing is connected to the AWS IoT service; false if it is not connected.</p>
    #[serde(rename = "connected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connected: Option<bool>,
    /// <p>The epoch time (in milliseconds) when the thing last connected or disconnected. If the thing has been disconnected for more than a few weeks, the time value might be missing.</p>
    #[serde(rename = "timestamp")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timestamp: Option<i64>,
}

/// <p>The thing search index document.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingDocument {
    /// <p>The attributes.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>Indicates whether the thing is connected to the AWS IoT service.</p>
    #[serde(rename = "connectivity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connectivity: Option<ThingConnectivity>,
    /// <p>The shadow.</p>
    #[serde(rename = "shadow")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shadow: Option<String>,
    /// <p>Thing group names.</p>
    #[serde(rename = "thingGroupNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_names: Option<Vec<String>>,
    /// <p>The thing ID.</p>
    #[serde(rename = "thingId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_id: Option<String>,
    /// <p>The thing name.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The thing type name.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The thing group search index document.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingGroupDocument {
    /// <p>The thing group attributes.</p>
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attributes: Option<::std::collections::HashMap<String, String>>,
    /// <p>Parent group names.</p>
    #[serde(rename = "parentGroupNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group_names: Option<Vec<String>>,
    /// <p>The thing group description.</p>
    #[serde(rename = "thingGroupDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_description: Option<String>,
    /// <p>The thing group ID.</p>
    #[serde(rename = "thingGroupId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_id: Option<String>,
    /// <p>The thing group name.</p>
    #[serde(rename = "thingGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_name: Option<String>,
}

/// <p>Thing group indexing configuration.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingGroupIndexingConfiguration {
    /// <p>A list of thing group fields to index. This list cannot contain any managed fields. Use the GetIndexingConfiguration API to get a list of managed fields.</p> <p>Contains custom field names and their data type.</p>
    #[serde(rename = "customFields")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_fields: Option<Vec<Field>>,
    /// <p>Contains fields that are indexed and whose types are already known by the Fleet Indexing service.</p>
    #[serde(rename = "managedFields")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub managed_fields: Option<Vec<Field>>,
    /// <p>Thing group indexing mode.</p>
    #[serde(rename = "thingGroupIndexingMode")]
    pub thing_group_indexing_mode: String,
}

/// <p>Thing group metadata.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingGroupMetadata {
    /// <p>The UNIX timestamp of when the thing group was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The parent thing group name.</p>
    #[serde(rename = "parentGroupName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_group_name: Option<String>,
    /// <p>The root parent thing group.</p>
    #[serde(rename = "rootToParentThingGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub root_to_parent_thing_groups: Option<Vec<GroupNameAndArn>>,
}

/// <p>Thing group properties.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingGroupProperties {
    /// <p>The thing group attributes in JSON format.</p>
    #[serde(rename = "attributePayload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_payload: Option<AttributePayload>,
    /// <p>The thing group description.</p>
    #[serde(rename = "thingGroupDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_description: Option<String>,
}

/// <p>The thing indexing configuration. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/managing-index.html">Managing Thing Indexing</a>.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingIndexingConfiguration {
    /// <p>Contains custom field names and their data type.</p>
    #[serde(rename = "customFields")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub custom_fields: Option<Vec<Field>>,
    /// <p>Contains fields that are indexed and whose types are already known by the Fleet Indexing service.</p>
    #[serde(rename = "managedFields")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub managed_fields: Option<Vec<Field>>,
    /// <p><p>Thing connectivity indexing mode. Valid values are: </p> <ul> <li> <p>STATUS  Your thing index contains connectivity status. To enable thing connectivity indexing, thingIndexMode must not be set to OFF.</p> </li> <li> <p>OFF - Thing connectivity status indexing is disabled.</p> </li> </ul></p>
    #[serde(rename = "thingConnectivityIndexingMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_connectivity_indexing_mode: Option<String>,
    /// <p><p>Thing indexing mode. Valid values are:</p> <ul> <li> <p>REGISTRY  Your thing index contains registry data only.</p> </li> <li> <p>REGISTRY<em>AND</em>SHADOW - Your thing index contains registry and shadow data.</p> </li> <li> <p>OFF - Thing indexing is disabled.</p> </li> </ul></p>
    #[serde(rename = "thingIndexingMode")]
    pub thing_indexing_mode: String,
}

/// <p>The definition of the thing type, including thing type name and description.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingTypeDefinition {
    /// <p>The thing type ARN.</p>
    #[serde(rename = "thingTypeArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_arn: Option<String>,
    /// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when it was deprecated.</p>
    #[serde(rename = "thingTypeMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_metadata: Option<ThingTypeMetadata>,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
    /// <p>The ThingTypeProperties for the thing type.</p>
    #[serde(rename = "thingTypeProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_properties: Option<ThingTypeProperties>,
}

/// <p>The ThingTypeMetadata contains additional information about the thing type including: creation date and time, a value indicating whether the thing type is deprecated, and a date and time when time was deprecated.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ThingTypeMetadata {
    /// <p>The date and time when the thing type was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>Whether the thing type is deprecated. If <b>true</b>, no new things could be associated with this type.</p>
    #[serde(rename = "deprecated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deprecated: Option<bool>,
    /// <p>The date and time when the thing type was deprecated.</p>
    #[serde(rename = "deprecationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deprecation_date: Option<f64>,
}

/// <p>The ThingTypeProperties contains information about the thing type including: a thing type description, and a list of searchable thing attribute names.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThingTypeProperties {
    /// <p>A list of searchable thing attribute names.</p>
    #[serde(rename = "searchableAttributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub searchable_attributes: Option<Vec<String>>,
    /// <p>The description of the thing type.</p>
    #[serde(rename = "thingTypeDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_description: Option<String>,
}

/// <p>Specifies the amount of time each device has to finish its execution of the job. A timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the timer expires, it will be automatically set to <code>TIMED_OUT</code>.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimeoutConfig {
    /// <p>Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal <code>TIMED_OUT</code> status.</p>
    #[serde(rename = "inProgressTimeoutInMinutes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub in_progress_timeout_in_minutes: Option<i64>,
}

/// <p>Specifies the TLS context to use for the test authorizer request.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TlsContext {
    /// <p>The value of the <code>serverName</code> key in a TLS authorization request.</p>
    #[serde(rename = "serverName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_name: Option<String>,
}

/// <p>Describes a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TopicRule {
    /// <p>The actions associated with the rule.</p>
    #[serde(rename = "actions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub actions: Option<Vec<Action>>,
    /// <p>The version of the SQL rules engine to use when evaluating the rule.</p>
    #[serde(rename = "awsIotSqlVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_sql_version: Option<String>,
    /// <p>The date and time the rule was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The description of the rule.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The action to perform when an error occurs.</p>
    #[serde(rename = "errorAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_action: Option<Action>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
    /// <p>The SQL statement used to query the topic. When using a SQL query with multiple lines, be sure to escape the newline characters.</p>
    #[serde(rename = "sql")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sql: Option<String>,
}

/// <p>A topic rule destination.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TopicRuleDestination {
    /// <p>The topic rule destination URL.</p>
    #[serde(rename = "arn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// <p>Properties of the HTTP URL.</p>
    #[serde(rename = "httpUrlProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub http_url_properties: Option<HttpUrlDestinationProperties>,
    /// <p><p>The status of the topic rule destination. Valid values are:</p> <dl> <dt>IN<em>PROGRESS</dt> <dd> <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN</em>PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p> </dd> <dt>ENABLED</dt> <dd> <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p> </dd> <dt>DISABLED</dt> <dd> <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p> </dd> <dt>ERROR</dt> <dd> <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p> </dd> </dl></p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>Additional details or reason why the topic rule destination is in the current status.</p>
    #[serde(rename = "statusReason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_reason: Option<String>,
}

/// <p>Configuration of the topic rule destination.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TopicRuleDestinationConfiguration {
    /// <p>Configuration of the HTTP URL.</p>
    #[serde(rename = "httpUrlConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub http_url_configuration: Option<HttpUrlDestinationConfiguration>,
}

/// <p>Information about the topic rule destination.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TopicRuleDestinationSummary {
    /// <p>The topic rule destination ARN.</p>
    #[serde(rename = "arn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arn: Option<String>,
    /// <p>Information about the HTTP URL.</p>
    #[serde(rename = "httpUrlSummary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub http_url_summary: Option<HttpUrlDestinationSummary>,
    /// <p><p>The status of the topic rule destination. Valid values are:</p> <dl> <dt>IN<em>PROGRESS</dt> <dd> <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN</em>PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p> </dd> <dt>ENABLED</dt> <dd> <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p> </dd> <dt>DISABLED</dt> <dd> <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p> </dd> <dt>ERROR</dt> <dd> <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p> </dd> </dl></p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The reason the topic rule destination is in the current status.</p>
    #[serde(rename = "statusReason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status_reason: Option<String>,
}

/// <p>Describes a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TopicRuleListItem {
    /// <p>The date and time the rule was created.</p>
    #[serde(rename = "createdAt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<f64>,
    /// <p>The rule ARN.</p>
    #[serde(rename = "ruleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_arn: Option<String>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The name of the rule.</p>
    #[serde(rename = "ruleName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_name: Option<String>,
    /// <p>The pattern for the topic names that apply.</p>
    #[serde(rename = "topicPattern")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub topic_pattern: Option<String>,
}

/// <p>Describes a rule.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TopicRulePayload {
    /// <p>The actions associated with the rule.</p>
    #[serde(rename = "actions")]
    pub actions: Vec<Action>,
    /// <p>The version of the SQL rules engine to use when evaluating the rule.</p>
    #[serde(rename = "awsIotSqlVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aws_iot_sql_version: Option<String>,
    /// <p>The description of the rule.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The action to take when an error occurs.</p>
    #[serde(rename = "errorAction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_action: Option<Action>,
    /// <p>Specifies whether the rule is disabled.</p>
    #[serde(rename = "ruleDisabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rule_disabled: Option<bool>,
    /// <p>The SQL statement used to query the topic. For more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/iot-rules.html#aws-iot-sql-reference">AWS IoT SQL Reference</a> in the <i>AWS IoT Developer Guide</i>.</p>
    #[serde(rename = "sql")]
    pub sql: String,
}

/// <p>The input for the TransferCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct TransferCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The AWS account.</p>
    #[serde(rename = "targetAwsAccount")]
    pub target_aws_account: String,
    /// <p>The transfer message.</p>
    #[serde(rename = "transferMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_message: Option<String>,
}

/// <p>The output from the TransferCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TransferCertificateResponse {
    /// <p>The ARN of the certificate.</p>
    #[serde(rename = "transferredCertificateArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transferred_certificate_arn: Option<String>,
}

/// <p>Data used to transfer a certificate to an AWS account.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct TransferData {
    /// <p>The date the transfer was accepted.</p>
    #[serde(rename = "acceptDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub accept_date: Option<f64>,
    /// <p>The date the transfer was rejected.</p>
    #[serde(rename = "rejectDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject_date: Option<f64>,
    /// <p>The reason why the transfer was rejected.</p>
    #[serde(rename = "rejectReason")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reject_reason: Option<String>,
    /// <p>The date the transfer took place.</p>
    #[serde(rename = "transferDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_date: Option<f64>,
    /// <p>The transfer message.</p>
    #[serde(rename = "transferMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub transfer_message: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UntagResourceRequest {
    /// <p>The ARN of the resource.</p>
    #[serde(rename = "resourceArn")]
    pub resource_arn: String,
    /// <p>A list of the keys of the tags to be removed from the resource.</p>
    #[serde(rename = "tagKeys")]
    pub tag_keys: Vec<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UntagResourceResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateAccountAuditConfigurationRequest {
    /// <p>Specifies which audit checks are enabled and disabled for this account. Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are currently enabled.</p> <p>Some data collection might start immediately when certain checks are enabled. When a check is disabled, any data collected so far in relation to the check is deleted.</p> <p>You cannot disable a check if it is used by any scheduled audit. You must first delete the check from the scheduled audit or delete the scheduled audit itself.</p> <p>On the first call to <code>UpdateAccountAuditConfiguration</code>, this parameter is required and must specify at least one enabled check.</p>
    #[serde(rename = "auditCheckConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_check_configurations:
        Option<::std::collections::HashMap<String, AuditCheckConfiguration>>,
    /// <p>Information about the targets to which audit notifications are sent.</p>
    #[serde(rename = "auditNotificationTargetConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audit_notification_target_configurations:
        Option<::std::collections::HashMap<String, AuditNotificationTarget>>,
    /// <p>The ARN of the role that grants permission to AWS IoT to access information about your devices, policies, certificates and other items as required when performing an audit.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateAccountAuditConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateAuthorizerRequest {
    /// <p>The ARN of the authorizer's Lambda function.</p>
    #[serde(rename = "authorizerFunctionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_function_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    pub authorizer_name: String,
    /// <p>The status of the update authorizer request.</p>
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,
    /// <p>The key used to extract the token from the HTTP headers. </p>
    #[serde(rename = "tokenKeyName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_key_name: Option<String>,
    /// <p>The public keys used to verify the token signature.</p>
    #[serde(rename = "tokenSigningPublicKeys")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token_signing_public_keys: Option<::std::collections::HashMap<String, String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateAuthorizerResponse {
    /// <p>The authorizer ARN.</p>
    #[serde(rename = "authorizerArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_arn: Option<String>,
    /// <p>The authorizer name.</p>
    #[serde(rename = "authorizerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateBillingGroupRequest {
    /// <p>The name of the billing group.</p>
    #[serde(rename = "billingGroupName")]
    pub billing_group_name: String,
    /// <p>The properties of the billing group.</p>
    #[serde(rename = "billingGroupProperties")]
    pub billing_group_properties: BillingGroupProperties,
    /// <p>The expected version of the billing group. If the version of the billing group does not match the expected version specified in the request, the <code>UpdateBillingGroup</code> request is rejected with a <code>VersionConflictException</code>.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateBillingGroupResponse {
    /// <p>The latest version of the billing group.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

/// <p>Parameters to define a mitigation action that changes the state of the CA certificate to inactive.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateCACertificateParams {
    /// <p>The action that you want to apply to the CA cerrtificate. The only supported value is <code>DEACTIVATE</code>.</p>
    #[serde(rename = "action")]
    pub action: String,
}

/// <p>The input to the UpdateCACertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateCACertificateRequest {
    /// <p>The CA certificate identifier.</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The new value for the auto registration status. Valid values are: "ENABLE" or "DISABLE".</p>
    #[serde(rename = "newAutoRegistrationStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_auto_registration_status: Option<String>,
    /// <p>The updated status of the CA certificate.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "newStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_status: Option<String>,
    /// <p>Information about the registration configuration.</p>
    #[serde(rename = "registrationConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registration_config: Option<RegistrationConfig>,
    /// <p>If true, removes auto registration.</p>
    #[serde(rename = "removeAutoRegistration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_auto_registration: Option<bool>,
}

/// <p>The input for the UpdateCertificate operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateCertificateRequest {
    /// <p>The ID of the certificate. (The last part of the certificate ARN contains the certificate ID.)</p>
    #[serde(rename = "certificateId")]
    pub certificate_id: String,
    /// <p>The new status.</p> <p> <b>Note:</b> Setting the status to PENDING_TRANSFER will result in an exception being thrown. PENDING_TRANSFER is a status used internally by AWS IoT. It is not intended for developer use.</p> <p> <b>Note:</b> The status value REGISTER_INACTIVE is deprecated and should not be used.</p>
    #[serde(rename = "newStatus")]
    pub new_status: String,
}

/// <p>Parameters to define a mitigation action that changes the state of the device certificate to inactive.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct UpdateDeviceCertificateParams {
    /// <p>The action that you want to apply to the device cerrtificate. The only supported value is <code>DEACTIVATE</code>.</p>
    #[serde(rename = "action")]
    pub action: String,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateDomainConfigurationRequest {
    /// <p>An object that specifies the authorization service for a domain.</p>
    #[serde(rename = "authorizerConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorizer_config: Option<AuthorizerConfig>,
    /// <p>The name of the domain configuration to be updated.</p>
    #[serde(rename = "domainConfigurationName")]
    pub domain_configuration_name: String,
    /// <p>The status to which the domain configuration should be updated.</p>
    #[serde(rename = "domainConfigurationStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_status: Option<String>,
    /// <p>Removes the authorization configuration from a domain.</p>
    #[serde(rename = "removeAuthorizerConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_authorizer_config: Option<bool>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateDomainConfigurationResponse {
    /// <p>The ARN of the domain configuration that was updated.</p>
    #[serde(rename = "domainConfigurationArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_arn: Option<String>,
    /// <p>The name of the domain configuration that was updated.</p>
    #[serde(rename = "domainConfigurationName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub domain_configuration_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateDynamicThingGroupRequest {
    /// <p>The expected version of the dynamic thing group to update.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p><p>The dynamic thing group index to update.</p> <note> <p>Currently one index is supported: &#39;AWS_Things&#39;.</p> </note></p>
    #[serde(rename = "indexName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_name: Option<String>,
    /// <p>The dynamic thing group search query string to update.</p>
    #[serde(rename = "queryString")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_string: Option<String>,
    /// <p><p>The dynamic thing group query version to update.</p> <note> <p>Currently one query version is supported: &quot;2017-09-30&quot;. If not specified, the query version defaults to this value.</p> </note></p>
    #[serde(rename = "queryVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_version: Option<String>,
    /// <p>The name of the dynamic thing group to update.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
    /// <p>The dynamic thing group properties to update.</p>
    #[serde(rename = "thingGroupProperties")]
    pub thing_group_properties: ThingGroupProperties,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateDynamicThingGroupResponse {
    /// <p>The dynamic thing group version.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateEventConfigurationsRequest {
    /// <p>The new event configuration values.</p>
    #[serde(rename = "eventConfigurations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event_configurations: Option<::std::collections::HashMap<String, Configuration>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateEventConfigurationsResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateIndexingConfigurationRequest {
    /// <p>Thing group indexing configuration.</p>
    #[serde(rename = "thingGroupIndexingConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_group_indexing_configuration: Option<ThingGroupIndexingConfiguration>,
    /// <p>Thing indexing configuration.</p>
    #[serde(rename = "thingIndexingConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_indexing_configuration: Option<ThingIndexingConfiguration>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateIndexingConfigurationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateJobRequest {
    /// <p>Allows you to create criteria to abort a job.</p>
    #[serde(rename = "abortConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub abort_config: Option<AbortConfig>,
    /// <p>A short text description of the job.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>Allows you to create a staged rollout of the job.</p>
    #[serde(rename = "jobExecutionsRolloutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub job_executions_rollout_config: Option<JobExecutionsRolloutConfig>,
    /// <p>The ID of the job to be updated.</p>
    #[serde(rename = "jobId")]
    pub job_id: String,
    /// <p>Configuration information for pre-signed S3 URLs.</p>
    #[serde(rename = "presignedUrlConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presigned_url_config: Option<PresignedUrlConfig>,
    /// <p>Specifies the amount of time each device has to finish its execution of the job. The timer is started when the job execution status is set to <code>IN_PROGRESS</code>. If the job execution status is not set to another terminal state before the time expires, it will be automatically set to <code>TIMED_OUT</code>. </p>
    #[serde(rename = "timeoutConfig")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout_config: Option<TimeoutConfig>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateMitigationActionRequest {
    /// <p>The friendly name for the mitigation action. You can't change the name by using <code>UpdateMitigationAction</code>. Instead, you must delete and re-create the mitigation action with the new name.</p>
    #[serde(rename = "actionName")]
    pub action_name: String,
    /// <p>Defines the type of action and the parameters for that action.</p>
    #[serde(rename = "actionParams")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_params: Option<MitigationActionParams>,
    /// <p>The ARN of the IAM role that is used to apply the mitigation action.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateMitigationActionResponse {
    /// <p>The ARN for the new mitigation action.</p>
    #[serde(rename = "actionArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_arn: Option<String>,
    /// <p>A unique identifier for the mitigation action.</p>
    #[serde(rename = "actionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_id: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateProvisioningTemplateRequest {
    /// <p>The ID of the default provisioning template version.</p>
    #[serde(rename = "defaultVersionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_version_id: Option<i64>,
    /// <p>The description of the fleet provisioning template.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>True to enable the fleet provisioning template, otherwise false.</p>
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// <p>The ARN of the role associated with the provisioning template. This IoT role grants permission to provision a device.</p>
    #[serde(rename = "provisioningRoleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub provisioning_role_arn: Option<String>,
    /// <p>The name of the fleet provisioning template.</p>
    #[serde(rename = "templateName")]
    pub template_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateProvisioningTemplateResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateRoleAliasRequest {
    /// <p>The number of seconds the credential will be valid.</p>
    #[serde(rename = "credentialDurationSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub credential_duration_seconds: Option<i64>,
    /// <p>The role alias to update.</p>
    #[serde(rename = "roleAlias")]
    pub role_alias: String,
    /// <p>The role ARN.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateRoleAliasResponse {
    /// <p>The role alias.</p>
    #[serde(rename = "roleAlias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias: Option<String>,
    /// <p>The role alias ARN.</p>
    #[serde(rename = "roleAliasArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_alias_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateScheduledAuditRequest {
    /// <p>The day of the month on which the scheduled audit takes place. Can be "1" through "31" or "LAST". This field is required if the "frequency" parameter is set to "MONTHLY". If days 29-31 are specified, and the month does not have that many days, the audit takes place on the "LAST" day of the month.</p>
    #[serde(rename = "dayOfMonth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_month: Option<String>,
    /// <p>The day of the week on which the scheduled audit takes place. Can be one of "SUN", "MON", "TUE", "WED", "THU", "FRI", or "SAT". This field is required if the "frequency" parameter is set to "WEEKLY" or "BIWEEKLY".</p>
    #[serde(rename = "dayOfWeek")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub day_of_week: Option<String>,
    /// <p>How often the scheduled audit takes place. Can be one of "DAILY", "WEEKLY", "BIWEEKLY", or "MONTHLY". The start time of each audit is determined by the system.</p>
    #[serde(rename = "frequency")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub frequency: Option<String>,
    /// <p>The name of the scheduled audit. (Max. 128 chars)</p>
    #[serde(rename = "scheduledAuditName")]
    pub scheduled_audit_name: String,
    /// <p>Which checks are performed during the scheduled audit. Checks must be enabled for your account. (Use <code>DescribeAccountAuditConfiguration</code> to see the list of all checks, including those that are enabled or use <code>UpdateAccountAuditConfiguration</code> to select which checks are enabled.)</p>
    #[serde(rename = "targetCheckNames")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_check_names: Option<Vec<String>>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateScheduledAuditResponse {
    /// <p>The ARN of the scheduled audit.</p>
    #[serde(rename = "scheduledAuditArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scheduled_audit_arn: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateSecurityProfileRequest {
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the profile's <code>behaviors</code>, but it is also retained for any metric specified here.</p>
    #[serde(rename = "additionalMetricsToRetain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_metrics_to_retain: Option<Vec<String>>,
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>If true, delete all <code>additionalMetricsToRetain</code> defined for this security profile. If any <code>additionalMetricsToRetain</code> are defined in the current invocation, an exception occurs.</p>
    #[serde(rename = "deleteAdditionalMetricsToRetain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_additional_metrics_to_retain: Option<bool>,
    /// <p>If true, delete all <code>alertTargets</code> defined for this security profile. If any <code>alertTargets</code> are defined in the current invocation, an exception occurs.</p>
    #[serde(rename = "deleteAlertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_alert_targets: Option<bool>,
    /// <p>If true, delete all <code>behaviors</code> defined for this security profile. If any <code>behaviors</code> are defined in the current invocation, an exception occurs.</p>
    #[serde(rename = "deleteBehaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_behaviors: Option<bool>,
    /// <p>The expected version of the security profile. A new version is generated whenever the security profile is updated. If you specify a value that is different from the actual version, a <code>VersionConflictException</code> is thrown.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>A description of the security profile.</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name of the security profile you want to update.</p>
    #[serde(rename = "securityProfileName")]
    pub security_profile_name: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateSecurityProfileResponse {
    /// <p>A list of metrics whose data is retained (stored). By default, data is retained for any metric used in the security profile's <code>behaviors</code>, but it is also retained for any metric specified here.</p>
    #[serde(rename = "additionalMetricsToRetain")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub additional_metrics_to_retain: Option<Vec<String>>,
    /// <p>Where the alerts are sent. (Alerts are always sent to the console.)</p>
    #[serde(rename = "alertTargets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alert_targets: Option<::std::collections::HashMap<String, AlertTarget>>,
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behaviors: Option<Vec<Behavior>>,
    /// <p>The time the security profile was created.</p>
    #[serde(rename = "creationDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_date: Option<f64>,
    /// <p>The time the security profile was last modified.</p>
    #[serde(rename = "lastModifiedDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified_date: Option<f64>,
    /// <p>The ARN of the security profile that was updated.</p>
    #[serde(rename = "securityProfileArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_arn: Option<String>,
    /// <p>The description of the security profile.</p>
    #[serde(rename = "securityProfileDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_description: Option<String>,
    /// <p>The name of the security profile that was updated.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The updated version of the security profile.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateStreamRequest {
    /// <p>The description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The files associated with the stream.</p>
    #[serde(rename = "files")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<StreamFile>>,
    /// <p>An IAM role that allows the IoT service principal assumes to access your S3 files.</p>
    #[serde(rename = "roleArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    pub stream_id: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateStreamResponse {
    /// <p>A description of the stream.</p>
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// <p>The stream ARN.</p>
    #[serde(rename = "streamArn")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_arn: Option<String>,
    /// <p>The stream ID.</p>
    #[serde(rename = "streamId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_id: Option<String>,
    /// <p>The stream version.</p>
    #[serde(rename = "streamVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stream_version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateThingGroupRequest {
    /// <p>The expected version of the thing group. If this does not match the version of the thing group being updated, the update will fail.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>The thing group to update.</p>
    #[serde(rename = "thingGroupName")]
    pub thing_group_name: String,
    /// <p>The thing group properties.</p>
    #[serde(rename = "thingGroupProperties")]
    pub thing_group_properties: ThingGroupProperties,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateThingGroupResponse {
    /// <p>The version of the updated thing group.</p>
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<i64>,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateThingGroupsForThingRequest {
    /// <p>Override dynamic thing groups with static thing groups when 10-group limit is reached. If a thing belongs to 10 thing groups, and one or more of those groups are dynamic thing groups, adding a thing to a static group removes the thing from the last dynamic group.</p>
    #[serde(rename = "overrideDynamicGroups")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub override_dynamic_groups: Option<bool>,
    /// <p>The groups to which the thing will be added.</p>
    #[serde(rename = "thingGroupsToAdd")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups_to_add: Option<Vec<String>>,
    /// <p>The groups from which the thing will be removed.</p>
    #[serde(rename = "thingGroupsToRemove")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_groups_to_remove: Option<Vec<String>>,
    /// <p>The thing whose group memberships will be updated.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateThingGroupsForThingResponse {}

/// <p>The input for the UpdateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateThingRequest {
    /// <p>A list of thing attributes, a JSON string containing name-value pairs. For example:</p> <p> <code>{\"attributes\":{\"name1\":\"value2\"}}</code> </p> <p>This data is used to add new attributes or update existing attributes.</p>
    #[serde(rename = "attributePayload")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attribute_payload: Option<AttributePayload>,
    /// <p>The expected version of the thing record in the registry. If the version of the record in the registry does not match the expected version specified in the request, the <code>UpdateThing</code> request is rejected with a <code>VersionConflictException</code>.</p>
    #[serde(rename = "expectedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_version: Option<i64>,
    /// <p>Remove a thing type association. If <b>true</b>, the association is removed.</p>
    #[serde(rename = "removeThingType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remove_thing_type: Option<bool>,
    /// <p>The name of the thing to update.</p>
    #[serde(rename = "thingName")]
    pub thing_name: String,
    /// <p>The name of the thing type.</p>
    #[serde(rename = "thingTypeName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_type_name: Option<String>,
}

/// <p>The output from the UpdateThing operation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateThingResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct UpdateTopicRuleDestinationRequest {
    /// <p>The ARN of the topic rule destination.</p>
    #[serde(rename = "arn")]
    pub arn: String,
    /// <p><p>The status of the topic rule destination. Valid values are:</p> <dl> <dt>IN<em>PROGRESS</dt> <dd> <p>A topic rule destination was created but has not been confirmed. You can set <code>status</code> to <code>IN</em>PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p> </dd> <dt>ENABLED</dt> <dd> <p>Confirmation was completed, and traffic to this destination is allowed. You can set <code>status</code> to <code>DISABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p> </dd> <dt>DISABLED</dt> <dd> <p>Confirmation was completed, and traffic to this destination is not allowed. You can set <code>status</code> to <code>ENABLED</code> by calling <code>UpdateTopicRuleDestination</code>.</p> </dd> <dt>ERROR</dt> <dd> <p>Confirmation could not be completed, for example if the confirmation timed out. You can call <code>GetTopicRuleDestination</code> for details about the error. You can set <code>status</code> to <code>IN_PROGRESS</code> by calling <code>UpdateTopicRuleDestination</code>. Calling <code>UpdateTopicRuleDestination</code> causes a new confirmation challenge to be sent to your confirmation endpoint.</p> </dd> </dl></p>
    #[serde(rename = "status")]
    pub status: String,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct UpdateTopicRuleDestinationResponse {}

#[derive(Default, Debug, Clone, PartialEq, Serialize)]
pub struct ValidateSecurityProfileBehaviorsRequest {
    /// <p>Specifies the behaviors that, when violated by a device (thing), cause an alert.</p>
    #[serde(rename = "behaviors")]
    pub behaviors: Vec<Behavior>,
}

#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ValidateSecurityProfileBehaviorsResponse {
    /// <p>True if the behaviors were valid.</p>
    #[serde(rename = "valid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub valid: Option<bool>,
    /// <p>The list of any errors found in the behaviors.</p>
    #[serde(rename = "validationErrors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validation_errors: Option<Vec<ValidationError>>,
}

/// <p>Information about an error found in a behavior specification.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ValidationError {
    /// <p>The description of an error found in the behaviors.</p>
    #[serde(rename = "errorMessage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
}

/// <p>Information about a Device Defender security profile behavior violation.</p>
#[derive(Default, Debug, Clone, PartialEq, Deserialize)]
#[cfg_attr(any(test, feature = "serialize_structs"), derive(Serialize))]
pub struct ViolationEvent {
    /// <p>The behavior which was violated.</p>
    #[serde(rename = "behavior")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub behavior: Option<Behavior>,
    /// <p>The value of the metric (the measurement).</p>
    #[serde(rename = "metricValue")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metric_value: Option<MetricValue>,
    /// <p>The name of the security profile whose behavior was violated.</p>
    #[serde(rename = "securityProfileName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub security_profile_name: Option<String>,
    /// <p>The name of the thing responsible for the violation event.</p>
    #[serde(rename = "thingName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thing_name: Option<String>,
    /// <p>The time the violation event occurred.</p>
    #[serde(rename = "violationEventTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_event_time: Option<f64>,
    /// <p>The type of violation event.</p>
    #[serde(rename = "violationEventType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_event_type: Option<String>,
    /// <p>The ID of the violation event.</p>
    #[serde(rename = "violationId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub violation_id: Option<String>,
}

/// Errors returned by AcceptCertificateTransfer
#[derive(Debug, PartialEq)]
pub enum AcceptCertificateTransferError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't revert the certificate transfer because the transfer is already complete.</p>
    TransferAlreadyCompleted(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl AcceptCertificateTransferError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AcceptCertificateTransferError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AcceptCertificateTransferError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AcceptCertificateTransferError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AcceptCertificateTransferError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        AcceptCertificateTransferError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AcceptCertificateTransferError::Throttling(
                        err.msg,
                    ))
                }
                "TransferAlreadyCompletedException" => {
                    return RusotoError::Service(
                        AcceptCertificateTransferError::TransferAlreadyCompleted(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(AcceptCertificateTransferError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AcceptCertificateTransferError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AcceptCertificateTransferError {
    fn description(&self) -> &str {
        match *self {
            AcceptCertificateTransferError::InternalFailure(ref cause) => cause,
            AcceptCertificateTransferError::InvalidRequest(ref cause) => cause,
            AcceptCertificateTransferError::ResourceNotFound(ref cause) => cause,
            AcceptCertificateTransferError::ServiceUnavailable(ref cause) => cause,
            AcceptCertificateTransferError::Throttling(ref cause) => cause,
            AcceptCertificateTransferError::TransferAlreadyCompleted(ref cause) => cause,
            AcceptCertificateTransferError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by AddThingToBillingGroup
#[derive(Debug, PartialEq)]
pub enum AddThingToBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl AddThingToBillingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AddThingToBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AddThingToBillingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AddThingToBillingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AddThingToBillingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AddThingToBillingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AddThingToBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AddThingToBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            AddThingToBillingGroupError::InternalFailure(ref cause) => cause,
            AddThingToBillingGroupError::InvalidRequest(ref cause) => cause,
            AddThingToBillingGroupError::ResourceNotFound(ref cause) => cause,
            AddThingToBillingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by AddThingToThingGroup
#[derive(Debug, PartialEq)]
pub enum AddThingToThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl AddThingToThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AddThingToThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AddThingToThingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AddThingToThingGroupError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AddThingToThingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AddThingToThingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AddThingToThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AddThingToThingGroupError {
    fn description(&self) -> &str {
        match *self {
            AddThingToThingGroupError::InternalFailure(ref cause) => cause,
            AddThingToThingGroupError::InvalidRequest(ref cause) => cause,
            AddThingToThingGroupError::ResourceNotFound(ref cause) => cause,
            AddThingToThingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by AssociateTargetsWithJob
#[derive(Debug, PartialEq)]
pub enum AssociateTargetsWithJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl AssociateTargetsWithJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AssociateTargetsWithJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(AssociateTargetsWithJobError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(AssociateTargetsWithJobError::LimitExceeded(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AssociateTargetsWithJobError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(AssociateTargetsWithJobError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AssociateTargetsWithJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AssociateTargetsWithJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AssociateTargetsWithJobError {
    fn description(&self) -> &str {
        match *self {
            AssociateTargetsWithJobError::InvalidRequest(ref cause) => cause,
            AssociateTargetsWithJobError::LimitExceeded(ref cause) => cause,
            AssociateTargetsWithJobError::ResourceNotFound(ref cause) => cause,
            AssociateTargetsWithJobError::ServiceUnavailable(ref cause) => cause,
            AssociateTargetsWithJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by AttachPolicy
#[derive(Debug, PartialEq)]
pub enum AttachPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl AttachPolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AttachPolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AttachPolicyError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AttachPolicyError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(AttachPolicyError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AttachPolicyError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(AttachPolicyError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AttachPolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(AttachPolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AttachPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachPolicyError {
    fn description(&self) -> &str {
        match *self {
            AttachPolicyError::InternalFailure(ref cause) => cause,
            AttachPolicyError::InvalidRequest(ref cause) => cause,
            AttachPolicyError::LimitExceeded(ref cause) => cause,
            AttachPolicyError::ResourceNotFound(ref cause) => cause,
            AttachPolicyError::ServiceUnavailable(ref cause) => cause,
            AttachPolicyError::Throttling(ref cause) => cause,
            AttachPolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by AttachPrincipalPolicy
#[derive(Debug, PartialEq)]
pub enum AttachPrincipalPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl AttachPrincipalPolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AttachPrincipalPolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(AttachPrincipalPolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AttachPrincipalPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachPrincipalPolicyError {
    fn description(&self) -> &str {
        match *self {
            AttachPrincipalPolicyError::InternalFailure(ref cause) => cause,
            AttachPrincipalPolicyError::InvalidRequest(ref cause) => cause,
            AttachPrincipalPolicyError::LimitExceeded(ref cause) => cause,
            AttachPrincipalPolicyError::ResourceNotFound(ref cause) => cause,
            AttachPrincipalPolicyError::ServiceUnavailable(ref cause) => cause,
            AttachPrincipalPolicyError::Throttling(ref cause) => cause,
            AttachPrincipalPolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by AttachSecurityProfile
#[derive(Debug, PartialEq)]
pub enum AttachSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl AttachSecurityProfileError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AttachSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AttachSecurityProfileError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AttachSecurityProfileError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(AttachSecurityProfileError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AttachSecurityProfileError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AttachSecurityProfileError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(AttachSecurityProfileError::VersionConflict(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AttachSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            AttachSecurityProfileError::InternalFailure(ref cause) => cause,
            AttachSecurityProfileError::InvalidRequest(ref cause) => cause,
            AttachSecurityProfileError::LimitExceeded(ref cause) => cause,
            AttachSecurityProfileError::ResourceNotFound(ref cause) => cause,
            AttachSecurityProfileError::Throttling(ref cause) => cause,
            AttachSecurityProfileError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by AttachThingPrincipal
#[derive(Debug, PartialEq)]
pub enum AttachThingPrincipalError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl AttachThingPrincipalError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<AttachThingPrincipalError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(AttachThingPrincipalError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(AttachThingPrincipalError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(AttachThingPrincipalError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(AttachThingPrincipalError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(AttachThingPrincipalError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(AttachThingPrincipalError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for AttachThingPrincipalError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for AttachThingPrincipalError {
    fn description(&self) -> &str {
        match *self {
            AttachThingPrincipalError::InternalFailure(ref cause) => cause,
            AttachThingPrincipalError::InvalidRequest(ref cause) => cause,
            AttachThingPrincipalError::ResourceNotFound(ref cause) => cause,
            AttachThingPrincipalError::ServiceUnavailable(ref cause) => cause,
            AttachThingPrincipalError::Throttling(ref cause) => cause,
            AttachThingPrincipalError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CancelAuditMitigationActionsTask
#[derive(Debug, PartialEq)]
pub enum CancelAuditMitigationActionsTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CancelAuditMitigationActionsTaskError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<CancelAuditMitigationActionsTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        CancelAuditMitigationActionsTaskError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        CancelAuditMitigationActionsTaskError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        CancelAuditMitigationActionsTaskError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CancelAuditMitigationActionsTaskError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CancelAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelAuditMitigationActionsTaskError {
    fn description(&self) -> &str {
        match *self {
            CancelAuditMitigationActionsTaskError::InternalFailure(ref cause) => cause,
            CancelAuditMitigationActionsTaskError::InvalidRequest(ref cause) => cause,
            CancelAuditMitigationActionsTaskError::ResourceNotFound(ref cause) => cause,
            CancelAuditMitigationActionsTaskError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CancelAuditTask
#[derive(Debug, PartialEq)]
pub enum CancelAuditTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CancelAuditTaskError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CancelAuditTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CancelAuditTaskError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CancelAuditTaskError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CancelAuditTaskError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CancelAuditTaskError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CancelAuditTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelAuditTaskError {
    fn description(&self) -> &str {
        match *self {
            CancelAuditTaskError::InternalFailure(ref cause) => cause,
            CancelAuditTaskError::InvalidRequest(ref cause) => cause,
            CancelAuditTaskError::ResourceNotFound(ref cause) => cause,
            CancelAuditTaskError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CancelCertificateTransfer
#[derive(Debug, PartialEq)]
pub enum CancelCertificateTransferError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't revert the certificate transfer because the transfer is already complete.</p>
    TransferAlreadyCompleted(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CancelCertificateTransferError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CancelCertificateTransferError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CancelCertificateTransferError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CancelCertificateTransferError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CancelCertificateTransferError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        CancelCertificateTransferError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CancelCertificateTransferError::Throttling(
                        err.msg,
                    ))
                }
                "TransferAlreadyCompletedException" => {
                    return RusotoError::Service(
                        CancelCertificateTransferError::TransferAlreadyCompleted(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CancelCertificateTransferError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CancelCertificateTransferError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelCertificateTransferError {
    fn description(&self) -> &str {
        match *self {
            CancelCertificateTransferError::InternalFailure(ref cause) => cause,
            CancelCertificateTransferError::InvalidRequest(ref cause) => cause,
            CancelCertificateTransferError::ResourceNotFound(ref cause) => cause,
            CancelCertificateTransferError::ServiceUnavailable(ref cause) => cause,
            CancelCertificateTransferError::Throttling(ref cause) => cause,
            CancelCertificateTransferError::TransferAlreadyCompleted(ref cause) => cause,
            CancelCertificateTransferError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CancelJob
#[derive(Debug, PartialEq)]
pub enum CancelJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CancelJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CancelJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(CancelJobError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CancelJobError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CancelJobError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CancelJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CancelJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelJobError {
    fn description(&self) -> &str {
        match *self {
            CancelJobError::InvalidRequest(ref cause) => cause,
            CancelJobError::ResourceNotFound(ref cause) => cause,
            CancelJobError::ServiceUnavailable(ref cause) => cause,
            CancelJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CancelJobExecution
#[derive(Debug, PartialEq)]
pub enum CancelJobExecutionError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the <code>force</code> parameter.</p>
    InvalidStateTransition(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl CancelJobExecutionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CancelJobExecutionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(CancelJobExecutionError::InvalidRequest(err.msg))
                }
                "InvalidStateTransitionException" => {
                    return RusotoError::Service(CancelJobExecutionError::InvalidStateTransition(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CancelJobExecutionError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CancelJobExecutionError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CancelJobExecutionError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(CancelJobExecutionError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CancelJobExecutionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CancelJobExecutionError {
    fn description(&self) -> &str {
        match *self {
            CancelJobExecutionError::InvalidRequest(ref cause) => cause,
            CancelJobExecutionError::InvalidStateTransition(ref cause) => cause,
            CancelJobExecutionError::ResourceNotFound(ref cause) => cause,
            CancelJobExecutionError::ServiceUnavailable(ref cause) => cause,
            CancelJobExecutionError::Throttling(ref cause) => cause,
            CancelJobExecutionError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by ClearDefaultAuthorizer
#[derive(Debug, PartialEq)]
pub enum ClearDefaultAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ClearDefaultAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ClearDefaultAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ClearDefaultAuthorizerError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ClearDefaultAuthorizerError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ClearDefaultAuthorizerError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ClearDefaultAuthorizerError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ClearDefaultAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ClearDefaultAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ClearDefaultAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ClearDefaultAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            ClearDefaultAuthorizerError::InternalFailure(ref cause) => cause,
            ClearDefaultAuthorizerError::InvalidRequest(ref cause) => cause,
            ClearDefaultAuthorizerError::ResourceNotFound(ref cause) => cause,
            ClearDefaultAuthorizerError::ServiceUnavailable(ref cause) => cause,
            ClearDefaultAuthorizerError::Throttling(ref cause) => cause,
            ClearDefaultAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ConfirmTopicRuleDestination
#[derive(Debug, PartialEq)]
pub enum ConfirmTopicRuleDestinationError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ConfirmTopicRuleDestinationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ConfirmTopicRuleDestinationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(
                        ConfirmTopicRuleDestinationError::ConflictingResourceUpdate(err.msg),
                    )
                }
                "InternalException" => {
                    return RusotoError::Service(ConfirmTopicRuleDestinationError::Internal(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ConfirmTopicRuleDestinationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        ConfirmTopicRuleDestinationError::ServiceUnavailable(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ConfirmTopicRuleDestinationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ConfirmTopicRuleDestinationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ConfirmTopicRuleDestinationError {
    fn description(&self) -> &str {
        match *self {
            ConfirmTopicRuleDestinationError::ConflictingResourceUpdate(ref cause) => cause,
            ConfirmTopicRuleDestinationError::Internal(ref cause) => cause,
            ConfirmTopicRuleDestinationError::InvalidRequest(ref cause) => cause,
            ConfirmTopicRuleDestinationError::ServiceUnavailable(ref cause) => cause,
            ConfirmTopicRuleDestinationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateAuthorizer
#[derive(Debug, PartialEq)]
pub enum CreateAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateAuthorizerError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateAuthorizerError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateAuthorizerError::LimitExceeded(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateAuthorizerError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateAuthorizerError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            CreateAuthorizerError::InternalFailure(ref cause) => cause,
            CreateAuthorizerError::InvalidRequest(ref cause) => cause,
            CreateAuthorizerError::LimitExceeded(ref cause) => cause,
            CreateAuthorizerError::ResourceAlreadyExists(ref cause) => cause,
            CreateAuthorizerError::ServiceUnavailable(ref cause) => cause,
            CreateAuthorizerError::Throttling(ref cause) => cause,
            CreateAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateBillingGroup
#[derive(Debug, PartialEq)]
pub enum CreateBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateBillingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateBillingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateBillingGroupError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateBillingGroupError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateBillingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            CreateBillingGroupError::InternalFailure(ref cause) => cause,
            CreateBillingGroupError::InvalidRequest(ref cause) => cause,
            CreateBillingGroupError::ResourceAlreadyExists(ref cause) => cause,
            CreateBillingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateCertificateFromCsr
#[derive(Debug, PartialEq)]
pub enum CreateCertificateFromCsrError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateCertificateFromCsrError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateCertificateFromCsrError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateCertificateFromCsrError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateCertificateFromCsrError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateCertificateFromCsrError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateCertificateFromCsrError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateCertificateFromCsrError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateCertificateFromCsrError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateCertificateFromCsrError {
    fn description(&self) -> &str {
        match *self {
            CreateCertificateFromCsrError::InternalFailure(ref cause) => cause,
            CreateCertificateFromCsrError::InvalidRequest(ref cause) => cause,
            CreateCertificateFromCsrError::ServiceUnavailable(ref cause) => cause,
            CreateCertificateFromCsrError::Throttling(ref cause) => cause,
            CreateCertificateFromCsrError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateDomainConfiguration
#[derive(Debug, PartialEq)]
pub enum CreateDomainConfigurationError {
    /// <p>The certificate is invalid.</p>
    CertificateValidation(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateDomainConfigurationError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateDomainConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateValidationException" => {
                    return RusotoError::Service(
                        CreateDomainConfigurationError::CertificateValidation(err.msg),
                    )
                }
                "InternalFailureException" => {
                    return RusotoError::Service(CreateDomainConfigurationError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateDomainConfigurationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateDomainConfigurationError::LimitExceeded(
                        err.msg,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(
                        CreateDomainConfigurationError::ResourceAlreadyExists(err.msg),
                    )
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        CreateDomainConfigurationError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateDomainConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateDomainConfigurationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateDomainConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateDomainConfigurationError {
    fn description(&self) -> &str {
        match *self {
            CreateDomainConfigurationError::CertificateValidation(ref cause) => cause,
            CreateDomainConfigurationError::InternalFailure(ref cause) => cause,
            CreateDomainConfigurationError::InvalidRequest(ref cause) => cause,
            CreateDomainConfigurationError::LimitExceeded(ref cause) => cause,
            CreateDomainConfigurationError::ResourceAlreadyExists(ref cause) => cause,
            CreateDomainConfigurationError::ServiceUnavailable(ref cause) => cause,
            CreateDomainConfigurationError::Throttling(ref cause) => cause,
            CreateDomainConfigurationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateDynamicThingGroup
#[derive(Debug, PartialEq)]
pub enum CreateDynamicThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateDynamicThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateDynamicThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateDynamicThingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidQueryException" => {
                    return RusotoError::Service(CreateDynamicThingGroupError::InvalidQuery(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateDynamicThingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateDynamicThingGroupError::LimitExceeded(
                        err.msg,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(
                        CreateDynamicThingGroupError::ResourceAlreadyExists(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreateDynamicThingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateDynamicThingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateDynamicThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateDynamicThingGroupError {
    fn description(&self) -> &str {
        match *self {
            CreateDynamicThingGroupError::InternalFailure(ref cause) => cause,
            CreateDynamicThingGroupError::InvalidQuery(ref cause) => cause,
            CreateDynamicThingGroupError::InvalidRequest(ref cause) => cause,
            CreateDynamicThingGroupError::LimitExceeded(ref cause) => cause,
            CreateDynamicThingGroupError::ResourceAlreadyExists(ref cause) => cause,
            CreateDynamicThingGroupError::ResourceNotFound(ref cause) => cause,
            CreateDynamicThingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateJob
#[derive(Debug, PartialEq)]
pub enum CreateJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateJobError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateJobError::LimitExceeded(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateJobError::ResourceAlreadyExists(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreateJobError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateJobError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateJobError {
    fn description(&self) -> &str {
        match *self {
            CreateJobError::InvalidRequest(ref cause) => cause,
            CreateJobError::LimitExceeded(ref cause) => cause,
            CreateJobError::ResourceAlreadyExists(ref cause) => cause,
            CreateJobError::ResourceNotFound(ref cause) => cause,
            CreateJobError::ServiceUnavailable(ref cause) => cause,
            CreateJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateKeysAndCertificate
#[derive(Debug, PartialEq)]
pub enum CreateKeysAndCertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateKeysAndCertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateKeysAndCertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateKeysAndCertificateError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateKeysAndCertificateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateKeysAndCertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateKeysAndCertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateKeysAndCertificateError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateKeysAndCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateKeysAndCertificateError {
    fn description(&self) -> &str {
        match *self {
            CreateKeysAndCertificateError::InternalFailure(ref cause) => cause,
            CreateKeysAndCertificateError::InvalidRequest(ref cause) => cause,
            CreateKeysAndCertificateError::ServiceUnavailable(ref cause) => cause,
            CreateKeysAndCertificateError::Throttling(ref cause) => cause,
            CreateKeysAndCertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateMitigationAction
#[derive(Debug, PartialEq)]
pub enum CreateMitigationActionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateMitigationActionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateMitigationActionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateMitigationActionError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateMitigationActionError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateMitigationActionError::LimitExceeded(
                        err.msg,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(
                        CreateMitigationActionError::ResourceAlreadyExists(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateMitigationActionError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateMitigationActionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateMitigationActionError {
    fn description(&self) -> &str {
        match *self {
            CreateMitigationActionError::InternalFailure(ref cause) => cause,
            CreateMitigationActionError::InvalidRequest(ref cause) => cause,
            CreateMitigationActionError::LimitExceeded(ref cause) => cause,
            CreateMitigationActionError::ResourceAlreadyExists(ref cause) => cause,
            CreateMitigationActionError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateOTAUpdate
#[derive(Debug, PartialEq)]
pub enum CreateOTAUpdateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateOTAUpdateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateOTAUpdateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateOTAUpdateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateOTAUpdateError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateOTAUpdateError::LimitExceeded(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateOTAUpdateError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreateOTAUpdateError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateOTAUpdateError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateOTAUpdateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateOTAUpdateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateOTAUpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateOTAUpdateError {
    fn description(&self) -> &str {
        match *self {
            CreateOTAUpdateError::InternalFailure(ref cause) => cause,
            CreateOTAUpdateError::InvalidRequest(ref cause) => cause,
            CreateOTAUpdateError::LimitExceeded(ref cause) => cause,
            CreateOTAUpdateError::ResourceAlreadyExists(ref cause) => cause,
            CreateOTAUpdateError::ResourceNotFound(ref cause) => cause,
            CreateOTAUpdateError::ServiceUnavailable(ref cause) => cause,
            CreateOTAUpdateError::Throttling(ref cause) => cause,
            CreateOTAUpdateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreatePolicy
#[derive(Debug, PartialEq)]
pub enum CreatePolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The policy documentation is not valid.</p>
    MalformedPolicy(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreatePolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreatePolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreatePolicyError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreatePolicyError::InvalidRequest(err.msg))
                }
                "MalformedPolicyException" => {
                    return RusotoError::Service(CreatePolicyError::MalformedPolicy(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreatePolicyError::ResourceAlreadyExists(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreatePolicyError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreatePolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreatePolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreatePolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreatePolicyError {
    fn description(&self) -> &str {
        match *self {
            CreatePolicyError::InternalFailure(ref cause) => cause,
            CreatePolicyError::InvalidRequest(ref cause) => cause,
            CreatePolicyError::MalformedPolicy(ref cause) => cause,
            CreatePolicyError::ResourceAlreadyExists(ref cause) => cause,
            CreatePolicyError::ServiceUnavailable(ref cause) => cause,
            CreatePolicyError::Throttling(ref cause) => cause,
            CreatePolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreatePolicyVersion
#[derive(Debug, PartialEq)]
pub enum CreatePolicyVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The policy documentation is not valid.</p>
    MalformedPolicy(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>The number of policy versions exceeds the limit.</p>
    VersionsLimitExceeded(String),
}

impl CreatePolicyVersionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreatePolicyVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreatePolicyVersionError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreatePolicyVersionError::InvalidRequest(err.msg))
                }
                "MalformedPolicyException" => {
                    return RusotoError::Service(CreatePolicyVersionError::MalformedPolicy(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreatePolicyVersionError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreatePolicyVersionError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreatePolicyVersionError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreatePolicyVersionError::Unauthorized(err.msg))
                }
                "VersionsLimitExceededException" => {
                    return RusotoError::Service(CreatePolicyVersionError::VersionsLimitExceeded(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreatePolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreatePolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            CreatePolicyVersionError::InternalFailure(ref cause) => cause,
            CreatePolicyVersionError::InvalidRequest(ref cause) => cause,
            CreatePolicyVersionError::MalformedPolicy(ref cause) => cause,
            CreatePolicyVersionError::ResourceNotFound(ref cause) => cause,
            CreatePolicyVersionError::ServiceUnavailable(ref cause) => cause,
            CreatePolicyVersionError::Throttling(ref cause) => cause,
            CreatePolicyVersionError::Unauthorized(ref cause) => cause,
            CreatePolicyVersionError::VersionsLimitExceeded(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateProvisioningClaim
#[derive(Debug, PartialEq)]
pub enum CreateProvisioningClaimError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateProvisioningClaimError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateProvisioningClaimError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateProvisioningClaimError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateProvisioningClaimError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreateProvisioningClaimError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateProvisioningClaimError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateProvisioningClaimError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateProvisioningClaimError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateProvisioningClaimError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateProvisioningClaimError {
    fn description(&self) -> &str {
        match *self {
            CreateProvisioningClaimError::InternalFailure(ref cause) => cause,
            CreateProvisioningClaimError::InvalidRequest(ref cause) => cause,
            CreateProvisioningClaimError::ResourceNotFound(ref cause) => cause,
            CreateProvisioningClaimError::ServiceUnavailable(ref cause) => cause,
            CreateProvisioningClaimError::Throttling(ref cause) => cause,
            CreateProvisioningClaimError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateProvisioningTemplate
#[derive(Debug, PartialEq)]
pub enum CreateProvisioningTemplateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateProvisioningTemplateError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<CreateProvisioningTemplateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateProvisioningTemplateError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateProvisioningTemplateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateProvisioningTemplateError::LimitExceeded(
                        err.msg,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateError::ResourceAlreadyExists(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateProvisioningTemplateError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateProvisioningTemplateError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateProvisioningTemplateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateProvisioningTemplateError {
    fn description(&self) -> &str {
        match *self {
            CreateProvisioningTemplateError::InternalFailure(ref cause) => cause,
            CreateProvisioningTemplateError::InvalidRequest(ref cause) => cause,
            CreateProvisioningTemplateError::LimitExceeded(ref cause) => cause,
            CreateProvisioningTemplateError::ResourceAlreadyExists(ref cause) => cause,
            CreateProvisioningTemplateError::Throttling(ref cause) => cause,
            CreateProvisioningTemplateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateProvisioningTemplateVersion
#[derive(Debug, PartialEq)]
pub enum CreateProvisioningTemplateVersionError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>The number of policy versions exceeds the limit.</p>
    VersionsLimitExceeded(String),
}

impl CreateProvisioningTemplateVersionError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<CreateProvisioningTemplateVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::ConflictingResourceUpdate(err.msg),
                    )
                }
                "InternalFailureException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::Throttling(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::Unauthorized(err.msg),
                    )
                }
                "VersionsLimitExceededException" => {
                    return RusotoError::Service(
                        CreateProvisioningTemplateVersionError::VersionsLimitExceeded(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateProvisioningTemplateVersionError {
    fn description(&self) -> &str {
        match *self {
            CreateProvisioningTemplateVersionError::ConflictingResourceUpdate(ref cause) => cause,
            CreateProvisioningTemplateVersionError::InternalFailure(ref cause) => cause,
            CreateProvisioningTemplateVersionError::InvalidRequest(ref cause) => cause,
            CreateProvisioningTemplateVersionError::ResourceNotFound(ref cause) => cause,
            CreateProvisioningTemplateVersionError::Throttling(ref cause) => cause,
            CreateProvisioningTemplateVersionError::Unauthorized(ref cause) => cause,
            CreateProvisioningTemplateVersionError::VersionsLimitExceeded(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateRoleAlias
#[derive(Debug, PartialEq)]
pub enum CreateRoleAliasError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateRoleAliasError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateRoleAliasError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateRoleAliasError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateRoleAliasError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateRoleAliasError::LimitExceeded(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateRoleAliasError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateRoleAliasError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateRoleAliasError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateRoleAliasError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            CreateRoleAliasError::InternalFailure(ref cause) => cause,
            CreateRoleAliasError::InvalidRequest(ref cause) => cause,
            CreateRoleAliasError::LimitExceeded(ref cause) => cause,
            CreateRoleAliasError::ResourceAlreadyExists(ref cause) => cause,
            CreateRoleAliasError::ServiceUnavailable(ref cause) => cause,
            CreateRoleAliasError::Throttling(ref cause) => cause,
            CreateRoleAliasError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateScheduledAudit
#[derive(Debug, PartialEq)]
pub enum CreateScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateScheduledAuditError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateScheduledAuditError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateScheduledAuditError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateScheduledAuditError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateScheduledAuditError::LimitExceeded(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateScheduledAuditError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateScheduledAuditError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            CreateScheduledAuditError::InternalFailure(ref cause) => cause,
            CreateScheduledAuditError::InvalidRequest(ref cause) => cause,
            CreateScheduledAuditError::LimitExceeded(ref cause) => cause,
            CreateScheduledAuditError::ResourceAlreadyExists(ref cause) => cause,
            CreateScheduledAuditError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateSecurityProfile
#[derive(Debug, PartialEq)]
pub enum CreateSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateSecurityProfileError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateSecurityProfileError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateSecurityProfileError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateSecurityProfileError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateSecurityProfileError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            CreateSecurityProfileError::InternalFailure(ref cause) => cause,
            CreateSecurityProfileError::InvalidRequest(ref cause) => cause,
            CreateSecurityProfileError::ResourceAlreadyExists(ref cause) => cause,
            CreateSecurityProfileError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateStream
#[derive(Debug, PartialEq)]
pub enum CreateStreamError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateStreamError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateStreamError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateStreamError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateStreamError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(CreateStreamError::LimitExceeded(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateStreamError::ResourceAlreadyExists(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreateStreamError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateStreamError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateStreamError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateStreamError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateStreamError {
    fn description(&self) -> &str {
        match *self {
            CreateStreamError::InternalFailure(ref cause) => cause,
            CreateStreamError::InvalidRequest(ref cause) => cause,
            CreateStreamError::LimitExceeded(ref cause) => cause,
            CreateStreamError::ResourceAlreadyExists(ref cause) => cause,
            CreateStreamError::ResourceNotFound(ref cause) => cause,
            CreateStreamError::ServiceUnavailable(ref cause) => cause,
            CreateStreamError::Throttling(ref cause) => cause,
            CreateStreamError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateThing
#[derive(Debug, PartialEq)]
pub enum CreateThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateThingError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateThingError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateThingError::ResourceAlreadyExists(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(CreateThingError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateThingError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateThingError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateThingError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateThingError {
    fn description(&self) -> &str {
        match *self {
            CreateThingError::InternalFailure(ref cause) => cause,
            CreateThingError::InvalidRequest(ref cause) => cause,
            CreateThingError::ResourceAlreadyExists(ref cause) => cause,
            CreateThingError::ResourceNotFound(ref cause) => cause,
            CreateThingError::ServiceUnavailable(ref cause) => cause,
            CreateThingError::Throttling(ref cause) => cause,
            CreateThingError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateThingGroup
#[derive(Debug, PartialEq)]
pub enum CreateThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl CreateThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateThingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateThingGroupError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateThingGroupError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateThingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateThingGroupError {
    fn description(&self) -> &str {
        match *self {
            CreateThingGroupError::InternalFailure(ref cause) => cause,
            CreateThingGroupError::InvalidRequest(ref cause) => cause,
            CreateThingGroupError::ResourceAlreadyExists(ref cause) => cause,
            CreateThingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateThingType
#[derive(Debug, PartialEq)]
pub enum CreateThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl CreateThingTypeError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateThingTypeError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(CreateThingTypeError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateThingTypeError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateThingTypeError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateThingTypeError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(CreateThingTypeError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(CreateThingTypeError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateThingTypeError {
    fn description(&self) -> &str {
        match *self {
            CreateThingTypeError::InternalFailure(ref cause) => cause,
            CreateThingTypeError::InvalidRequest(ref cause) => cause,
            CreateThingTypeError::ResourceAlreadyExists(ref cause) => cause,
            CreateThingTypeError::ServiceUnavailable(ref cause) => cause,
            CreateThingTypeError::Throttling(ref cause) => cause,
            CreateThingTypeError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateTopicRule
#[derive(Debug, PartialEq)]
pub enum CreateTopicRuleError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The Rule-SQL expression can't be parsed correctly.</p>
    SqlParse(String),
}

impl CreateTopicRuleError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<CreateTopicRuleError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(CreateTopicRuleError::ConflictingResourceUpdate(
                        err.msg,
                    ))
                }
                "InternalException" => {
                    return RusotoError::Service(CreateTopicRuleError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateTopicRuleError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(CreateTopicRuleError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(CreateTopicRuleError::ServiceUnavailable(err.msg))
                }
                "SqlParseException" => {
                    return RusotoError::Service(CreateTopicRuleError::SqlParse(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            CreateTopicRuleError::ConflictingResourceUpdate(ref cause) => cause,
            CreateTopicRuleError::Internal(ref cause) => cause,
            CreateTopicRuleError::InvalidRequest(ref cause) => cause,
            CreateTopicRuleError::ResourceAlreadyExists(ref cause) => cause,
            CreateTopicRuleError::ServiceUnavailable(ref cause) => cause,
            CreateTopicRuleError::SqlParse(ref cause) => cause,
        }
    }
}
/// Errors returned by CreateTopicRuleDestination
#[derive(Debug, PartialEq)]
pub enum CreateTopicRuleDestinationError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl CreateTopicRuleDestinationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<CreateTopicRuleDestinationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(
                        CreateTopicRuleDestinationError::ConflictingResourceUpdate(err.msg),
                    )
                }
                "InternalException" => {
                    return RusotoError::Service(CreateTopicRuleDestinationError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(CreateTopicRuleDestinationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(
                        CreateTopicRuleDestinationError::ResourceAlreadyExists(err.msg),
                    )
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        CreateTopicRuleDestinationError::ServiceUnavailable(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for CreateTopicRuleDestinationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for CreateTopicRuleDestinationError {
    fn description(&self) -> &str {
        match *self {
            CreateTopicRuleDestinationError::ConflictingResourceUpdate(ref cause) => cause,
            CreateTopicRuleDestinationError::Internal(ref cause) => cause,
            CreateTopicRuleDestinationError::InvalidRequest(ref cause) => cause,
            CreateTopicRuleDestinationError::ResourceAlreadyExists(ref cause) => cause,
            CreateTopicRuleDestinationError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteAccountAuditConfiguration
#[derive(Debug, PartialEq)]
pub enum DeleteAccountAuditConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DeleteAccountAuditConfigurationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DeleteAccountAuditConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DeleteAccountAuditConfigurationError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        DeleteAccountAuditConfigurationError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DeleteAccountAuditConfigurationError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteAccountAuditConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteAccountAuditConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteAccountAuditConfigurationError {
    fn description(&self) -> &str {
        match *self {
            DeleteAccountAuditConfigurationError::InternalFailure(ref cause) => cause,
            DeleteAccountAuditConfigurationError::InvalidRequest(ref cause) => cause,
            DeleteAccountAuditConfigurationError::ResourceNotFound(ref cause) => cause,
            DeleteAccountAuditConfigurationError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteAuthorizer
#[derive(Debug, PartialEq)]
pub enum DeleteAuthorizerError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(DeleteAuthorizerError::DeleteConflict(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteAuthorizerError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteAuthorizerError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteAuthorizerError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteAuthorizerError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            DeleteAuthorizerError::DeleteConflict(ref cause) => cause,
            DeleteAuthorizerError::InternalFailure(ref cause) => cause,
            DeleteAuthorizerError::InvalidRequest(ref cause) => cause,
            DeleteAuthorizerError::ResourceNotFound(ref cause) => cause,
            DeleteAuthorizerError::ServiceUnavailable(ref cause) => cause,
            DeleteAuthorizerError::Throttling(ref cause) => cause,
            DeleteAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteBillingGroup
#[derive(Debug, PartialEq)]
pub enum DeleteBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl DeleteBillingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteBillingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteBillingGroupError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteBillingGroupError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(DeleteBillingGroupError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            DeleteBillingGroupError::InternalFailure(ref cause) => cause,
            DeleteBillingGroupError::InvalidRequest(ref cause) => cause,
            DeleteBillingGroupError::Throttling(ref cause) => cause,
            DeleteBillingGroupError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteCACertificate
#[derive(Debug, PartialEq)]
pub enum DeleteCACertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteCACertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteCACertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateStateException" => {
                    return RusotoError::Service(DeleteCACertificateError::CertificateState(
                        err.msg,
                    ))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteCACertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteCACertificateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteCACertificateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteCACertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteCACertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteCACertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteCACertificateError {
    fn description(&self) -> &str {
        match *self {
            DeleteCACertificateError::CertificateState(ref cause) => cause,
            DeleteCACertificateError::InternalFailure(ref cause) => cause,
            DeleteCACertificateError::InvalidRequest(ref cause) => cause,
            DeleteCACertificateError::ResourceNotFound(ref cause) => cause,
            DeleteCACertificateError::ServiceUnavailable(ref cause) => cause,
            DeleteCACertificateError::Throttling(ref cause) => cause,
            DeleteCACertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteCertificate
#[derive(Debug, PartialEq)]
pub enum DeleteCertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteCertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteCertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateStateException" => {
                    return RusotoError::Service(DeleteCertificateError::CertificateState(err.msg))
                }
                "DeleteConflictException" => {
                    return RusotoError::Service(DeleteCertificateError::DeleteConflict(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteCertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteCertificateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteCertificateError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteCertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteCertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteCertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteCertificateError {
    fn description(&self) -> &str {
        match *self {
            DeleteCertificateError::CertificateState(ref cause) => cause,
            DeleteCertificateError::DeleteConflict(ref cause) => cause,
            DeleteCertificateError::InternalFailure(ref cause) => cause,
            DeleteCertificateError::InvalidRequest(ref cause) => cause,
            DeleteCertificateError::ResourceNotFound(ref cause) => cause,
            DeleteCertificateError::ServiceUnavailable(ref cause) => cause,
            DeleteCertificateError::Throttling(ref cause) => cause,
            DeleteCertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteDomainConfiguration
#[derive(Debug, PartialEq)]
pub enum DeleteDomainConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteDomainConfigurationError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteDomainConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteDomainConfigurationError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteDomainConfigurationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteDomainConfigurationError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        DeleteDomainConfigurationError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteDomainConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteDomainConfigurationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteDomainConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteDomainConfigurationError {
    fn description(&self) -> &str {
        match *self {
            DeleteDomainConfigurationError::InternalFailure(ref cause) => cause,
            DeleteDomainConfigurationError::InvalidRequest(ref cause) => cause,
            DeleteDomainConfigurationError::ResourceNotFound(ref cause) => cause,
            DeleteDomainConfigurationError::ServiceUnavailable(ref cause) => cause,
            DeleteDomainConfigurationError::Throttling(ref cause) => cause,
            DeleteDomainConfigurationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteDynamicThingGroup
#[derive(Debug, PartialEq)]
pub enum DeleteDynamicThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl DeleteDynamicThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteDynamicThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteDynamicThingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteDynamicThingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteDynamicThingGroupError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(DeleteDynamicThingGroupError::VersionConflict(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteDynamicThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteDynamicThingGroupError {
    fn description(&self) -> &str {
        match *self {
            DeleteDynamicThingGroupError::InternalFailure(ref cause) => cause,
            DeleteDynamicThingGroupError::InvalidRequest(ref cause) => cause,
            DeleteDynamicThingGroupError::Throttling(ref cause) => cause,
            DeleteDynamicThingGroupError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteJob
#[derive(Debug, PartialEq)]
pub enum DeleteJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the <code>force</code> parameter.</p>
    InvalidStateTransition(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DeleteJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteJobError::InvalidRequest(err.msg))
                }
                "InvalidStateTransitionException" => {
                    return RusotoError::Service(DeleteJobError::InvalidStateTransition(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(DeleteJobError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteJobError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteJobError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteJobError {
    fn description(&self) -> &str {
        match *self {
            DeleteJobError::InvalidRequest(ref cause) => cause,
            DeleteJobError::InvalidStateTransition(ref cause) => cause,
            DeleteJobError::LimitExceeded(ref cause) => cause,
            DeleteJobError::ResourceNotFound(ref cause) => cause,
            DeleteJobError::ServiceUnavailable(ref cause) => cause,
            DeleteJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteJobExecution
#[derive(Debug, PartialEq)]
pub enum DeleteJobExecutionError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>An attempt was made to change to an invalid state, for example by deleting a job or a job execution which is "IN_PROGRESS" without setting the <code>force</code> parameter.</p>
    InvalidStateTransition(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DeleteJobExecutionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteJobExecutionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteJobExecutionError::InvalidRequest(err.msg))
                }
                "InvalidStateTransitionException" => {
                    return RusotoError::Service(DeleteJobExecutionError::InvalidStateTransition(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteJobExecutionError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteJobExecutionError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteJobExecutionError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteJobExecutionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteJobExecutionError {
    fn description(&self) -> &str {
        match *self {
            DeleteJobExecutionError::InvalidRequest(ref cause) => cause,
            DeleteJobExecutionError::InvalidStateTransition(ref cause) => cause,
            DeleteJobExecutionError::ResourceNotFound(ref cause) => cause,
            DeleteJobExecutionError::ServiceUnavailable(ref cause) => cause,
            DeleteJobExecutionError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteMitigationAction
#[derive(Debug, PartialEq)]
pub enum DeleteMitigationActionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DeleteMitigationActionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteMitigationActionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteMitigationActionError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteMitigationActionError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteMitigationActionError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteMitigationActionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteMitigationActionError {
    fn description(&self) -> &str {
        match *self {
            DeleteMitigationActionError::InternalFailure(ref cause) => cause,
            DeleteMitigationActionError::InvalidRequest(ref cause) => cause,
            DeleteMitigationActionError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteOTAUpdate
#[derive(Debug, PartialEq)]
pub enum DeleteOTAUpdateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl DeleteOTAUpdateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteOTAUpdateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::Unauthorized(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(DeleteOTAUpdateError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteOTAUpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteOTAUpdateError {
    fn description(&self) -> &str {
        match *self {
            DeleteOTAUpdateError::InternalFailure(ref cause) => cause,
            DeleteOTAUpdateError::InvalidRequest(ref cause) => cause,
            DeleteOTAUpdateError::ResourceNotFound(ref cause) => cause,
            DeleteOTAUpdateError::ServiceUnavailable(ref cause) => cause,
            DeleteOTAUpdateError::Throttling(ref cause) => cause,
            DeleteOTAUpdateError::Unauthorized(ref cause) => cause,
            DeleteOTAUpdateError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by DeletePolicy
#[derive(Debug, PartialEq)]
pub enum DeletePolicyError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeletePolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeletePolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(DeletePolicyError::DeleteConflict(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeletePolicyError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeletePolicyError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeletePolicyError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeletePolicyError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeletePolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeletePolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeletePolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeletePolicyError {
    fn description(&self) -> &str {
        match *self {
            DeletePolicyError::DeleteConflict(ref cause) => cause,
            DeletePolicyError::InternalFailure(ref cause) => cause,
            DeletePolicyError::InvalidRequest(ref cause) => cause,
            DeletePolicyError::ResourceNotFound(ref cause) => cause,
            DeletePolicyError::ServiceUnavailable(ref cause) => cause,
            DeletePolicyError::Throttling(ref cause) => cause,
            DeletePolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeletePolicyVersion
#[derive(Debug, PartialEq)]
pub enum DeletePolicyVersionError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeletePolicyVersionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeletePolicyVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(DeletePolicyVersionError::DeleteConflict(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeletePolicyVersionError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeletePolicyVersionError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeletePolicyVersionError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeletePolicyVersionError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeletePolicyVersionError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeletePolicyVersionError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeletePolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeletePolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            DeletePolicyVersionError::DeleteConflict(ref cause) => cause,
            DeletePolicyVersionError::InternalFailure(ref cause) => cause,
            DeletePolicyVersionError::InvalidRequest(ref cause) => cause,
            DeletePolicyVersionError::ResourceNotFound(ref cause) => cause,
            DeletePolicyVersionError::ServiceUnavailable(ref cause) => cause,
            DeletePolicyVersionError::Throttling(ref cause) => cause,
            DeletePolicyVersionError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteProvisioningTemplate
#[derive(Debug, PartialEq)]
pub enum DeleteProvisioningTemplateError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteProvisioningTemplateError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DeleteProvisioningTemplateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(DeleteProvisioningTemplateError::DeleteConflict(
                        err.msg,
                    ))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteProvisioningTemplateError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteProvisioningTemplateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteProvisioningTemplateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteProvisioningTemplateError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteProvisioningTemplateError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteProvisioningTemplateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteProvisioningTemplateError {
    fn description(&self) -> &str {
        match *self {
            DeleteProvisioningTemplateError::DeleteConflict(ref cause) => cause,
            DeleteProvisioningTemplateError::InternalFailure(ref cause) => cause,
            DeleteProvisioningTemplateError::InvalidRequest(ref cause) => cause,
            DeleteProvisioningTemplateError::ResourceNotFound(ref cause) => cause,
            DeleteProvisioningTemplateError::Throttling(ref cause) => cause,
            DeleteProvisioningTemplateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteProvisioningTemplateVersion
#[derive(Debug, PartialEq)]
pub enum DeleteProvisioningTemplateVersionError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteProvisioningTemplateVersionError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DeleteProvisioningTemplateVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(
                        DeleteProvisioningTemplateVersionError::DeleteConflict(err.msg),
                    )
                }
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DeleteProvisioningTemplateVersionError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        DeleteProvisioningTemplateVersionError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DeleteProvisioningTemplateVersionError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(
                        DeleteProvisioningTemplateVersionError::Throttling(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(
                        DeleteProvisioningTemplateVersionError::Unauthorized(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteProvisioningTemplateVersionError {
    fn description(&self) -> &str {
        match *self {
            DeleteProvisioningTemplateVersionError::DeleteConflict(ref cause) => cause,
            DeleteProvisioningTemplateVersionError::InternalFailure(ref cause) => cause,
            DeleteProvisioningTemplateVersionError::InvalidRequest(ref cause) => cause,
            DeleteProvisioningTemplateVersionError::ResourceNotFound(ref cause) => cause,
            DeleteProvisioningTemplateVersionError::Throttling(ref cause) => cause,
            DeleteProvisioningTemplateVersionError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteRegistrationCode
#[derive(Debug, PartialEq)]
pub enum DeleteRegistrationCodeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteRegistrationCodeError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteRegistrationCodeError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteRegistrationCodeError::InternalFailure(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteRegistrationCodeError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteRegistrationCodeError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteRegistrationCodeError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteRegistrationCodeError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteRegistrationCodeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteRegistrationCodeError {
    fn description(&self) -> &str {
        match *self {
            DeleteRegistrationCodeError::InternalFailure(ref cause) => cause,
            DeleteRegistrationCodeError::ResourceNotFound(ref cause) => cause,
            DeleteRegistrationCodeError::ServiceUnavailable(ref cause) => cause,
            DeleteRegistrationCodeError::Throttling(ref cause) => cause,
            DeleteRegistrationCodeError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteRoleAlias
#[derive(Debug, PartialEq)]
pub enum DeleteRoleAliasError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteRoleAliasError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteRoleAliasError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(DeleteRoleAliasError::DeleteConflict(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteRoleAliasError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteRoleAliasError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteRoleAliasError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteRoleAliasError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteRoleAliasError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteRoleAliasError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            DeleteRoleAliasError::DeleteConflict(ref cause) => cause,
            DeleteRoleAliasError::InternalFailure(ref cause) => cause,
            DeleteRoleAliasError::InvalidRequest(ref cause) => cause,
            DeleteRoleAliasError::ResourceNotFound(ref cause) => cause,
            DeleteRoleAliasError::ServiceUnavailable(ref cause) => cause,
            DeleteRoleAliasError::Throttling(ref cause) => cause,
            DeleteRoleAliasError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteScheduledAudit
#[derive(Debug, PartialEq)]
pub enum DeleteScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DeleteScheduledAuditError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteScheduledAuditError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteScheduledAuditError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteScheduledAuditError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteScheduledAuditError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteScheduledAuditError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            DeleteScheduledAuditError::InternalFailure(ref cause) => cause,
            DeleteScheduledAuditError::InvalidRequest(ref cause) => cause,
            DeleteScheduledAuditError::ResourceNotFound(ref cause) => cause,
            DeleteScheduledAuditError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteSecurityProfile
#[derive(Debug, PartialEq)]
pub enum DeleteSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl DeleteSecurityProfileError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteSecurityProfileError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteSecurityProfileError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteSecurityProfileError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(DeleteSecurityProfileError::VersionConflict(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            DeleteSecurityProfileError::InternalFailure(ref cause) => cause,
            DeleteSecurityProfileError::InvalidRequest(ref cause) => cause,
            DeleteSecurityProfileError::Throttling(ref cause) => cause,
            DeleteSecurityProfileError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteStream
#[derive(Debug, PartialEq)]
pub enum DeleteStreamError {
    /// <p>You can't delete the resource because it is attached to one or more resources.</p>
    DeleteConflict(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteStreamError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteStreamError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "DeleteConflictException" => {
                    return RusotoError::Service(DeleteStreamError::DeleteConflict(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteStreamError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteStreamError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteStreamError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteStreamError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteStreamError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteStreamError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteStreamError {
    fn description(&self) -> &str {
        match *self {
            DeleteStreamError::DeleteConflict(ref cause) => cause,
            DeleteStreamError::InternalFailure(ref cause) => cause,
            DeleteStreamError::InvalidRequest(ref cause) => cause,
            DeleteStreamError::ResourceNotFound(ref cause) => cause,
            DeleteStreamError::ServiceUnavailable(ref cause) => cause,
            DeleteStreamError::Throttling(ref cause) => cause,
            DeleteStreamError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteThing
#[derive(Debug, PartialEq)]
pub enum DeleteThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl DeleteThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteThingError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteThingError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteThingError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteThingError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteThingError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteThingError::Unauthorized(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(DeleteThingError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteThingError {
    fn description(&self) -> &str {
        match *self {
            DeleteThingError::InternalFailure(ref cause) => cause,
            DeleteThingError::InvalidRequest(ref cause) => cause,
            DeleteThingError::ResourceNotFound(ref cause) => cause,
            DeleteThingError::ServiceUnavailable(ref cause) => cause,
            DeleteThingError::Throttling(ref cause) => cause,
            DeleteThingError::Unauthorized(ref cause) => cause,
            DeleteThingError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteThingGroup
#[derive(Debug, PartialEq)]
pub enum DeleteThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl DeleteThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteThingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteThingGroupError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteThingGroupError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(DeleteThingGroupError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteThingGroupError {
    fn description(&self) -> &str {
        match *self {
            DeleteThingGroupError::InternalFailure(ref cause) => cause,
            DeleteThingGroupError::InvalidRequest(ref cause) => cause,
            DeleteThingGroupError::Throttling(ref cause) => cause,
            DeleteThingGroupError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteThingType
#[derive(Debug, PartialEq)]
pub enum DeleteThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteThingTypeError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteThingTypeError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeleteThingTypeError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteThingTypeError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeleteThingTypeError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteThingTypeError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeleteThingTypeError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteThingTypeError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteThingTypeError {
    fn description(&self) -> &str {
        match *self {
            DeleteThingTypeError::InternalFailure(ref cause) => cause,
            DeleteThingTypeError::InvalidRequest(ref cause) => cause,
            DeleteThingTypeError::ResourceNotFound(ref cause) => cause,
            DeleteThingTypeError::ServiceUnavailable(ref cause) => cause,
            DeleteThingTypeError::Throttling(ref cause) => cause,
            DeleteThingTypeError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteTopicRule
#[derive(Debug, PartialEq)]
pub enum DeleteTopicRuleError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteTopicRuleError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteTopicRuleError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(DeleteTopicRuleError::ConflictingResourceUpdate(
                        err.msg,
                    ))
                }
                "InternalException" => {
                    return RusotoError::Service(DeleteTopicRuleError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteTopicRuleError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteTopicRuleError::ServiceUnavailable(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteTopicRuleError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            DeleteTopicRuleError::ConflictingResourceUpdate(ref cause) => cause,
            DeleteTopicRuleError::Internal(ref cause) => cause,
            DeleteTopicRuleError::InvalidRequest(ref cause) => cause,
            DeleteTopicRuleError::ServiceUnavailable(ref cause) => cause,
            DeleteTopicRuleError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteTopicRuleDestination
#[derive(Debug, PartialEq)]
pub enum DeleteTopicRuleDestinationError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeleteTopicRuleDestinationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DeleteTopicRuleDestinationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(
                        DeleteTopicRuleDestinationError::ConflictingResourceUpdate(err.msg),
                    )
                }
                "InternalException" => {
                    return RusotoError::Service(DeleteTopicRuleDestinationError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteTopicRuleDestinationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        DeleteTopicRuleDestinationError::ServiceUnavailable(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeleteTopicRuleDestinationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteTopicRuleDestinationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteTopicRuleDestinationError {
    fn description(&self) -> &str {
        match *self {
            DeleteTopicRuleDestinationError::ConflictingResourceUpdate(ref cause) => cause,
            DeleteTopicRuleDestinationError::Internal(ref cause) => cause,
            DeleteTopicRuleDestinationError::InvalidRequest(ref cause) => cause,
            DeleteTopicRuleDestinationError::ServiceUnavailable(ref cause) => cause,
            DeleteTopicRuleDestinationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DeleteV2LoggingLevel
#[derive(Debug, PartialEq)]
pub enum DeleteV2LoggingLevelError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl DeleteV2LoggingLevelError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeleteV2LoggingLevelError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(DeleteV2LoggingLevelError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeleteV2LoggingLevelError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeleteV2LoggingLevelError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeleteV2LoggingLevelError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeleteV2LoggingLevelError {
    fn description(&self) -> &str {
        match *self {
            DeleteV2LoggingLevelError::Internal(ref cause) => cause,
            DeleteV2LoggingLevelError::InvalidRequest(ref cause) => cause,
            DeleteV2LoggingLevelError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by DeprecateThingType
#[derive(Debug, PartialEq)]
pub enum DeprecateThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DeprecateThingTypeError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DeprecateThingTypeError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DeprecateThingTypeError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DeprecateThingTypeError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DeprecateThingTypeError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DeprecateThingTypeError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DeprecateThingTypeError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DeprecateThingTypeError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DeprecateThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DeprecateThingTypeError {
    fn description(&self) -> &str {
        match *self {
            DeprecateThingTypeError::InternalFailure(ref cause) => cause,
            DeprecateThingTypeError::InvalidRequest(ref cause) => cause,
            DeprecateThingTypeError::ResourceNotFound(ref cause) => cause,
            DeprecateThingTypeError::ServiceUnavailable(ref cause) => cause,
            DeprecateThingTypeError::Throttling(ref cause) => cause,
            DeprecateThingTypeError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeAccountAuditConfiguration
#[derive(Debug, PartialEq)]
pub enum DescribeAccountAuditConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeAccountAuditConfigurationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeAccountAuditConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DescribeAccountAuditConfigurationError::InternalFailure(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(
                        DescribeAccountAuditConfigurationError::Throttling(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeAccountAuditConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAccountAuditConfigurationError {
    fn description(&self) -> &str {
        match *self {
            DescribeAccountAuditConfigurationError::InternalFailure(ref cause) => cause,
            DescribeAccountAuditConfigurationError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeAuditFinding
#[derive(Debug, PartialEq)]
pub enum DescribeAuditFindingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeAuditFindingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeAuditFindingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeAuditFindingError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeAuditFindingError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeAuditFindingError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeAuditFindingError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeAuditFindingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAuditFindingError {
    fn description(&self) -> &str {
        match *self {
            DescribeAuditFindingError::InternalFailure(ref cause) => cause,
            DescribeAuditFindingError::InvalidRequest(ref cause) => cause,
            DescribeAuditFindingError::ResourceNotFound(ref cause) => cause,
            DescribeAuditFindingError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeAuditMitigationActionsTask
#[derive(Debug, PartialEq)]
pub enum DescribeAuditMitigationActionsTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeAuditMitigationActionsTaskError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeAuditMitigationActionsTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DescribeAuditMitigationActionsTaskError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        DescribeAuditMitigationActionsTaskError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DescribeAuditMitigationActionsTaskError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(
                        DescribeAuditMitigationActionsTaskError::Throttling(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAuditMitigationActionsTaskError {
    fn description(&self) -> &str {
        match *self {
            DescribeAuditMitigationActionsTaskError::InternalFailure(ref cause) => cause,
            DescribeAuditMitigationActionsTaskError::InvalidRequest(ref cause) => cause,
            DescribeAuditMitigationActionsTaskError::ResourceNotFound(ref cause) => cause,
            DescribeAuditMitigationActionsTaskError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeAuditTask
#[derive(Debug, PartialEq)]
pub enum DescribeAuditTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeAuditTaskError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeAuditTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeAuditTaskError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeAuditTaskError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeAuditTaskError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeAuditTaskError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeAuditTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAuditTaskError {
    fn description(&self) -> &str {
        match *self {
            DescribeAuditTaskError::InternalFailure(ref cause) => cause,
            DescribeAuditTaskError::InvalidRequest(ref cause) => cause,
            DescribeAuditTaskError::ResourceNotFound(ref cause) => cause,
            DescribeAuditTaskError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeAuthorizer
#[derive(Debug, PartialEq)]
pub enum DescribeAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeAuthorizerError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeAuthorizerError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeAuthorizerError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeAuthorizerError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            DescribeAuthorizerError::InternalFailure(ref cause) => cause,
            DescribeAuthorizerError::InvalidRequest(ref cause) => cause,
            DescribeAuthorizerError::ResourceNotFound(ref cause) => cause,
            DescribeAuthorizerError::ServiceUnavailable(ref cause) => cause,
            DescribeAuthorizerError::Throttling(ref cause) => cause,
            DescribeAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeBillingGroup
#[derive(Debug, PartialEq)]
pub enum DescribeBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeBillingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeBillingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeBillingGroupError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeBillingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeBillingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            DescribeBillingGroupError::InternalFailure(ref cause) => cause,
            DescribeBillingGroupError::InvalidRequest(ref cause) => cause,
            DescribeBillingGroupError::ResourceNotFound(ref cause) => cause,
            DescribeBillingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeCACertificate
#[derive(Debug, PartialEq)]
pub enum DescribeCACertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeCACertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeCACertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeCACertificateError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeCACertificateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeCACertificateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeCACertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeCACertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeCACertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeCACertificateError {
    fn description(&self) -> &str {
        match *self {
            DescribeCACertificateError::InternalFailure(ref cause) => cause,
            DescribeCACertificateError::InvalidRequest(ref cause) => cause,
            DescribeCACertificateError::ResourceNotFound(ref cause) => cause,
            DescribeCACertificateError::ServiceUnavailable(ref cause) => cause,
            DescribeCACertificateError::Throttling(ref cause) => cause,
            DescribeCACertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeCertificate
#[derive(Debug, PartialEq)]
pub enum DescribeCertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeCertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeCertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeCertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeCertificateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeCertificateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeCertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeCertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeCertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeCertificateError {
    fn description(&self) -> &str {
        match *self {
            DescribeCertificateError::InternalFailure(ref cause) => cause,
            DescribeCertificateError::InvalidRequest(ref cause) => cause,
            DescribeCertificateError::ResourceNotFound(ref cause) => cause,
            DescribeCertificateError::ServiceUnavailable(ref cause) => cause,
            DescribeCertificateError::Throttling(ref cause) => cause,
            DescribeCertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeDefaultAuthorizer
#[derive(Debug, PartialEq)]
pub enum DescribeDefaultAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeDefaultAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeDefaultAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeDefaultAuthorizerError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeDefaultAuthorizerError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeDefaultAuthorizerError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        DescribeDefaultAuthorizerError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeDefaultAuthorizerError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeDefaultAuthorizerError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeDefaultAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeDefaultAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            DescribeDefaultAuthorizerError::InternalFailure(ref cause) => cause,
            DescribeDefaultAuthorizerError::InvalidRequest(ref cause) => cause,
            DescribeDefaultAuthorizerError::ResourceNotFound(ref cause) => cause,
            DescribeDefaultAuthorizerError::ServiceUnavailable(ref cause) => cause,
            DescribeDefaultAuthorizerError::Throttling(ref cause) => cause,
            DescribeDefaultAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeDomainConfiguration
#[derive(Debug, PartialEq)]
pub enum DescribeDomainConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeDomainConfigurationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeDomainConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeDomainConfigurationError::InternalFailure(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DescribeDomainConfigurationError::ResourceNotFound(err.msg),
                    )
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        DescribeDomainConfigurationError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeDomainConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeDomainConfigurationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeDomainConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeDomainConfigurationError {
    fn description(&self) -> &str {
        match *self {
            DescribeDomainConfigurationError::InternalFailure(ref cause) => cause,
            DescribeDomainConfigurationError::ResourceNotFound(ref cause) => cause,
            DescribeDomainConfigurationError::ServiceUnavailable(ref cause) => cause,
            DescribeDomainConfigurationError::Throttling(ref cause) => cause,
            DescribeDomainConfigurationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeEndpoint
#[derive(Debug, PartialEq)]
pub enum DescribeEndpointError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeEndpointError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeEndpointError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeEndpointError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeEndpointError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeEndpointError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeEndpointError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeEndpointError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeEndpointError {
    fn description(&self) -> &str {
        match *self {
            DescribeEndpointError::InternalFailure(ref cause) => cause,
            DescribeEndpointError::InvalidRequest(ref cause) => cause,
            DescribeEndpointError::Throttling(ref cause) => cause,
            DescribeEndpointError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeEventConfigurations
#[derive(Debug, PartialEq)]
pub enum DescribeEventConfigurationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeEventConfigurationsError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeEventConfigurationsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeEventConfigurationsError::InternalFailure(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeEventConfigurationsError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeEventConfigurationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeEventConfigurationsError {
    fn description(&self) -> &str {
        match *self {
            DescribeEventConfigurationsError::InternalFailure(ref cause) => cause,
            DescribeEventConfigurationsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeIndex
#[derive(Debug, PartialEq)]
pub enum DescribeIndexError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeIndexError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeIndexError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeIndexError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeIndexError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeIndexError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeIndexError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeIndexError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeIndexError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeIndexError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeIndexError {
    fn description(&self) -> &str {
        match *self {
            DescribeIndexError::InternalFailure(ref cause) => cause,
            DescribeIndexError::InvalidRequest(ref cause) => cause,
            DescribeIndexError::ResourceNotFound(ref cause) => cause,
            DescribeIndexError::ServiceUnavailable(ref cause) => cause,
            DescribeIndexError::Throttling(ref cause) => cause,
            DescribeIndexError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeJob
#[derive(Debug, PartialEq)]
pub enum DescribeJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeJobError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeJobError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeJobError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeJobError {
    fn description(&self) -> &str {
        match *self {
            DescribeJobError::InvalidRequest(ref cause) => cause,
            DescribeJobError::ResourceNotFound(ref cause) => cause,
            DescribeJobError::ServiceUnavailable(ref cause) => cause,
            DescribeJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeJobExecution
#[derive(Debug, PartialEq)]
pub enum DescribeJobExecutionError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeJobExecutionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeJobExecutionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeJobExecutionError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeJobExecutionError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeJobExecutionError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeJobExecutionError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeJobExecutionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeJobExecutionError {
    fn description(&self) -> &str {
        match *self {
            DescribeJobExecutionError::InvalidRequest(ref cause) => cause,
            DescribeJobExecutionError::ResourceNotFound(ref cause) => cause,
            DescribeJobExecutionError::ServiceUnavailable(ref cause) => cause,
            DescribeJobExecutionError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeMitigationAction
#[derive(Debug, PartialEq)]
pub enum DescribeMitigationActionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeMitigationActionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeMitigationActionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeMitigationActionError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeMitigationActionError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeMitigationActionError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeMitigationActionError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeMitigationActionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeMitigationActionError {
    fn description(&self) -> &str {
        match *self {
            DescribeMitigationActionError::InternalFailure(ref cause) => cause,
            DescribeMitigationActionError::InvalidRequest(ref cause) => cause,
            DescribeMitigationActionError::ResourceNotFound(ref cause) => cause,
            DescribeMitigationActionError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeProvisioningTemplate
#[derive(Debug, PartialEq)]
pub enum DescribeProvisioningTemplateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeProvisioningTemplateError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeProvisioningTemplateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeProvisioningTemplateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeProvisioningTemplateError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeProvisioningTemplateError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeProvisioningTemplateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeProvisioningTemplateError {
    fn description(&self) -> &str {
        match *self {
            DescribeProvisioningTemplateError::InternalFailure(ref cause) => cause,
            DescribeProvisioningTemplateError::InvalidRequest(ref cause) => cause,
            DescribeProvisioningTemplateError::ResourceNotFound(ref cause) => cause,
            DescribeProvisioningTemplateError::Throttling(ref cause) => cause,
            DescribeProvisioningTemplateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeProvisioningTemplateVersion
#[derive(Debug, PartialEq)]
pub enum DescribeProvisioningTemplateVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeProvisioningTemplateVersionError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeProvisioningTemplateVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateVersionError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateVersionError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateVersionError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateVersionError::Throttling(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(
                        DescribeProvisioningTemplateVersionError::Unauthorized(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeProvisioningTemplateVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeProvisioningTemplateVersionError {
    fn description(&self) -> &str {
        match *self {
            DescribeProvisioningTemplateVersionError::InternalFailure(ref cause) => cause,
            DescribeProvisioningTemplateVersionError::InvalidRequest(ref cause) => cause,
            DescribeProvisioningTemplateVersionError::ResourceNotFound(ref cause) => cause,
            DescribeProvisioningTemplateVersionError::Throttling(ref cause) => cause,
            DescribeProvisioningTemplateVersionError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeRoleAlias
#[derive(Debug, PartialEq)]
pub enum DescribeRoleAliasError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeRoleAliasError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeRoleAliasError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeRoleAliasError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeRoleAliasError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeRoleAliasError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeRoleAliasError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeRoleAliasError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeRoleAliasError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            DescribeRoleAliasError::InternalFailure(ref cause) => cause,
            DescribeRoleAliasError::InvalidRequest(ref cause) => cause,
            DescribeRoleAliasError::ResourceNotFound(ref cause) => cause,
            DescribeRoleAliasError::ServiceUnavailable(ref cause) => cause,
            DescribeRoleAliasError::Throttling(ref cause) => cause,
            DescribeRoleAliasError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeScheduledAudit
#[derive(Debug, PartialEq)]
pub enum DescribeScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeScheduledAuditError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeScheduledAuditError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeScheduledAuditError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeScheduledAuditError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeScheduledAuditError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeScheduledAuditError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            DescribeScheduledAuditError::InternalFailure(ref cause) => cause,
            DescribeScheduledAuditError::InvalidRequest(ref cause) => cause,
            DescribeScheduledAuditError::ResourceNotFound(ref cause) => cause,
            DescribeScheduledAuditError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeSecurityProfile
#[derive(Debug, PartialEq)]
pub enum DescribeSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeSecurityProfileError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeSecurityProfileError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeSecurityProfileError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeSecurityProfileError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeSecurityProfileError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            DescribeSecurityProfileError::InternalFailure(ref cause) => cause,
            DescribeSecurityProfileError::InvalidRequest(ref cause) => cause,
            DescribeSecurityProfileError::ResourceNotFound(ref cause) => cause,
            DescribeSecurityProfileError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeStream
#[derive(Debug, PartialEq)]
pub enum DescribeStreamError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeStreamError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeStreamError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeStreamError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeStreamError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeStreamError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeStreamError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeStreamError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeStreamError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeStreamError {
    fn description(&self) -> &str {
        match *self {
            DescribeStreamError::InternalFailure(ref cause) => cause,
            DescribeStreamError::InvalidRequest(ref cause) => cause,
            DescribeStreamError::ResourceNotFound(ref cause) => cause,
            DescribeStreamError::ServiceUnavailable(ref cause) => cause,
            DescribeStreamError::Throttling(ref cause) => cause,
            DescribeStreamError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeThing
#[derive(Debug, PartialEq)]
pub enum DescribeThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeThingError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeThingError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeThingError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeThingError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeThingError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeThingError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingError::InternalFailure(ref cause) => cause,
            DescribeThingError::InvalidRequest(ref cause) => cause,
            DescribeThingError::ResourceNotFound(ref cause) => cause,
            DescribeThingError::ServiceUnavailable(ref cause) => cause,
            DescribeThingError::Throttling(ref cause) => cause,
            DescribeThingError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeThingGroup
#[derive(Debug, PartialEq)]
pub enum DescribeThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DescribeThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeThingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeThingGroupError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeThingGroupError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeThingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingGroupError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingGroupError::InternalFailure(ref cause) => cause,
            DescribeThingGroupError::InvalidRequest(ref cause) => cause,
            DescribeThingGroupError::ResourceNotFound(ref cause) => cause,
            DescribeThingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeThingRegistrationTask
#[derive(Debug, PartialEq)]
pub enum DescribeThingRegistrationTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeThingRegistrationTaskError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<DescribeThingRegistrationTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        DescribeThingRegistrationTaskError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        DescribeThingRegistrationTaskError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        DescribeThingRegistrationTaskError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeThingRegistrationTaskError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeThingRegistrationTaskError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeThingRegistrationTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingRegistrationTaskError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingRegistrationTaskError::InternalFailure(ref cause) => cause,
            DescribeThingRegistrationTaskError::InvalidRequest(ref cause) => cause,
            DescribeThingRegistrationTaskError::ResourceNotFound(ref cause) => cause,
            DescribeThingRegistrationTaskError::Throttling(ref cause) => cause,
            DescribeThingRegistrationTaskError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DescribeThingType
#[derive(Debug, PartialEq)]
pub enum DescribeThingTypeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DescribeThingTypeError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DescribeThingTypeError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DescribeThingTypeError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DescribeThingTypeError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DescribeThingTypeError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DescribeThingTypeError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DescribeThingTypeError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DescribeThingTypeError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DescribeThingTypeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DescribeThingTypeError {
    fn description(&self) -> &str {
        match *self {
            DescribeThingTypeError::InternalFailure(ref cause) => cause,
            DescribeThingTypeError::InvalidRequest(ref cause) => cause,
            DescribeThingTypeError::ResourceNotFound(ref cause) => cause,
            DescribeThingTypeError::ServiceUnavailable(ref cause) => cause,
            DescribeThingTypeError::Throttling(ref cause) => cause,
            DescribeThingTypeError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DetachPolicy
#[derive(Debug, PartialEq)]
pub enum DetachPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DetachPolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DetachPolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DetachPolicyError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DetachPolicyError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(DetachPolicyError::LimitExceeded(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DetachPolicyError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DetachPolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DetachPolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DetachPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachPolicyError {
    fn description(&self) -> &str {
        match *self {
            DetachPolicyError::InternalFailure(ref cause) => cause,
            DetachPolicyError::InvalidRequest(ref cause) => cause,
            DetachPolicyError::LimitExceeded(ref cause) => cause,
            DetachPolicyError::ServiceUnavailable(ref cause) => cause,
            DetachPolicyError::Throttling(ref cause) => cause,
            DetachPolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DetachPrincipalPolicy
#[derive(Debug, PartialEq)]
pub enum DetachPrincipalPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DetachPrincipalPolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DetachPrincipalPolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DetachPrincipalPolicyError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DetachPrincipalPolicyError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DetachPrincipalPolicyError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DetachPrincipalPolicyError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DetachPrincipalPolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DetachPrincipalPolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DetachPrincipalPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachPrincipalPolicyError {
    fn description(&self) -> &str {
        match *self {
            DetachPrincipalPolicyError::InternalFailure(ref cause) => cause,
            DetachPrincipalPolicyError::InvalidRequest(ref cause) => cause,
            DetachPrincipalPolicyError::ResourceNotFound(ref cause) => cause,
            DetachPrincipalPolicyError::ServiceUnavailable(ref cause) => cause,
            DetachPrincipalPolicyError::Throttling(ref cause) => cause,
            DetachPrincipalPolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DetachSecurityProfile
#[derive(Debug, PartialEq)]
pub enum DetachSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl DetachSecurityProfileError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DetachSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DetachSecurityProfileError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DetachSecurityProfileError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DetachSecurityProfileError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DetachSecurityProfileError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DetachSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            DetachSecurityProfileError::InternalFailure(ref cause) => cause,
            DetachSecurityProfileError::InvalidRequest(ref cause) => cause,
            DetachSecurityProfileError::ResourceNotFound(ref cause) => cause,
            DetachSecurityProfileError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by DetachThingPrincipal
#[derive(Debug, PartialEq)]
pub enum DetachThingPrincipalError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DetachThingPrincipalError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DetachThingPrincipalError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(DetachThingPrincipalError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DetachThingPrincipalError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(DetachThingPrincipalError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DetachThingPrincipalError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(DetachThingPrincipalError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DetachThingPrincipalError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DetachThingPrincipalError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DetachThingPrincipalError {
    fn description(&self) -> &str {
        match *self {
            DetachThingPrincipalError::InternalFailure(ref cause) => cause,
            DetachThingPrincipalError::InvalidRequest(ref cause) => cause,
            DetachThingPrincipalError::ResourceNotFound(ref cause) => cause,
            DetachThingPrincipalError::ServiceUnavailable(ref cause) => cause,
            DetachThingPrincipalError::Throttling(ref cause) => cause,
            DetachThingPrincipalError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by DisableTopicRule
#[derive(Debug, PartialEq)]
pub enum DisableTopicRuleError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl DisableTopicRuleError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<DisableTopicRuleError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(DisableTopicRuleError::ConflictingResourceUpdate(
                        err.msg,
                    ))
                }
                "InternalException" => {
                    return RusotoError::Service(DisableTopicRuleError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(DisableTopicRuleError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(DisableTopicRuleError::ServiceUnavailable(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(DisableTopicRuleError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for DisableTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for DisableTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            DisableTopicRuleError::ConflictingResourceUpdate(ref cause) => cause,
            DisableTopicRuleError::Internal(ref cause) => cause,
            DisableTopicRuleError::InvalidRequest(ref cause) => cause,
            DisableTopicRuleError::ServiceUnavailable(ref cause) => cause,
            DisableTopicRuleError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by EnableTopicRule
#[derive(Debug, PartialEq)]
pub enum EnableTopicRuleError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl EnableTopicRuleError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<EnableTopicRuleError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(EnableTopicRuleError::ConflictingResourceUpdate(
                        err.msg,
                    ))
                }
                "InternalException" => {
                    return RusotoError::Service(EnableTopicRuleError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(EnableTopicRuleError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(EnableTopicRuleError::ServiceUnavailable(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(EnableTopicRuleError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for EnableTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for EnableTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            EnableTopicRuleError::ConflictingResourceUpdate(ref cause) => cause,
            EnableTopicRuleError::Internal(ref cause) => cause,
            EnableTopicRuleError::InvalidRequest(ref cause) => cause,
            EnableTopicRuleError::ServiceUnavailable(ref cause) => cause,
            EnableTopicRuleError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetCardinality
#[derive(Debug, PartialEq)]
pub enum GetCardinalityError {
    /// <p>The index is not ready.</p>
    IndexNotReady(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregation(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetCardinalityError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetCardinalityError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "IndexNotReadyException" => {
                    return RusotoError::Service(GetCardinalityError::IndexNotReady(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(GetCardinalityError::InternalFailure(err.msg))
                }
                "InvalidAggregationException" => {
                    return RusotoError::Service(GetCardinalityError::InvalidAggregation(err.msg))
                }
                "InvalidQueryException" => {
                    return RusotoError::Service(GetCardinalityError::InvalidQuery(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetCardinalityError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetCardinalityError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetCardinalityError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetCardinalityError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetCardinalityError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetCardinalityError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetCardinalityError {
    fn description(&self) -> &str {
        match *self {
            GetCardinalityError::IndexNotReady(ref cause) => cause,
            GetCardinalityError::InternalFailure(ref cause) => cause,
            GetCardinalityError::InvalidAggregation(ref cause) => cause,
            GetCardinalityError::InvalidQuery(ref cause) => cause,
            GetCardinalityError::InvalidRequest(ref cause) => cause,
            GetCardinalityError::ResourceNotFound(ref cause) => cause,
            GetCardinalityError::ServiceUnavailable(ref cause) => cause,
            GetCardinalityError::Throttling(ref cause) => cause,
            GetCardinalityError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetEffectivePolicies
#[derive(Debug, PartialEq)]
pub enum GetEffectivePoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetEffectivePoliciesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetEffectivePoliciesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetEffectivePoliciesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetEffectivePoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetEffectivePoliciesError {
    fn description(&self) -> &str {
        match *self {
            GetEffectivePoliciesError::InternalFailure(ref cause) => cause,
            GetEffectivePoliciesError::InvalidRequest(ref cause) => cause,
            GetEffectivePoliciesError::LimitExceeded(ref cause) => cause,
            GetEffectivePoliciesError::ResourceNotFound(ref cause) => cause,
            GetEffectivePoliciesError::ServiceUnavailable(ref cause) => cause,
            GetEffectivePoliciesError::Throttling(ref cause) => cause,
            GetEffectivePoliciesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetIndexingConfiguration
#[derive(Debug, PartialEq)]
pub enum GetIndexingConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetIndexingConfigurationError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetIndexingConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(GetIndexingConfigurationError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetIndexingConfigurationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetIndexingConfigurationError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetIndexingConfigurationError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetIndexingConfigurationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetIndexingConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetIndexingConfigurationError {
    fn description(&self) -> &str {
        match *self {
            GetIndexingConfigurationError::InternalFailure(ref cause) => cause,
            GetIndexingConfigurationError::InvalidRequest(ref cause) => cause,
            GetIndexingConfigurationError::ServiceUnavailable(ref cause) => cause,
            GetIndexingConfigurationError::Throttling(ref cause) => cause,
            GetIndexingConfigurationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetJobDocument
#[derive(Debug, PartialEq)]
pub enum GetJobDocumentError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl GetJobDocumentError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetJobDocumentError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(GetJobDocumentError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetJobDocumentError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetJobDocumentError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetJobDocumentError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetJobDocumentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetJobDocumentError {
    fn description(&self) -> &str {
        match *self {
            GetJobDocumentError::InvalidRequest(ref cause) => cause,
            GetJobDocumentError::ResourceNotFound(ref cause) => cause,
            GetJobDocumentError::ServiceUnavailable(ref cause) => cause,
            GetJobDocumentError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by GetLoggingOptions
#[derive(Debug, PartialEq)]
pub enum GetLoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl GetLoggingOptionsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetLoggingOptionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(GetLoggingOptionsError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetLoggingOptionsError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetLoggingOptionsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetLoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetLoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            GetLoggingOptionsError::Internal(ref cause) => cause,
            GetLoggingOptionsError::InvalidRequest(ref cause) => cause,
            GetLoggingOptionsError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by GetOTAUpdate
#[derive(Debug, PartialEq)]
pub enum GetOTAUpdateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetOTAUpdateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetOTAUpdateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(GetOTAUpdateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetOTAUpdateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetOTAUpdateError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetOTAUpdateError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetOTAUpdateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetOTAUpdateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetOTAUpdateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetOTAUpdateError {
    fn description(&self) -> &str {
        match *self {
            GetOTAUpdateError::InternalFailure(ref cause) => cause,
            GetOTAUpdateError::InvalidRequest(ref cause) => cause,
            GetOTAUpdateError::ResourceNotFound(ref cause) => cause,
            GetOTAUpdateError::ServiceUnavailable(ref cause) => cause,
            GetOTAUpdateError::Throttling(ref cause) => cause,
            GetOTAUpdateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetPercentiles
#[derive(Debug, PartialEq)]
pub enum GetPercentilesError {
    /// <p>The index is not ready.</p>
    IndexNotReady(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregation(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetPercentilesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetPercentilesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "IndexNotReadyException" => {
                    return RusotoError::Service(GetPercentilesError::IndexNotReady(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(GetPercentilesError::InternalFailure(err.msg))
                }
                "InvalidAggregationException" => {
                    return RusotoError::Service(GetPercentilesError::InvalidAggregation(err.msg))
                }
                "InvalidQueryException" => {
                    return RusotoError::Service(GetPercentilesError::InvalidQuery(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetPercentilesError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetPercentilesError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetPercentilesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetPercentilesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetPercentilesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetPercentilesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetPercentilesError {
    fn description(&self) -> &str {
        match *self {
            GetPercentilesError::IndexNotReady(ref cause) => cause,
            GetPercentilesError::InternalFailure(ref cause) => cause,
            GetPercentilesError::InvalidAggregation(ref cause) => cause,
            GetPercentilesError::InvalidQuery(ref cause) => cause,
            GetPercentilesError::InvalidRequest(ref cause) => cause,
            GetPercentilesError::ResourceNotFound(ref cause) => cause,
            GetPercentilesError::ServiceUnavailable(ref cause) => cause,
            GetPercentilesError::Throttling(ref cause) => cause,
            GetPercentilesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetPolicy
#[derive(Debug, PartialEq)]
pub enum GetPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetPolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetPolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(GetPolicyError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetPolicyError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetPolicyError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetPolicyError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetPolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetPolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetPolicyError {
    fn description(&self) -> &str {
        match *self {
            GetPolicyError::InternalFailure(ref cause) => cause,
            GetPolicyError::InvalidRequest(ref cause) => cause,
            GetPolicyError::ResourceNotFound(ref cause) => cause,
            GetPolicyError::ServiceUnavailable(ref cause) => cause,
            GetPolicyError::Throttling(ref cause) => cause,
            GetPolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetPolicyVersion
#[derive(Debug, PartialEq)]
pub enum GetPolicyVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetPolicyVersionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetPolicyVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(GetPolicyVersionError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetPolicyVersionError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetPolicyVersionError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetPolicyVersionError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetPolicyVersionError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetPolicyVersionError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetPolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetPolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            GetPolicyVersionError::InternalFailure(ref cause) => cause,
            GetPolicyVersionError::InvalidRequest(ref cause) => cause,
            GetPolicyVersionError::ResourceNotFound(ref cause) => cause,
            GetPolicyVersionError::ServiceUnavailable(ref cause) => cause,
            GetPolicyVersionError::Throttling(ref cause) => cause,
            GetPolicyVersionError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetRegistrationCode
#[derive(Debug, PartialEq)]
pub enum GetRegistrationCodeError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetRegistrationCodeError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetRegistrationCodeError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(GetRegistrationCodeError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetRegistrationCodeError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetRegistrationCodeError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetRegistrationCodeError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetRegistrationCodeError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetRegistrationCodeError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetRegistrationCodeError {
    fn description(&self) -> &str {
        match *self {
            GetRegistrationCodeError::InternalFailure(ref cause) => cause,
            GetRegistrationCodeError::InvalidRequest(ref cause) => cause,
            GetRegistrationCodeError::ServiceUnavailable(ref cause) => cause,
            GetRegistrationCodeError::Throttling(ref cause) => cause,
            GetRegistrationCodeError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetStatistics
#[derive(Debug, PartialEq)]
pub enum GetStatisticsError {
    /// <p>The index is not ready.</p>
    IndexNotReady(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The aggregation is invalid.</p>
    InvalidAggregation(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetStatisticsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetStatisticsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "IndexNotReadyException" => {
                    return RusotoError::Service(GetStatisticsError::IndexNotReady(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(GetStatisticsError::InternalFailure(err.msg))
                }
                "InvalidAggregationException" => {
                    return RusotoError::Service(GetStatisticsError::InvalidAggregation(err.msg))
                }
                "InvalidQueryException" => {
                    return RusotoError::Service(GetStatisticsError::InvalidQuery(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetStatisticsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(GetStatisticsError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetStatisticsError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(GetStatisticsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetStatisticsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetStatisticsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetStatisticsError {
    fn description(&self) -> &str {
        match *self {
            GetStatisticsError::IndexNotReady(ref cause) => cause,
            GetStatisticsError::InternalFailure(ref cause) => cause,
            GetStatisticsError::InvalidAggregation(ref cause) => cause,
            GetStatisticsError::InvalidQuery(ref cause) => cause,
            GetStatisticsError::InvalidRequest(ref cause) => cause,
            GetStatisticsError::ResourceNotFound(ref cause) => cause,
            GetStatisticsError::ServiceUnavailable(ref cause) => cause,
            GetStatisticsError::Throttling(ref cause) => cause,
            GetStatisticsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetTopicRule
#[derive(Debug, PartialEq)]
pub enum GetTopicRuleError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetTopicRuleError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetTopicRuleError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(GetTopicRuleError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetTopicRuleError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetTopicRuleError::ServiceUnavailable(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetTopicRuleError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            GetTopicRuleError::Internal(ref cause) => cause,
            GetTopicRuleError::InvalidRequest(ref cause) => cause,
            GetTopicRuleError::ServiceUnavailable(ref cause) => cause,
            GetTopicRuleError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetTopicRuleDestination
#[derive(Debug, PartialEq)]
pub enum GetTopicRuleDestinationError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl GetTopicRuleDestinationError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetTopicRuleDestinationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(GetTopicRuleDestinationError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(GetTopicRuleDestinationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetTopicRuleDestinationError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(GetTopicRuleDestinationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetTopicRuleDestinationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetTopicRuleDestinationError {
    fn description(&self) -> &str {
        match *self {
            GetTopicRuleDestinationError::Internal(ref cause) => cause,
            GetTopicRuleDestinationError::InvalidRequest(ref cause) => cause,
            GetTopicRuleDestinationError::ServiceUnavailable(ref cause) => cause,
            GetTopicRuleDestinationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by GetV2LoggingOptions
#[derive(Debug, PartialEq)]
pub enum GetV2LoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The resource is not configured.</p>
    NotConfigured(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl GetV2LoggingOptionsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<GetV2LoggingOptionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(GetV2LoggingOptionsError::Internal(err.msg))
                }
                "NotConfiguredException" => {
                    return RusotoError::Service(GetV2LoggingOptionsError::NotConfigured(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(GetV2LoggingOptionsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for GetV2LoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for GetV2LoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            GetV2LoggingOptionsError::Internal(ref cause) => cause,
            GetV2LoggingOptionsError::NotConfigured(ref cause) => cause,
            GetV2LoggingOptionsError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by ListActiveViolations
#[derive(Debug, PartialEq)]
pub enum ListActiveViolationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListActiveViolationsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListActiveViolationsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListActiveViolationsError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListActiveViolationsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListActiveViolationsError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListActiveViolationsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListActiveViolationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListActiveViolationsError {
    fn description(&self) -> &str {
        match *self {
            ListActiveViolationsError::InternalFailure(ref cause) => cause,
            ListActiveViolationsError::InvalidRequest(ref cause) => cause,
            ListActiveViolationsError::ResourceNotFound(ref cause) => cause,
            ListActiveViolationsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListAttachedPolicies
#[derive(Debug, PartialEq)]
pub enum ListAttachedPoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListAttachedPoliciesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListAttachedPoliciesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListAttachedPoliciesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListAttachedPoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAttachedPoliciesError {
    fn description(&self) -> &str {
        match *self {
            ListAttachedPoliciesError::InternalFailure(ref cause) => cause,
            ListAttachedPoliciesError::InvalidRequest(ref cause) => cause,
            ListAttachedPoliciesError::LimitExceeded(ref cause) => cause,
            ListAttachedPoliciesError::ResourceNotFound(ref cause) => cause,
            ListAttachedPoliciesError::ServiceUnavailable(ref cause) => cause,
            ListAttachedPoliciesError::Throttling(ref cause) => cause,
            ListAttachedPoliciesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListAuditFindings
#[derive(Debug, PartialEq)]
pub enum ListAuditFindingsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListAuditFindingsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListAuditFindingsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListAuditFindingsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListAuditFindingsError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListAuditFindingsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListAuditFindingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuditFindingsError {
    fn description(&self) -> &str {
        match *self {
            ListAuditFindingsError::InternalFailure(ref cause) => cause,
            ListAuditFindingsError::InvalidRequest(ref cause) => cause,
            ListAuditFindingsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListAuditMitigationActionsExecutions
#[derive(Debug, PartialEq)]
pub enum ListAuditMitigationActionsExecutionsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListAuditMitigationActionsExecutionsError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListAuditMitigationActionsExecutionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ListAuditMitigationActionsExecutionsError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ListAuditMitigationActionsExecutionsError::InvalidRequest(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(
                        ListAuditMitigationActionsExecutionsError::Throttling(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListAuditMitigationActionsExecutionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuditMitigationActionsExecutionsError {
    fn description(&self) -> &str {
        match *self {
            ListAuditMitigationActionsExecutionsError::InternalFailure(ref cause) => cause,
            ListAuditMitigationActionsExecutionsError::InvalidRequest(ref cause) => cause,
            ListAuditMitigationActionsExecutionsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListAuditMitigationActionsTasks
#[derive(Debug, PartialEq)]
pub enum ListAuditMitigationActionsTasksError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListAuditMitigationActionsTasksError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListAuditMitigationActionsTasksError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ListAuditMitigationActionsTasksError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ListAuditMitigationActionsTasksError::InvalidRequest(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListAuditMitigationActionsTasksError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListAuditMitigationActionsTasksError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuditMitigationActionsTasksError {
    fn description(&self) -> &str {
        match *self {
            ListAuditMitigationActionsTasksError::InternalFailure(ref cause) => cause,
            ListAuditMitigationActionsTasksError::InvalidRequest(ref cause) => cause,
            ListAuditMitigationActionsTasksError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListAuditTasks
#[derive(Debug, PartialEq)]
pub enum ListAuditTasksError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListAuditTasksError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListAuditTasksError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListAuditTasksError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListAuditTasksError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListAuditTasksError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListAuditTasksError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuditTasksError {
    fn description(&self) -> &str {
        match *self {
            ListAuditTasksError::InternalFailure(ref cause) => cause,
            ListAuditTasksError::InvalidRequest(ref cause) => cause,
            ListAuditTasksError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListAuthorizers
#[derive(Debug, PartialEq)]
pub enum ListAuthorizersError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListAuthorizersError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListAuthorizersError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListAuthorizersError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListAuthorizersError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListAuthorizersError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListAuthorizersError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListAuthorizersError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListAuthorizersError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListAuthorizersError {
    fn description(&self) -> &str {
        match *self {
            ListAuthorizersError::InternalFailure(ref cause) => cause,
            ListAuthorizersError::InvalidRequest(ref cause) => cause,
            ListAuthorizersError::ServiceUnavailable(ref cause) => cause,
            ListAuthorizersError::Throttling(ref cause) => cause,
            ListAuthorizersError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListBillingGroups
#[derive(Debug, PartialEq)]
pub enum ListBillingGroupsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListBillingGroupsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListBillingGroupsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListBillingGroupsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListBillingGroupsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListBillingGroupsError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListBillingGroupsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListBillingGroupsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListBillingGroupsError {
    fn description(&self) -> &str {
        match *self {
            ListBillingGroupsError::InternalFailure(ref cause) => cause,
            ListBillingGroupsError::InvalidRequest(ref cause) => cause,
            ListBillingGroupsError::ResourceNotFound(ref cause) => cause,
            ListBillingGroupsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListCACertificates
#[derive(Debug, PartialEq)]
pub enum ListCACertificatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListCACertificatesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListCACertificatesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListCACertificatesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListCACertificatesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListCACertificatesError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListCACertificatesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListCACertificatesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListCACertificatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListCACertificatesError {
    fn description(&self) -> &str {
        match *self {
            ListCACertificatesError::InternalFailure(ref cause) => cause,
            ListCACertificatesError::InvalidRequest(ref cause) => cause,
            ListCACertificatesError::ServiceUnavailable(ref cause) => cause,
            ListCACertificatesError::Throttling(ref cause) => cause,
            ListCACertificatesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListCertificates
#[derive(Debug, PartialEq)]
pub enum ListCertificatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListCertificatesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListCertificatesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListCertificatesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListCertificatesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListCertificatesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListCertificatesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListCertificatesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListCertificatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListCertificatesError {
    fn description(&self) -> &str {
        match *self {
            ListCertificatesError::InternalFailure(ref cause) => cause,
            ListCertificatesError::InvalidRequest(ref cause) => cause,
            ListCertificatesError::ServiceUnavailable(ref cause) => cause,
            ListCertificatesError::Throttling(ref cause) => cause,
            ListCertificatesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListCertificatesByCA
#[derive(Debug, PartialEq)]
pub enum ListCertificatesByCAError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListCertificatesByCAError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListCertificatesByCAError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListCertificatesByCAError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListCertificatesByCAError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListCertificatesByCAError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListCertificatesByCAError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListCertificatesByCAError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListCertificatesByCAError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListCertificatesByCAError {
    fn description(&self) -> &str {
        match *self {
            ListCertificatesByCAError::InternalFailure(ref cause) => cause,
            ListCertificatesByCAError::InvalidRequest(ref cause) => cause,
            ListCertificatesByCAError::ServiceUnavailable(ref cause) => cause,
            ListCertificatesByCAError::Throttling(ref cause) => cause,
            ListCertificatesByCAError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListDomainConfigurations
#[derive(Debug, PartialEq)]
pub enum ListDomainConfigurationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListDomainConfigurationsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListDomainConfigurationsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListDomainConfigurationsError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListDomainConfigurationsError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListDomainConfigurationsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListDomainConfigurationsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListDomainConfigurationsError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListDomainConfigurationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListDomainConfigurationsError {
    fn description(&self) -> &str {
        match *self {
            ListDomainConfigurationsError::InternalFailure(ref cause) => cause,
            ListDomainConfigurationsError::InvalidRequest(ref cause) => cause,
            ListDomainConfigurationsError::ServiceUnavailable(ref cause) => cause,
            ListDomainConfigurationsError::Throttling(ref cause) => cause,
            ListDomainConfigurationsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListIndices
#[derive(Debug, PartialEq)]
pub enum ListIndicesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListIndicesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListIndicesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListIndicesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListIndicesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListIndicesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListIndicesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListIndicesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListIndicesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListIndicesError {
    fn description(&self) -> &str {
        match *self {
            ListIndicesError::InternalFailure(ref cause) => cause,
            ListIndicesError::InvalidRequest(ref cause) => cause,
            ListIndicesError::ServiceUnavailable(ref cause) => cause,
            ListIndicesError::Throttling(ref cause) => cause,
            ListIndicesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListJobExecutionsForJob
#[derive(Debug, PartialEq)]
pub enum ListJobExecutionsForJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListJobExecutionsForJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListJobExecutionsForJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(ListJobExecutionsForJobError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListJobExecutionsForJobError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListJobExecutionsForJobError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListJobExecutionsForJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListJobExecutionsForJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListJobExecutionsForJobError {
    fn description(&self) -> &str {
        match *self {
            ListJobExecutionsForJobError::InvalidRequest(ref cause) => cause,
            ListJobExecutionsForJobError::ResourceNotFound(ref cause) => cause,
            ListJobExecutionsForJobError::ServiceUnavailable(ref cause) => cause,
            ListJobExecutionsForJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListJobExecutionsForThing
#[derive(Debug, PartialEq)]
pub enum ListJobExecutionsForThingError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListJobExecutionsForThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListJobExecutionsForThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(ListJobExecutionsForThingError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListJobExecutionsForThingError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        ListJobExecutionsForThingError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListJobExecutionsForThingError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListJobExecutionsForThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListJobExecutionsForThingError {
    fn description(&self) -> &str {
        match *self {
            ListJobExecutionsForThingError::InvalidRequest(ref cause) => cause,
            ListJobExecutionsForThingError::ResourceNotFound(ref cause) => cause,
            ListJobExecutionsForThingError::ServiceUnavailable(ref cause) => cause,
            ListJobExecutionsForThingError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListJobs
#[derive(Debug, PartialEq)]
pub enum ListJobsError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListJobsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListJobsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(ListJobsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListJobsError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListJobsError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListJobsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListJobsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListJobsError {
    fn description(&self) -> &str {
        match *self {
            ListJobsError::InvalidRequest(ref cause) => cause,
            ListJobsError::ResourceNotFound(ref cause) => cause,
            ListJobsError::ServiceUnavailable(ref cause) => cause,
            ListJobsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListMitigationActions
#[derive(Debug, PartialEq)]
pub enum ListMitigationActionsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListMitigationActionsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListMitigationActionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListMitigationActionsError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListMitigationActionsError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListMitigationActionsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListMitigationActionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListMitigationActionsError {
    fn description(&self) -> &str {
        match *self {
            ListMitigationActionsError::InternalFailure(ref cause) => cause,
            ListMitigationActionsError::InvalidRequest(ref cause) => cause,
            ListMitigationActionsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListOTAUpdates
#[derive(Debug, PartialEq)]
pub enum ListOTAUpdatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListOTAUpdatesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListOTAUpdatesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListOTAUpdatesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListOTAUpdatesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListOTAUpdatesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListOTAUpdatesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListOTAUpdatesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListOTAUpdatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListOTAUpdatesError {
    fn description(&self) -> &str {
        match *self {
            ListOTAUpdatesError::InternalFailure(ref cause) => cause,
            ListOTAUpdatesError::InvalidRequest(ref cause) => cause,
            ListOTAUpdatesError::ServiceUnavailable(ref cause) => cause,
            ListOTAUpdatesError::Throttling(ref cause) => cause,
            ListOTAUpdatesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListOutgoingCertificates
#[derive(Debug, PartialEq)]
pub enum ListOutgoingCertificatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListOutgoingCertificatesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListOutgoingCertificatesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListOutgoingCertificatesError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListOutgoingCertificatesError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListOutgoingCertificatesError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListOutgoingCertificatesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListOutgoingCertificatesError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListOutgoingCertificatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListOutgoingCertificatesError {
    fn description(&self) -> &str {
        match *self {
            ListOutgoingCertificatesError::InternalFailure(ref cause) => cause,
            ListOutgoingCertificatesError::InvalidRequest(ref cause) => cause,
            ListOutgoingCertificatesError::ServiceUnavailable(ref cause) => cause,
            ListOutgoingCertificatesError::Throttling(ref cause) => cause,
            ListOutgoingCertificatesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListPolicies
#[derive(Debug, PartialEq)]
pub enum ListPoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListPoliciesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListPoliciesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListPoliciesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListPoliciesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListPoliciesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListPoliciesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListPoliciesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListPoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPoliciesError {
    fn description(&self) -> &str {
        match *self {
            ListPoliciesError::InternalFailure(ref cause) => cause,
            ListPoliciesError::InvalidRequest(ref cause) => cause,
            ListPoliciesError::ServiceUnavailable(ref cause) => cause,
            ListPoliciesError::Throttling(ref cause) => cause,
            ListPoliciesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListPolicyPrincipals
#[derive(Debug, PartialEq)]
pub enum ListPolicyPrincipalsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListPolicyPrincipalsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListPolicyPrincipalsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListPolicyPrincipalsError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListPolicyPrincipalsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListPolicyPrincipalsError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListPolicyPrincipalsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListPolicyPrincipalsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListPolicyPrincipalsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListPolicyPrincipalsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPolicyPrincipalsError {
    fn description(&self) -> &str {
        match *self {
            ListPolicyPrincipalsError::InternalFailure(ref cause) => cause,
            ListPolicyPrincipalsError::InvalidRequest(ref cause) => cause,
            ListPolicyPrincipalsError::ResourceNotFound(ref cause) => cause,
            ListPolicyPrincipalsError::ServiceUnavailable(ref cause) => cause,
            ListPolicyPrincipalsError::Throttling(ref cause) => cause,
            ListPolicyPrincipalsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListPolicyVersions
#[derive(Debug, PartialEq)]
pub enum ListPolicyVersionsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListPolicyVersionsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListPolicyVersionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListPolicyVersionsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListPolicyVersionsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListPolicyVersionsError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListPolicyVersionsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListPolicyVersionsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListPolicyVersionsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListPolicyVersionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPolicyVersionsError {
    fn description(&self) -> &str {
        match *self {
            ListPolicyVersionsError::InternalFailure(ref cause) => cause,
            ListPolicyVersionsError::InvalidRequest(ref cause) => cause,
            ListPolicyVersionsError::ResourceNotFound(ref cause) => cause,
            ListPolicyVersionsError::ServiceUnavailable(ref cause) => cause,
            ListPolicyVersionsError::Throttling(ref cause) => cause,
            ListPolicyVersionsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListPrincipalPolicies
#[derive(Debug, PartialEq)]
pub enum ListPrincipalPoliciesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListPrincipalPoliciesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListPrincipalPoliciesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListPrincipalPoliciesError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListPrincipalPoliciesError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListPrincipalPoliciesError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListPrincipalPoliciesError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListPrincipalPoliciesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListPrincipalPoliciesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListPrincipalPoliciesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPrincipalPoliciesError {
    fn description(&self) -> &str {
        match *self {
            ListPrincipalPoliciesError::InternalFailure(ref cause) => cause,
            ListPrincipalPoliciesError::InvalidRequest(ref cause) => cause,
            ListPrincipalPoliciesError::ResourceNotFound(ref cause) => cause,
            ListPrincipalPoliciesError::ServiceUnavailable(ref cause) => cause,
            ListPrincipalPoliciesError::Throttling(ref cause) => cause,
            ListPrincipalPoliciesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListPrincipalThings
#[derive(Debug, PartialEq)]
pub enum ListPrincipalThingsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListPrincipalThingsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListPrincipalThingsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListPrincipalThingsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListPrincipalThingsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListPrincipalThingsError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListPrincipalThingsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListPrincipalThingsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListPrincipalThingsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListPrincipalThingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListPrincipalThingsError {
    fn description(&self) -> &str {
        match *self {
            ListPrincipalThingsError::InternalFailure(ref cause) => cause,
            ListPrincipalThingsError::InvalidRequest(ref cause) => cause,
            ListPrincipalThingsError::ResourceNotFound(ref cause) => cause,
            ListPrincipalThingsError::ServiceUnavailable(ref cause) => cause,
            ListPrincipalThingsError::Throttling(ref cause) => cause,
            ListPrincipalThingsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListProvisioningTemplateVersions
#[derive(Debug, PartialEq)]
pub enum ListProvisioningTemplateVersionsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListProvisioningTemplateVersionsError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListProvisioningTemplateVersionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ListProvisioningTemplateVersionsError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ListProvisioningTemplateVersionsError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        ListProvisioningTemplateVersionsError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListProvisioningTemplateVersionsError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(
                        ListProvisioningTemplateVersionsError::Unauthorized(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListProvisioningTemplateVersionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListProvisioningTemplateVersionsError {
    fn description(&self) -> &str {
        match *self {
            ListProvisioningTemplateVersionsError::InternalFailure(ref cause) => cause,
            ListProvisioningTemplateVersionsError::InvalidRequest(ref cause) => cause,
            ListProvisioningTemplateVersionsError::ResourceNotFound(ref cause) => cause,
            ListProvisioningTemplateVersionsError::Throttling(ref cause) => cause,
            ListProvisioningTemplateVersionsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListProvisioningTemplates
#[derive(Debug, PartialEq)]
pub enum ListProvisioningTemplatesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListProvisioningTemplatesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListProvisioningTemplatesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListProvisioningTemplatesError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListProvisioningTemplatesError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListProvisioningTemplatesError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListProvisioningTemplatesError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListProvisioningTemplatesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListProvisioningTemplatesError {
    fn description(&self) -> &str {
        match *self {
            ListProvisioningTemplatesError::InternalFailure(ref cause) => cause,
            ListProvisioningTemplatesError::InvalidRequest(ref cause) => cause,
            ListProvisioningTemplatesError::Throttling(ref cause) => cause,
            ListProvisioningTemplatesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListRoleAliases
#[derive(Debug, PartialEq)]
pub enum ListRoleAliasesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListRoleAliasesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListRoleAliasesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListRoleAliasesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListRoleAliasesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListRoleAliasesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListRoleAliasesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListRoleAliasesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListRoleAliasesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListRoleAliasesError {
    fn description(&self) -> &str {
        match *self {
            ListRoleAliasesError::InternalFailure(ref cause) => cause,
            ListRoleAliasesError::InvalidRequest(ref cause) => cause,
            ListRoleAliasesError::ServiceUnavailable(ref cause) => cause,
            ListRoleAliasesError::Throttling(ref cause) => cause,
            ListRoleAliasesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListScheduledAudits
#[derive(Debug, PartialEq)]
pub enum ListScheduledAuditsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListScheduledAuditsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListScheduledAuditsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListScheduledAuditsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListScheduledAuditsError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListScheduledAuditsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListScheduledAuditsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListScheduledAuditsError {
    fn description(&self) -> &str {
        match *self {
            ListScheduledAuditsError::InternalFailure(ref cause) => cause,
            ListScheduledAuditsError::InvalidRequest(ref cause) => cause,
            ListScheduledAuditsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListSecurityProfiles
#[derive(Debug, PartialEq)]
pub enum ListSecurityProfilesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListSecurityProfilesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListSecurityProfilesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListSecurityProfilesError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListSecurityProfilesError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListSecurityProfilesError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListSecurityProfilesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListSecurityProfilesError {
    fn description(&self) -> &str {
        match *self {
            ListSecurityProfilesError::InternalFailure(ref cause) => cause,
            ListSecurityProfilesError::InvalidRequest(ref cause) => cause,
            ListSecurityProfilesError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListSecurityProfilesForTarget
#[derive(Debug, PartialEq)]
pub enum ListSecurityProfilesForTargetError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListSecurityProfilesForTargetError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListSecurityProfilesForTargetError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ListSecurityProfilesForTargetError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ListSecurityProfilesForTargetError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        ListSecurityProfilesForTargetError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListSecurityProfilesForTargetError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListSecurityProfilesForTargetError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListSecurityProfilesForTargetError {
    fn description(&self) -> &str {
        match *self {
            ListSecurityProfilesForTargetError::InternalFailure(ref cause) => cause,
            ListSecurityProfilesForTargetError::InvalidRequest(ref cause) => cause,
            ListSecurityProfilesForTargetError::ResourceNotFound(ref cause) => cause,
            ListSecurityProfilesForTargetError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListStreams
#[derive(Debug, PartialEq)]
pub enum ListStreamsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListStreamsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListStreamsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListStreamsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListStreamsError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListStreamsError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListStreamsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListStreamsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListStreamsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListStreamsError {
    fn description(&self) -> &str {
        match *self {
            ListStreamsError::InternalFailure(ref cause) => cause,
            ListStreamsError::InvalidRequest(ref cause) => cause,
            ListStreamsError::ServiceUnavailable(ref cause) => cause,
            ListStreamsError::Throttling(ref cause) => cause,
            ListStreamsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListTagsForResource
#[derive(Debug, PartialEq)]
pub enum ListTagsForResourceError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListTagsForResourceError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListTagsForResourceError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListTagsForResourceError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListTagsForResourceError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListTagsForResourceError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListTagsForResourceError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTagsForResourceError {
    fn description(&self) -> &str {
        match *self {
            ListTagsForResourceError::InternalFailure(ref cause) => cause,
            ListTagsForResourceError::InvalidRequest(ref cause) => cause,
            ListTagsForResourceError::ResourceNotFound(ref cause) => cause,
            ListTagsForResourceError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListTargetsForPolicy
#[derive(Debug, PartialEq)]
pub enum ListTargetsForPolicyError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListTargetsForPolicyError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListTargetsForPolicyError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListTargetsForPolicyError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListTargetsForPolicyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTargetsForPolicyError {
    fn description(&self) -> &str {
        match *self {
            ListTargetsForPolicyError::InternalFailure(ref cause) => cause,
            ListTargetsForPolicyError::InvalidRequest(ref cause) => cause,
            ListTargetsForPolicyError::LimitExceeded(ref cause) => cause,
            ListTargetsForPolicyError::ResourceNotFound(ref cause) => cause,
            ListTargetsForPolicyError::ServiceUnavailable(ref cause) => cause,
            ListTargetsForPolicyError::Throttling(ref cause) => cause,
            ListTargetsForPolicyError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListTargetsForSecurityProfile
#[derive(Debug, PartialEq)]
pub enum ListTargetsForSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListTargetsForSecurityProfileError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListTargetsForSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ListTargetsForSecurityProfileError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ListTargetsForSecurityProfileError::InvalidRequest(err.msg),
                    )
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        ListTargetsForSecurityProfileError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListTargetsForSecurityProfileError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListTargetsForSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTargetsForSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            ListTargetsForSecurityProfileError::InternalFailure(ref cause) => cause,
            ListTargetsForSecurityProfileError::InvalidRequest(ref cause) => cause,
            ListTargetsForSecurityProfileError::ResourceNotFound(ref cause) => cause,
            ListTargetsForSecurityProfileError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingGroups
#[derive(Debug, PartialEq)]
pub enum ListThingGroupsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
}

impl ListThingGroupsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingGroupsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingGroupsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingGroupsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListThingGroupsError::ResourceNotFound(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingGroupsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingGroupsError {
    fn description(&self) -> &str {
        match *self {
            ListThingGroupsError::InternalFailure(ref cause) => cause,
            ListThingGroupsError::InvalidRequest(ref cause) => cause,
            ListThingGroupsError::ResourceNotFound(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingGroupsForThing
#[derive(Debug, PartialEq)]
pub enum ListThingGroupsForThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
}

impl ListThingGroupsForThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingGroupsForThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingGroupsForThingError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingGroupsForThingError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListThingGroupsForThingError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingGroupsForThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingGroupsForThingError {
    fn description(&self) -> &str {
        match *self {
            ListThingGroupsForThingError::InternalFailure(ref cause) => cause,
            ListThingGroupsForThingError::InvalidRequest(ref cause) => cause,
            ListThingGroupsForThingError::ResourceNotFound(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingPrincipals
#[derive(Debug, PartialEq)]
pub enum ListThingPrincipalsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListThingPrincipalsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingPrincipalsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingPrincipalsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingPrincipalsError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListThingPrincipalsError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListThingPrincipalsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListThingPrincipalsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListThingPrincipalsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingPrincipalsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingPrincipalsError {
    fn description(&self) -> &str {
        match *self {
            ListThingPrincipalsError::InternalFailure(ref cause) => cause,
            ListThingPrincipalsError::InvalidRequest(ref cause) => cause,
            ListThingPrincipalsError::ResourceNotFound(ref cause) => cause,
            ListThingPrincipalsError::ServiceUnavailable(ref cause) => cause,
            ListThingPrincipalsError::Throttling(ref cause) => cause,
            ListThingPrincipalsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingRegistrationTaskReports
#[derive(Debug, PartialEq)]
pub enum ListThingRegistrationTaskReportsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListThingRegistrationTaskReportsError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListThingRegistrationTaskReportsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ListThingRegistrationTaskReportsError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ListThingRegistrationTaskReportsError::InvalidRequest(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListThingRegistrationTaskReportsError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(
                        ListThingRegistrationTaskReportsError::Unauthorized(err.msg),
                    )
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingRegistrationTaskReportsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingRegistrationTaskReportsError {
    fn description(&self) -> &str {
        match *self {
            ListThingRegistrationTaskReportsError::InternalFailure(ref cause) => cause,
            ListThingRegistrationTaskReportsError::InvalidRequest(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Throttling(ref cause) => cause,
            ListThingRegistrationTaskReportsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingRegistrationTasks
#[derive(Debug, PartialEq)]
pub enum ListThingRegistrationTasksError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListThingRegistrationTasksError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ListThingRegistrationTasksError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingRegistrationTasksError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingRegistrationTasksError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListThingRegistrationTasksError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListThingRegistrationTasksError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingRegistrationTasksError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingRegistrationTasksError {
    fn description(&self) -> &str {
        match *self {
            ListThingRegistrationTasksError::InternalFailure(ref cause) => cause,
            ListThingRegistrationTasksError::InvalidRequest(ref cause) => cause,
            ListThingRegistrationTasksError::Throttling(ref cause) => cause,
            ListThingRegistrationTasksError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingTypes
#[derive(Debug, PartialEq)]
pub enum ListThingTypesError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListThingTypesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingTypesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingTypesError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingTypesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListThingTypesError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListThingTypesError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListThingTypesError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingTypesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingTypesError {
    fn description(&self) -> &str {
        match *self {
            ListThingTypesError::InternalFailure(ref cause) => cause,
            ListThingTypesError::InvalidRequest(ref cause) => cause,
            ListThingTypesError::ServiceUnavailable(ref cause) => cause,
            ListThingTypesError::Throttling(ref cause) => cause,
            ListThingTypesError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThings
#[derive(Debug, PartialEq)]
pub enum ListThingsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListThingsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingsError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListThingsError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListThingsError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListThingsError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingsError {
    fn description(&self) -> &str {
        match *self {
            ListThingsError::InternalFailure(ref cause) => cause,
            ListThingsError::InvalidRequest(ref cause) => cause,
            ListThingsError::ServiceUnavailable(ref cause) => cause,
            ListThingsError::Throttling(ref cause) => cause,
            ListThingsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingsInBillingGroup
#[derive(Debug, PartialEq)]
pub enum ListThingsInBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListThingsInBillingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingsInBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingsInBillingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingsInBillingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListThingsInBillingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListThingsInBillingGroupError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingsInBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingsInBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            ListThingsInBillingGroupError::InternalFailure(ref cause) => cause,
            ListThingsInBillingGroupError::InvalidRequest(ref cause) => cause,
            ListThingsInBillingGroupError::ResourceNotFound(ref cause) => cause,
            ListThingsInBillingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ListThingsInThingGroup
#[derive(Debug, PartialEq)]
pub enum ListThingsInThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
}

impl ListThingsInThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListThingsInThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListThingsInThingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListThingsInThingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(ListThingsInThingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListThingsInThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListThingsInThingGroupError {
    fn description(&self) -> &str {
        match *self {
            ListThingsInThingGroupError::InternalFailure(ref cause) => cause,
            ListThingsInThingGroupError::InvalidRequest(ref cause) => cause,
            ListThingsInThingGroupError::ResourceNotFound(ref cause) => cause,
        }
    }
}
/// Errors returned by ListTopicRuleDestinations
#[derive(Debug, PartialEq)]
pub enum ListTopicRuleDestinationsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ListTopicRuleDestinationsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListTopicRuleDestinationsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(ListTopicRuleDestinationsError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListTopicRuleDestinationsError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        ListTopicRuleDestinationsError::ServiceUnavailable(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ListTopicRuleDestinationsError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListTopicRuleDestinationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTopicRuleDestinationsError {
    fn description(&self) -> &str {
        match *self {
            ListTopicRuleDestinationsError::Internal(ref cause) => cause,
            ListTopicRuleDestinationsError::InvalidRequest(ref cause) => cause,
            ListTopicRuleDestinationsError::ServiceUnavailable(ref cause) => cause,
            ListTopicRuleDestinationsError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ListTopicRules
#[derive(Debug, PartialEq)]
pub enum ListTopicRulesError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl ListTopicRulesError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListTopicRulesError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(ListTopicRulesError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListTopicRulesError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListTopicRulesError::ServiceUnavailable(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListTopicRulesError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListTopicRulesError {
    fn description(&self) -> &str {
        match *self {
            ListTopicRulesError::Internal(ref cause) => cause,
            ListTopicRulesError::InvalidRequest(ref cause) => cause,
            ListTopicRulesError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by ListV2LoggingLevels
#[derive(Debug, PartialEq)]
pub enum ListV2LoggingLevelsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource is not configured.</p>
    NotConfigured(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl ListV2LoggingLevelsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListV2LoggingLevelsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(ListV2LoggingLevelsError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListV2LoggingLevelsError::InvalidRequest(err.msg))
                }
                "NotConfiguredException" => {
                    return RusotoError::Service(ListV2LoggingLevelsError::NotConfigured(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ListV2LoggingLevelsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListV2LoggingLevelsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListV2LoggingLevelsError {
    fn description(&self) -> &str {
        match *self {
            ListV2LoggingLevelsError::Internal(ref cause) => cause,
            ListV2LoggingLevelsError::InvalidRequest(ref cause) => cause,
            ListV2LoggingLevelsError::NotConfigured(ref cause) => cause,
            ListV2LoggingLevelsError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by ListViolationEvents
#[derive(Debug, PartialEq)]
pub enum ListViolationEventsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ListViolationEventsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ListViolationEventsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(ListViolationEventsError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ListViolationEventsError::InvalidRequest(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ListViolationEventsError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ListViolationEventsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ListViolationEventsError {
    fn description(&self) -> &str {
        match *self {
            ListViolationEventsError::InternalFailure(ref cause) => cause,
            ListViolationEventsError::InvalidRequest(ref cause) => cause,
            ListViolationEventsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by RegisterCACertificate
#[derive(Debug, PartialEq)]
pub enum RegisterCACertificateError {
    /// <p>The certificate is invalid.</p>
    CertificateValidation(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The registration code is invalid.</p>
    RegistrationCodeValidation(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl RegisterCACertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<RegisterCACertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateValidationException" => {
                    return RusotoError::Service(RegisterCACertificateError::CertificateValidation(
                        err.msg,
                    ))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(RegisterCACertificateError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(RegisterCACertificateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(RegisterCACertificateError::LimitExceeded(err.msg))
                }
                "RegistrationCodeValidationException" => {
                    return RusotoError::Service(
                        RegisterCACertificateError::RegistrationCodeValidation(err.msg),
                    )
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(RegisterCACertificateError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(RegisterCACertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(RegisterCACertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(RegisterCACertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for RegisterCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RegisterCACertificateError {
    fn description(&self) -> &str {
        match *self {
            RegisterCACertificateError::CertificateValidation(ref cause) => cause,
            RegisterCACertificateError::InternalFailure(ref cause) => cause,
            RegisterCACertificateError::InvalidRequest(ref cause) => cause,
            RegisterCACertificateError::LimitExceeded(ref cause) => cause,
            RegisterCACertificateError::RegistrationCodeValidation(ref cause) => cause,
            RegisterCACertificateError::ResourceAlreadyExists(ref cause) => cause,
            RegisterCACertificateError::ServiceUnavailable(ref cause) => cause,
            RegisterCACertificateError::Throttling(ref cause) => cause,
            RegisterCACertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by RegisterCertificate
#[derive(Debug, PartialEq)]
pub enum RegisterCertificateError {
    /// <p>Unable to verify the CA certificate used to sign the device certificate you are attempting to register. This is happens when you have registered more than one CA certificate that has the same subject field and public key.</p>
    CertificateConflict(String),
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>The certificate is invalid.</p>
    CertificateValidation(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl RegisterCertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<RegisterCertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateConflictException" => {
                    return RusotoError::Service(RegisterCertificateError::CertificateConflict(
                        err.msg,
                    ))
                }
                "CertificateStateException" => {
                    return RusotoError::Service(RegisterCertificateError::CertificateState(
                        err.msg,
                    ))
                }
                "CertificateValidationException" => {
                    return RusotoError::Service(RegisterCertificateError::CertificateValidation(
                        err.msg,
                    ))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(RegisterCertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(RegisterCertificateError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(RegisterCertificateError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(RegisterCertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(RegisterCertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(RegisterCertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for RegisterCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RegisterCertificateError {
    fn description(&self) -> &str {
        match *self {
            RegisterCertificateError::CertificateConflict(ref cause) => cause,
            RegisterCertificateError::CertificateState(ref cause) => cause,
            RegisterCertificateError::CertificateValidation(ref cause) => cause,
            RegisterCertificateError::InternalFailure(ref cause) => cause,
            RegisterCertificateError::InvalidRequest(ref cause) => cause,
            RegisterCertificateError::ResourceAlreadyExists(ref cause) => cause,
            RegisterCertificateError::ServiceUnavailable(ref cause) => cause,
            RegisterCertificateError::Throttling(ref cause) => cause,
            RegisterCertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by RegisterThing
#[derive(Debug, PartialEq)]
pub enum RegisterThingError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource registration failed.</p>
    ResourceRegistrationFailure(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl RegisterThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<RegisterThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(RegisterThingError::ConflictingResourceUpdate(
                        err.msg,
                    ))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(RegisterThingError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(RegisterThingError::InvalidRequest(err.msg))
                }
                "ResourceRegistrationFailureException" => {
                    return RusotoError::Service(RegisterThingError::ResourceRegistrationFailure(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(RegisterThingError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(RegisterThingError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(RegisterThingError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for RegisterThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RegisterThingError {
    fn description(&self) -> &str {
        match *self {
            RegisterThingError::ConflictingResourceUpdate(ref cause) => cause,
            RegisterThingError::InternalFailure(ref cause) => cause,
            RegisterThingError::InvalidRequest(ref cause) => cause,
            RegisterThingError::ResourceRegistrationFailure(ref cause) => cause,
            RegisterThingError::ServiceUnavailable(ref cause) => cause,
            RegisterThingError::Throttling(ref cause) => cause,
            RegisterThingError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by RejectCertificateTransfer
#[derive(Debug, PartialEq)]
pub enum RejectCertificateTransferError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't revert the certificate transfer because the transfer is already complete.</p>
    TransferAlreadyCompleted(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl RejectCertificateTransferError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<RejectCertificateTransferError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(RejectCertificateTransferError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(RejectCertificateTransferError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(RejectCertificateTransferError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        RejectCertificateTransferError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(RejectCertificateTransferError::Throttling(
                        err.msg,
                    ))
                }
                "TransferAlreadyCompletedException" => {
                    return RusotoError::Service(
                        RejectCertificateTransferError::TransferAlreadyCompleted(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(RejectCertificateTransferError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for RejectCertificateTransferError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RejectCertificateTransferError {
    fn description(&self) -> &str {
        match *self {
            RejectCertificateTransferError::InternalFailure(ref cause) => cause,
            RejectCertificateTransferError::InvalidRequest(ref cause) => cause,
            RejectCertificateTransferError::ResourceNotFound(ref cause) => cause,
            RejectCertificateTransferError::ServiceUnavailable(ref cause) => cause,
            RejectCertificateTransferError::Throttling(ref cause) => cause,
            RejectCertificateTransferError::TransferAlreadyCompleted(ref cause) => cause,
            RejectCertificateTransferError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by RemoveThingFromBillingGroup
#[derive(Debug, PartialEq)]
pub enum RemoveThingFromBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl RemoveThingFromBillingGroupError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<RemoveThingFromBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(RemoveThingFromBillingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(RemoveThingFromBillingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(
                        RemoveThingFromBillingGroupError::ResourceNotFound(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(RemoveThingFromBillingGroupError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for RemoveThingFromBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RemoveThingFromBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            RemoveThingFromBillingGroupError::InternalFailure(ref cause) => cause,
            RemoveThingFromBillingGroupError::InvalidRequest(ref cause) => cause,
            RemoveThingFromBillingGroupError::ResourceNotFound(ref cause) => cause,
            RemoveThingFromBillingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by RemoveThingFromThingGroup
#[derive(Debug, PartialEq)]
pub enum RemoveThingFromThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl RemoveThingFromThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<RemoveThingFromThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(RemoveThingFromThingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(RemoveThingFromThingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(RemoveThingFromThingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(RemoveThingFromThingGroupError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for RemoveThingFromThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for RemoveThingFromThingGroupError {
    fn description(&self) -> &str {
        match *self {
            RemoveThingFromThingGroupError::InternalFailure(ref cause) => cause,
            RemoveThingFromThingGroupError::InvalidRequest(ref cause) => cause,
            RemoveThingFromThingGroupError::ResourceNotFound(ref cause) => cause,
            RemoveThingFromThingGroupError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by ReplaceTopicRule
#[derive(Debug, PartialEq)]
pub enum ReplaceTopicRuleError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The Rule-SQL expression can't be parsed correctly.</p>
    SqlParse(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl ReplaceTopicRuleError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<ReplaceTopicRuleError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(ReplaceTopicRuleError::ConflictingResourceUpdate(
                        err.msg,
                    ))
                }
                "InternalException" => {
                    return RusotoError::Service(ReplaceTopicRuleError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(ReplaceTopicRuleError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(ReplaceTopicRuleError::ServiceUnavailable(err.msg))
                }
                "SqlParseException" => {
                    return RusotoError::Service(ReplaceTopicRuleError::SqlParse(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(ReplaceTopicRuleError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ReplaceTopicRuleError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ReplaceTopicRuleError {
    fn description(&self) -> &str {
        match *self {
            ReplaceTopicRuleError::ConflictingResourceUpdate(ref cause) => cause,
            ReplaceTopicRuleError::Internal(ref cause) => cause,
            ReplaceTopicRuleError::InvalidRequest(ref cause) => cause,
            ReplaceTopicRuleError::ServiceUnavailable(ref cause) => cause,
            ReplaceTopicRuleError::SqlParse(ref cause) => cause,
            ReplaceTopicRuleError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by SearchIndex
#[derive(Debug, PartialEq)]
pub enum SearchIndexError {
    /// <p>The index is not ready.</p>
    IndexNotReady(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl SearchIndexError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<SearchIndexError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "IndexNotReadyException" => {
                    return RusotoError::Service(SearchIndexError::IndexNotReady(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(SearchIndexError::InternalFailure(err.msg))
                }
                "InvalidQueryException" => {
                    return RusotoError::Service(SearchIndexError::InvalidQuery(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(SearchIndexError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(SearchIndexError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(SearchIndexError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(SearchIndexError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(SearchIndexError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for SearchIndexError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SearchIndexError {
    fn description(&self) -> &str {
        match *self {
            SearchIndexError::IndexNotReady(ref cause) => cause,
            SearchIndexError::InternalFailure(ref cause) => cause,
            SearchIndexError::InvalidQuery(ref cause) => cause,
            SearchIndexError::InvalidRequest(ref cause) => cause,
            SearchIndexError::ResourceNotFound(ref cause) => cause,
            SearchIndexError::ServiceUnavailable(ref cause) => cause,
            SearchIndexError::Throttling(ref cause) => cause,
            SearchIndexError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by SetDefaultAuthorizer
#[derive(Debug, PartialEq)]
pub enum SetDefaultAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource already exists.</p>
    ResourceAlreadyExists(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl SetDefaultAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<SetDefaultAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::InvalidRequest(err.msg))
                }
                "ResourceAlreadyExistsException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::ResourceAlreadyExists(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(SetDefaultAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for SetDefaultAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetDefaultAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            SetDefaultAuthorizerError::InternalFailure(ref cause) => cause,
            SetDefaultAuthorizerError::InvalidRequest(ref cause) => cause,
            SetDefaultAuthorizerError::ResourceAlreadyExists(ref cause) => cause,
            SetDefaultAuthorizerError::ResourceNotFound(ref cause) => cause,
            SetDefaultAuthorizerError::ServiceUnavailable(ref cause) => cause,
            SetDefaultAuthorizerError::Throttling(ref cause) => cause,
            SetDefaultAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by SetDefaultPolicyVersion
#[derive(Debug, PartialEq)]
pub enum SetDefaultPolicyVersionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl SetDefaultPolicyVersionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<SetDefaultPolicyVersionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(SetDefaultPolicyVersionError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(SetDefaultPolicyVersionError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(SetDefaultPolicyVersionError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(SetDefaultPolicyVersionError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(SetDefaultPolicyVersionError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(SetDefaultPolicyVersionError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for SetDefaultPolicyVersionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetDefaultPolicyVersionError {
    fn description(&self) -> &str {
        match *self {
            SetDefaultPolicyVersionError::InternalFailure(ref cause) => cause,
            SetDefaultPolicyVersionError::InvalidRequest(ref cause) => cause,
            SetDefaultPolicyVersionError::ResourceNotFound(ref cause) => cause,
            SetDefaultPolicyVersionError::ServiceUnavailable(ref cause) => cause,
            SetDefaultPolicyVersionError::Throttling(ref cause) => cause,
            SetDefaultPolicyVersionError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by SetLoggingOptions
#[derive(Debug, PartialEq)]
pub enum SetLoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl SetLoggingOptionsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<SetLoggingOptionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(SetLoggingOptionsError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(SetLoggingOptionsError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(SetLoggingOptionsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for SetLoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetLoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            SetLoggingOptionsError::Internal(ref cause) => cause,
            SetLoggingOptionsError::InvalidRequest(ref cause) => cause,
            SetLoggingOptionsError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by SetV2LoggingLevel
#[derive(Debug, PartialEq)]
pub enum SetV2LoggingLevelError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The resource is not configured.</p>
    NotConfigured(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl SetV2LoggingLevelError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<SetV2LoggingLevelError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(SetV2LoggingLevelError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(SetV2LoggingLevelError::InvalidRequest(err.msg))
                }
                "NotConfiguredException" => {
                    return RusotoError::Service(SetV2LoggingLevelError::NotConfigured(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(SetV2LoggingLevelError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for SetV2LoggingLevelError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetV2LoggingLevelError {
    fn description(&self) -> &str {
        match *self {
            SetV2LoggingLevelError::Internal(ref cause) => cause,
            SetV2LoggingLevelError::InvalidRequest(ref cause) => cause,
            SetV2LoggingLevelError::NotConfigured(ref cause) => cause,
            SetV2LoggingLevelError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by SetV2LoggingOptions
#[derive(Debug, PartialEq)]
pub enum SetV2LoggingOptionsError {
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
}

impl SetV2LoggingOptionsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<SetV2LoggingOptionsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalException" => {
                    return RusotoError::Service(SetV2LoggingOptionsError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(SetV2LoggingOptionsError::InvalidRequest(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(SetV2LoggingOptionsError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for SetV2LoggingOptionsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for SetV2LoggingOptionsError {
    fn description(&self) -> &str {
        match *self {
            SetV2LoggingOptionsError::Internal(ref cause) => cause,
            SetV2LoggingOptionsError::InvalidRequest(ref cause) => cause,
            SetV2LoggingOptionsError::ServiceUnavailable(ref cause) => cause,
        }
    }
}
/// Errors returned by StartAuditMitigationActionsTask
#[derive(Debug, PartialEq)]
pub enum StartAuditMitigationActionsTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>This exception occurs if you attempt to start a task with the same task-id as an existing task but with a different clientRequestToken.</p>
    TaskAlreadyExists(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl StartAuditMitigationActionsTaskError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<StartAuditMitigationActionsTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        StartAuditMitigationActionsTaskError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        StartAuditMitigationActionsTaskError::InvalidRequest(err.msg),
                    )
                }
                "LimitExceededException" => {
                    return RusotoError::Service(
                        StartAuditMitigationActionsTaskError::LimitExceeded(err.msg),
                    )
                }
                "TaskAlreadyExistsException" => {
                    return RusotoError::Service(
                        StartAuditMitigationActionsTaskError::TaskAlreadyExists(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(StartAuditMitigationActionsTaskError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for StartAuditMitigationActionsTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StartAuditMitigationActionsTaskError {
    fn description(&self) -> &str {
        match *self {
            StartAuditMitigationActionsTaskError::InternalFailure(ref cause) => cause,
            StartAuditMitigationActionsTaskError::InvalidRequest(ref cause) => cause,
            StartAuditMitigationActionsTaskError::LimitExceeded(ref cause) => cause,
            StartAuditMitigationActionsTaskError::TaskAlreadyExists(ref cause) => cause,
            StartAuditMitigationActionsTaskError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by StartOnDemandAuditTask
#[derive(Debug, PartialEq)]
pub enum StartOnDemandAuditTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl StartOnDemandAuditTaskError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<StartOnDemandAuditTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(StartOnDemandAuditTaskError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(StartOnDemandAuditTaskError::InvalidRequest(
                        err.msg,
                    ))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(StartOnDemandAuditTaskError::LimitExceeded(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(StartOnDemandAuditTaskError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for StartOnDemandAuditTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StartOnDemandAuditTaskError {
    fn description(&self) -> &str {
        match *self {
            StartOnDemandAuditTaskError::InternalFailure(ref cause) => cause,
            StartOnDemandAuditTaskError::InvalidRequest(ref cause) => cause,
            StartOnDemandAuditTaskError::LimitExceeded(ref cause) => cause,
            StartOnDemandAuditTaskError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by StartThingRegistrationTask
#[derive(Debug, PartialEq)]
pub enum StartThingRegistrationTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl StartThingRegistrationTaskError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<StartThingRegistrationTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(StartThingRegistrationTaskError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(StartThingRegistrationTaskError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(StartThingRegistrationTaskError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(StartThingRegistrationTaskError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for StartThingRegistrationTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StartThingRegistrationTaskError {
    fn description(&self) -> &str {
        match *self {
            StartThingRegistrationTaskError::InternalFailure(ref cause) => cause,
            StartThingRegistrationTaskError::InvalidRequest(ref cause) => cause,
            StartThingRegistrationTaskError::Throttling(ref cause) => cause,
            StartThingRegistrationTaskError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by StopThingRegistrationTask
#[derive(Debug, PartialEq)]
pub enum StopThingRegistrationTaskError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl StopThingRegistrationTaskError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<StopThingRegistrationTaskError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(StopThingRegistrationTaskError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(StopThingRegistrationTaskError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(StopThingRegistrationTaskError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(StopThingRegistrationTaskError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(StopThingRegistrationTaskError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for StopThingRegistrationTaskError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for StopThingRegistrationTaskError {
    fn description(&self) -> &str {
        match *self {
            StopThingRegistrationTaskError::InternalFailure(ref cause) => cause,
            StopThingRegistrationTaskError::InvalidRequest(ref cause) => cause,
            StopThingRegistrationTaskError::ResourceNotFound(ref cause) => cause,
            StopThingRegistrationTaskError::Throttling(ref cause) => cause,
            StopThingRegistrationTaskError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by TagResource
#[derive(Debug, PartialEq)]
pub enum TagResourceError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl TagResourceError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<TagResourceError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(TagResourceError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(TagResourceError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(TagResourceError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(TagResourceError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(TagResourceError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TagResourceError {
    fn description(&self) -> &str {
        match *self {
            TagResourceError::InternalFailure(ref cause) => cause,
            TagResourceError::InvalidRequest(ref cause) => cause,
            TagResourceError::LimitExceeded(ref cause) => cause,
            TagResourceError::ResourceNotFound(ref cause) => cause,
            TagResourceError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by TestAuthorization
#[derive(Debug, PartialEq)]
pub enum TestAuthorizationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl TestAuthorizationError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<TestAuthorizationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(TestAuthorizationError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(TestAuthorizationError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(TestAuthorizationError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(TestAuthorizationError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(TestAuthorizationError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(TestAuthorizationError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(TestAuthorizationError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for TestAuthorizationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TestAuthorizationError {
    fn description(&self) -> &str {
        match *self {
            TestAuthorizationError::InternalFailure(ref cause) => cause,
            TestAuthorizationError::InvalidRequest(ref cause) => cause,
            TestAuthorizationError::LimitExceeded(ref cause) => cause,
            TestAuthorizationError::ResourceNotFound(ref cause) => cause,
            TestAuthorizationError::ServiceUnavailable(ref cause) => cause,
            TestAuthorizationError::Throttling(ref cause) => cause,
            TestAuthorizationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by TestInvokeAuthorizer
#[derive(Debug, PartialEq)]
pub enum TestInvokeAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The response is invalid.</p>
    InvalidResponse(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl TestInvokeAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<TestInvokeAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::InvalidRequest(err.msg))
                }
                "InvalidResponseException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::InvalidResponse(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(TestInvokeAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for TestInvokeAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TestInvokeAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            TestInvokeAuthorizerError::InternalFailure(ref cause) => cause,
            TestInvokeAuthorizerError::InvalidRequest(ref cause) => cause,
            TestInvokeAuthorizerError::InvalidResponse(ref cause) => cause,
            TestInvokeAuthorizerError::ResourceNotFound(ref cause) => cause,
            TestInvokeAuthorizerError::ServiceUnavailable(ref cause) => cause,
            TestInvokeAuthorizerError::Throttling(ref cause) => cause,
            TestInvokeAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by TransferCertificate
#[derive(Debug, PartialEq)]
pub enum TransferCertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You can't transfer the certificate because authorization policies are still attached.</p>
    TransferConflict(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl TransferCertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<TransferCertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateStateException" => {
                    return RusotoError::Service(TransferCertificateError::CertificateState(
                        err.msg,
                    ))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(TransferCertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(TransferCertificateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(TransferCertificateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(TransferCertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(TransferCertificateError::Throttling(err.msg))
                }
                "TransferConflictException" => {
                    return RusotoError::Service(TransferCertificateError::TransferConflict(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(TransferCertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for TransferCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for TransferCertificateError {
    fn description(&self) -> &str {
        match *self {
            TransferCertificateError::CertificateState(ref cause) => cause,
            TransferCertificateError::InternalFailure(ref cause) => cause,
            TransferCertificateError::InvalidRequest(ref cause) => cause,
            TransferCertificateError::ResourceNotFound(ref cause) => cause,
            TransferCertificateError::ServiceUnavailable(ref cause) => cause,
            TransferCertificateError::Throttling(ref cause) => cause,
            TransferCertificateError::TransferConflict(ref cause) => cause,
            TransferCertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UntagResource
#[derive(Debug, PartialEq)]
pub enum UntagResourceError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UntagResourceError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UntagResourceError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UntagResourceError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UntagResourceError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UntagResourceError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UntagResourceError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UntagResourceError {
    fn description(&self) -> &str {
        match *self {
            UntagResourceError::InternalFailure(ref cause) => cause,
            UntagResourceError::InvalidRequest(ref cause) => cause,
            UntagResourceError::ResourceNotFound(ref cause) => cause,
            UntagResourceError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateAccountAuditConfiguration
#[derive(Debug, PartialEq)]
pub enum UpdateAccountAuditConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UpdateAccountAuditConfigurationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<UpdateAccountAuditConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        UpdateAccountAuditConfigurationError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        UpdateAccountAuditConfigurationError::InvalidRequest(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateAccountAuditConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateAccountAuditConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateAccountAuditConfigurationError {
    fn description(&self) -> &str {
        match *self {
            UpdateAccountAuditConfigurationError::InternalFailure(ref cause) => cause,
            UpdateAccountAuditConfigurationError::InvalidRequest(ref cause) => cause,
            UpdateAccountAuditConfigurationError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateAuthorizer
#[derive(Debug, PartialEq)]
pub enum UpdateAuthorizerError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>A limit has been exceeded.</p>
    LimitExceeded(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateAuthorizerError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateAuthorizerError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateAuthorizerError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateAuthorizerError::InvalidRequest(err.msg))
                }
                "LimitExceededException" => {
                    return RusotoError::Service(UpdateAuthorizerError::LimitExceeded(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateAuthorizerError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateAuthorizerError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateAuthorizerError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateAuthorizerError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateAuthorizerError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateAuthorizerError {
    fn description(&self) -> &str {
        match *self {
            UpdateAuthorizerError::InternalFailure(ref cause) => cause,
            UpdateAuthorizerError::InvalidRequest(ref cause) => cause,
            UpdateAuthorizerError::LimitExceeded(ref cause) => cause,
            UpdateAuthorizerError::ResourceNotFound(ref cause) => cause,
            UpdateAuthorizerError::ServiceUnavailable(ref cause) => cause,
            UpdateAuthorizerError::Throttling(ref cause) => cause,
            UpdateAuthorizerError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateBillingGroup
#[derive(Debug, PartialEq)]
pub enum UpdateBillingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl UpdateBillingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateBillingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateBillingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateBillingGroupError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateBillingGroupError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateBillingGroupError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(UpdateBillingGroupError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateBillingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateBillingGroupError {
    fn description(&self) -> &str {
        match *self {
            UpdateBillingGroupError::InternalFailure(ref cause) => cause,
            UpdateBillingGroupError::InvalidRequest(ref cause) => cause,
            UpdateBillingGroupError::ResourceNotFound(ref cause) => cause,
            UpdateBillingGroupError::Throttling(ref cause) => cause,
            UpdateBillingGroupError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateCACertificate
#[derive(Debug, PartialEq)]
pub enum UpdateCACertificateError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateCACertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateCACertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateCACertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateCACertificateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateCACertificateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateCACertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateCACertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateCACertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateCACertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateCACertificateError {
    fn description(&self) -> &str {
        match *self {
            UpdateCACertificateError::InternalFailure(ref cause) => cause,
            UpdateCACertificateError::InvalidRequest(ref cause) => cause,
            UpdateCACertificateError::ResourceNotFound(ref cause) => cause,
            UpdateCACertificateError::ServiceUnavailable(ref cause) => cause,
            UpdateCACertificateError::Throttling(ref cause) => cause,
            UpdateCACertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateCertificate
#[derive(Debug, PartialEq)]
pub enum UpdateCertificateError {
    /// <p>The certificate operation is not allowed.</p>
    CertificateState(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateCertificateError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateCertificateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateStateException" => {
                    return RusotoError::Service(UpdateCertificateError::CertificateState(err.msg))
                }
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateCertificateError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateCertificateError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateCertificateError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateCertificateError::ServiceUnavailable(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateCertificateError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateCertificateError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateCertificateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateCertificateError {
    fn description(&self) -> &str {
        match *self {
            UpdateCertificateError::CertificateState(ref cause) => cause,
            UpdateCertificateError::InternalFailure(ref cause) => cause,
            UpdateCertificateError::InvalidRequest(ref cause) => cause,
            UpdateCertificateError::ResourceNotFound(ref cause) => cause,
            UpdateCertificateError::ServiceUnavailable(ref cause) => cause,
            UpdateCertificateError::Throttling(ref cause) => cause,
            UpdateCertificateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateDomainConfiguration
#[derive(Debug, PartialEq)]
pub enum UpdateDomainConfigurationError {
    /// <p>The certificate is invalid.</p>
    CertificateValidation(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateDomainConfigurationError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateDomainConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "CertificateValidationException" => {
                    return RusotoError::Service(
                        UpdateDomainConfigurationError::CertificateValidation(err.msg),
                    )
                }
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateDomainConfigurationError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateDomainConfigurationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateDomainConfigurationError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        UpdateDomainConfigurationError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateDomainConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateDomainConfigurationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateDomainConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateDomainConfigurationError {
    fn description(&self) -> &str {
        match *self {
            UpdateDomainConfigurationError::CertificateValidation(ref cause) => cause,
            UpdateDomainConfigurationError::InternalFailure(ref cause) => cause,
            UpdateDomainConfigurationError::InvalidRequest(ref cause) => cause,
            UpdateDomainConfigurationError::ResourceNotFound(ref cause) => cause,
            UpdateDomainConfigurationError::ServiceUnavailable(ref cause) => cause,
            UpdateDomainConfigurationError::Throttling(ref cause) => cause,
            UpdateDomainConfigurationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateDynamicThingGroup
#[derive(Debug, PartialEq)]
pub enum UpdateDynamicThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The query is invalid.</p>
    InvalidQuery(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl UpdateDynamicThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateDynamicThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateDynamicThingGroupError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidQueryException" => {
                    return RusotoError::Service(UpdateDynamicThingGroupError::InvalidQuery(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateDynamicThingGroupError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateDynamicThingGroupError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateDynamicThingGroupError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(UpdateDynamicThingGroupError::VersionConflict(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateDynamicThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateDynamicThingGroupError {
    fn description(&self) -> &str {
        match *self {
            UpdateDynamicThingGroupError::InternalFailure(ref cause) => cause,
            UpdateDynamicThingGroupError::InvalidQuery(ref cause) => cause,
            UpdateDynamicThingGroupError::InvalidRequest(ref cause) => cause,
            UpdateDynamicThingGroupError::ResourceNotFound(ref cause) => cause,
            UpdateDynamicThingGroupError::Throttling(ref cause) => cause,
            UpdateDynamicThingGroupError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateEventConfigurations
#[derive(Debug, PartialEq)]
pub enum UpdateEventConfigurationsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UpdateEventConfigurationsError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateEventConfigurationsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateEventConfigurationsError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateEventConfigurationsError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateEventConfigurationsError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateEventConfigurationsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateEventConfigurationsError {
    fn description(&self) -> &str {
        match *self {
            UpdateEventConfigurationsError::InternalFailure(ref cause) => cause,
            UpdateEventConfigurationsError::InvalidRequest(ref cause) => cause,
            UpdateEventConfigurationsError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateIndexingConfiguration
#[derive(Debug, PartialEq)]
pub enum UpdateIndexingConfigurationError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateIndexingConfigurationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<UpdateIndexingConfigurationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateIndexingConfigurationError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateIndexingConfigurationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        UpdateIndexingConfigurationError::ServiceUnavailable(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateIndexingConfigurationError::Throttling(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateIndexingConfigurationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateIndexingConfigurationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateIndexingConfigurationError {
    fn description(&self) -> &str {
        match *self {
            UpdateIndexingConfigurationError::InternalFailure(ref cause) => cause,
            UpdateIndexingConfigurationError::InvalidRequest(ref cause) => cause,
            UpdateIndexingConfigurationError::ServiceUnavailable(ref cause) => cause,
            UpdateIndexingConfigurationError::Throttling(ref cause) => cause,
            UpdateIndexingConfigurationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateJob
#[derive(Debug, PartialEq)]
pub enum UpdateJobError {
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UpdateJobError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateJobError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateJobError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateJobError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateJobError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateJobError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateJobError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateJobError {
    fn description(&self) -> &str {
        match *self {
            UpdateJobError::InvalidRequest(ref cause) => cause,
            UpdateJobError::ResourceNotFound(ref cause) => cause,
            UpdateJobError::ServiceUnavailable(ref cause) => cause,
            UpdateJobError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateMitigationAction
#[derive(Debug, PartialEq)]
pub enum UpdateMitigationActionError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UpdateMitigationActionError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateMitigationActionError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateMitigationActionError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateMitigationActionError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateMitigationActionError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateMitigationActionError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateMitigationActionError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateMitigationActionError {
    fn description(&self) -> &str {
        match *self {
            UpdateMitigationActionError::InternalFailure(ref cause) => cause,
            UpdateMitigationActionError::InvalidRequest(ref cause) => cause,
            UpdateMitigationActionError::ResourceNotFound(ref cause) => cause,
            UpdateMitigationActionError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateProvisioningTemplate
#[derive(Debug, PartialEq)]
pub enum UpdateProvisioningTemplateError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateProvisioningTemplateError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<UpdateProvisioningTemplateError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(
                        UpdateProvisioningTemplateError::ConflictingResourceUpdate(err.msg),
                    )
                }
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateProvisioningTemplateError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateProvisioningTemplateError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateProvisioningTemplateError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateProvisioningTemplateError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateProvisioningTemplateError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateProvisioningTemplateError {
    fn description(&self) -> &str {
        match *self {
            UpdateProvisioningTemplateError::ConflictingResourceUpdate(ref cause) => cause,
            UpdateProvisioningTemplateError::InternalFailure(ref cause) => cause,
            UpdateProvisioningTemplateError::InvalidRequest(ref cause) => cause,
            UpdateProvisioningTemplateError::ResourceNotFound(ref cause) => cause,
            UpdateProvisioningTemplateError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateRoleAlias
#[derive(Debug, PartialEq)]
pub enum UpdateRoleAliasError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateRoleAliasError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateRoleAliasError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateRoleAliasError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateRoleAliasError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateRoleAliasError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateRoleAliasError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateRoleAliasError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateRoleAliasError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateRoleAliasError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateRoleAliasError {
    fn description(&self) -> &str {
        match *self {
            UpdateRoleAliasError::InternalFailure(ref cause) => cause,
            UpdateRoleAliasError::InvalidRequest(ref cause) => cause,
            UpdateRoleAliasError::ResourceNotFound(ref cause) => cause,
            UpdateRoleAliasError::ServiceUnavailable(ref cause) => cause,
            UpdateRoleAliasError::Throttling(ref cause) => cause,
            UpdateRoleAliasError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateScheduledAudit
#[derive(Debug, PartialEq)]
pub enum UpdateScheduledAuditError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UpdateScheduledAuditError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateScheduledAuditError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateScheduledAuditError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateScheduledAuditError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateScheduledAuditError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateScheduledAuditError::Throttling(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateScheduledAuditError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateScheduledAuditError {
    fn description(&self) -> &str {
        match *self {
            UpdateScheduledAuditError::InternalFailure(ref cause) => cause,
            UpdateScheduledAuditError::InvalidRequest(ref cause) => cause,
            UpdateScheduledAuditError::ResourceNotFound(ref cause) => cause,
            UpdateScheduledAuditError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateSecurityProfile
#[derive(Debug, PartialEq)]
pub enum UpdateSecurityProfileError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl UpdateSecurityProfileError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateSecurityProfileError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateSecurityProfileError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateSecurityProfileError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateSecurityProfileError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateSecurityProfileError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(UpdateSecurityProfileError::VersionConflict(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateSecurityProfileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateSecurityProfileError {
    fn description(&self) -> &str {
        match *self {
            UpdateSecurityProfileError::InternalFailure(ref cause) => cause,
            UpdateSecurityProfileError::InvalidRequest(ref cause) => cause,
            UpdateSecurityProfileError::ResourceNotFound(ref cause) => cause,
            UpdateSecurityProfileError::Throttling(ref cause) => cause,
            UpdateSecurityProfileError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateStream
#[derive(Debug, PartialEq)]
pub enum UpdateStreamError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateStreamError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateStreamError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateStreamError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateStreamError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateStreamError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateStreamError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateStreamError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateStreamError::Unauthorized(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateStreamError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateStreamError {
    fn description(&self) -> &str {
        match *self {
            UpdateStreamError::InternalFailure(ref cause) => cause,
            UpdateStreamError::InvalidRequest(ref cause) => cause,
            UpdateStreamError::ResourceNotFound(ref cause) => cause,
            UpdateStreamError::ServiceUnavailable(ref cause) => cause,
            UpdateStreamError::Throttling(ref cause) => cause,
            UpdateStreamError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateThing
#[derive(Debug, PartialEq)]
pub enum UpdateThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl UpdateThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateThingError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateThingError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateThingError::ResourceNotFound(err.msg))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(UpdateThingError::ServiceUnavailable(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateThingError::Throttling(err.msg))
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateThingError::Unauthorized(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(UpdateThingError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateThingError {
    fn description(&self) -> &str {
        match *self {
            UpdateThingError::InternalFailure(ref cause) => cause,
            UpdateThingError::InvalidRequest(ref cause) => cause,
            UpdateThingError::ResourceNotFound(ref cause) => cause,
            UpdateThingError::ServiceUnavailable(ref cause) => cause,
            UpdateThingError::Throttling(ref cause) => cause,
            UpdateThingError::Unauthorized(ref cause) => cause,
            UpdateThingError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateThingGroup
#[derive(Debug, PartialEq)]
pub enum UpdateThingGroupError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
    /// <p>An exception thrown when the version of an entity specified with the <code>expectedVersion</code> parameter does not match the latest version in the system.</p>
    VersionConflict(String),
}

impl UpdateThingGroupError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateThingGroupError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateThingGroupError::InternalFailure(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateThingGroupError::InvalidRequest(err.msg))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateThingGroupError::ResourceNotFound(err.msg))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateThingGroupError::Throttling(err.msg))
                }
                "VersionConflictException" => {
                    return RusotoError::Service(UpdateThingGroupError::VersionConflict(err.msg))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateThingGroupError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateThingGroupError {
    fn description(&self) -> &str {
        match *self {
            UpdateThingGroupError::InternalFailure(ref cause) => cause,
            UpdateThingGroupError::InvalidRequest(ref cause) => cause,
            UpdateThingGroupError::ResourceNotFound(ref cause) => cause,
            UpdateThingGroupError::Throttling(ref cause) => cause,
            UpdateThingGroupError::VersionConflict(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateThingGroupsForThing
#[derive(Debug, PartialEq)]
pub enum UpdateThingGroupsForThingError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The specified resource does not exist.</p>
    ResourceNotFound(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl UpdateThingGroupsForThingError {
    pub fn from_response(res: BufferedHttpResponse) -> RusotoError<UpdateThingGroupsForThingError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(UpdateThingGroupsForThingError::InternalFailure(
                        err.msg,
                    ))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateThingGroupsForThingError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ResourceNotFoundException" => {
                    return RusotoError::Service(UpdateThingGroupsForThingError::ResourceNotFound(
                        err.msg,
                    ))
                }
                "ThrottlingException" => {
                    return RusotoError::Service(UpdateThingGroupsForThingError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateThingGroupsForThingError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateThingGroupsForThingError {
    fn description(&self) -> &str {
        match *self {
            UpdateThingGroupsForThingError::InternalFailure(ref cause) => cause,
            UpdateThingGroupsForThingError::InvalidRequest(ref cause) => cause,
            UpdateThingGroupsForThingError::ResourceNotFound(ref cause) => cause,
            UpdateThingGroupsForThingError::Throttling(ref cause) => cause,
        }
    }
}
/// Errors returned by UpdateTopicRuleDestination
#[derive(Debug, PartialEq)]
pub enum UpdateTopicRuleDestinationError {
    /// <p>A conflicting resource update exception. This exception is thrown when two pending updates cause a conflict.</p>
    ConflictingResourceUpdate(String),
    /// <p>An unexpected error has occurred.</p>
    Internal(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The service is temporarily unavailable.</p>
    ServiceUnavailable(String),
    /// <p>You are not authorized to perform this operation.</p>
    Unauthorized(String),
}

impl UpdateTopicRuleDestinationError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<UpdateTopicRuleDestinationError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "ConflictingResourceUpdateException" => {
                    return RusotoError::Service(
                        UpdateTopicRuleDestinationError::ConflictingResourceUpdate(err.msg),
                    )
                }
                "InternalException" => {
                    return RusotoError::Service(UpdateTopicRuleDestinationError::Internal(err.msg))
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(UpdateTopicRuleDestinationError::InvalidRequest(
                        err.msg,
                    ))
                }
                "ServiceUnavailableException" => {
                    return RusotoError::Service(
                        UpdateTopicRuleDestinationError::ServiceUnavailable(err.msg),
                    )
                }
                "UnauthorizedException" => {
                    return RusotoError::Service(UpdateTopicRuleDestinationError::Unauthorized(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for UpdateTopicRuleDestinationError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for UpdateTopicRuleDestinationError {
    fn description(&self) -> &str {
        match *self {
            UpdateTopicRuleDestinationError::ConflictingResourceUpdate(ref cause) => cause,
            UpdateTopicRuleDestinationError::Internal(ref cause) => cause,
            UpdateTopicRuleDestinationError::InvalidRequest(ref cause) => cause,
            UpdateTopicRuleDestinationError::ServiceUnavailable(ref cause) => cause,
            UpdateTopicRuleDestinationError::Unauthorized(ref cause) => cause,
        }
    }
}
/// Errors returned by ValidateSecurityProfileBehaviors
#[derive(Debug, PartialEq)]
pub enum ValidateSecurityProfileBehaviorsError {
    /// <p>An unexpected error has occurred.</p>
    InternalFailure(String),
    /// <p>The request is not valid.</p>
    InvalidRequest(String),
    /// <p>The rate exceeds the limit.</p>
    Throttling(String),
}

impl ValidateSecurityProfileBehaviorsError {
    pub fn from_response(
        res: BufferedHttpResponse,
    ) -> RusotoError<ValidateSecurityProfileBehaviorsError> {
        if let Some(err) = proto::json::Error::parse_rest(&res) {
            match err.typ.as_str() {
                "InternalFailureException" => {
                    return RusotoError::Service(
                        ValidateSecurityProfileBehaviorsError::InternalFailure(err.msg),
                    )
                }
                "InvalidRequestException" => {
                    return RusotoError::Service(
                        ValidateSecurityProfileBehaviorsError::InvalidRequest(err.msg),
                    )
                }
                "ThrottlingException" => {
                    return RusotoError::Service(ValidateSecurityProfileBehaviorsError::Throttling(
                        err.msg,
                    ))
                }
                "ValidationException" => return RusotoError::Validation(err.msg),
                _ => {}
            }
        }
        return RusotoError::Unknown(res);
    }
}
impl fmt::Display for ValidateSecurityProfileBehaviorsError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.description())
    }
}
impl Error for ValidateSecurityProfileBehaviorsError {
    fn description(&self) -> &str {
        match *self {
            ValidateSecurityProfileBehaviorsError::InternalFailure(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::InvalidRequest(ref cause) => cause,
            ValidateSecurityProfileBehaviorsError::Throttling(ref cause) => cause,
        }
    }
}
/// Trait representing the capabilities of the AWS IoT API. AWS IoT clients implement this trait.
pub trait Iot {
    /// <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
    fn accept_certificate_transfer(
        &self,
        input: AcceptCertificateTransferRequest,
    ) -> RusotoFuture<(), AcceptCertificateTransferError>;

    /// <p>Adds a thing to a billing group.</p>
    fn add_thing_to_billing_group(
        &self,
        input: AddThingToBillingGroupRequest,
    ) -> RusotoFuture<AddThingToBillingGroupResponse, AddThingToBillingGroupError>;

    /// <p>Adds a thing to a thing group.</p>
    fn add_thing_to_thing_group(
        &self,
        input: AddThingToThingGroupRequest,
    ) -> RusotoFuture<AddThingToThingGroupResponse, AddThingToThingGroupError>;

    /// <p><p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to &quot;CONTINUOUS&quot;.</p> </li> <li> <p>The job status must currently be &quot;IN_PROGRESS&quot;.</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul></p>
    fn associate_targets_with_job(
        &self,
        input: AssociateTargetsWithJobRequest,
    ) -> RusotoFuture<AssociateTargetsWithJobResponse, AssociateTargetsWithJobError>;

    /// <p>Attaches a policy to the specified target.</p>
    fn attach_policy(&self, input: AttachPolicyRequest) -> RusotoFuture<(), AttachPolicyError>;

    /// <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
    fn attach_principal_policy(
        &self,
        input: AttachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), AttachPrincipalPolicyError>;

    /// <p>Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.</p>
    fn attach_security_profile(
        &self,
        input: AttachSecurityProfileRequest,
    ) -> RusotoFuture<AttachSecurityProfileResponse, AttachSecurityProfileError>;

    /// <p>Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p>
    fn attach_thing_principal(
        &self,
        input: AttachThingPrincipalRequest,
    ) -> RusotoFuture<AttachThingPrincipalResponse, AttachThingPrincipalError>;

    /// <p>Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.</p>
    fn cancel_audit_mitigation_actions_task(
        &self,
        input: CancelAuditMitigationActionsTaskRequest,
    ) -> RusotoFuture<CancelAuditMitigationActionsTaskResponse, CancelAuditMitigationActionsTaskError>;

    /// <p>Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.</p>
    fn cancel_audit_task(
        &self,
        input: CancelAuditTaskRequest,
    ) -> RusotoFuture<CancelAuditTaskResponse, CancelAuditTaskError>;

    /// <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
    fn cancel_certificate_transfer(
        &self,
        input: CancelCertificateTransferRequest,
    ) -> RusotoFuture<(), CancelCertificateTransferError>;

    /// <p>Cancels a job.</p>
    fn cancel_job(
        &self,
        input: CancelJobRequest,
    ) -> RusotoFuture<CancelJobResponse, CancelJobError>;

    /// <p>Cancels the execution of a job for a given thing.</p>
    fn cancel_job_execution(
        &self,
        input: CancelJobExecutionRequest,
    ) -> RusotoFuture<(), CancelJobExecutionError>;

    /// <p>Clears the default authorizer.</p>
    fn clear_default_authorizer(
        &self,
    ) -> RusotoFuture<ClearDefaultAuthorizerResponse, ClearDefaultAuthorizerError>;

    /// <p>Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.</p>
    fn confirm_topic_rule_destination(
        &self,
        input: ConfirmTopicRuleDestinationRequest,
    ) -> RusotoFuture<ConfirmTopicRuleDestinationResponse, ConfirmTopicRuleDestinationError>;

    /// <p>Creates an authorizer.</p>
    fn create_authorizer(
        &self,
        input: CreateAuthorizerRequest,
    ) -> RusotoFuture<CreateAuthorizerResponse, CreateAuthorizerError>;

    /// <p>Creates a billing group.</p>
    fn create_billing_group(
        &self,
        input: CreateBillingGroupRequest,
    ) -> RusotoFuture<CreateBillingGroupResponse, CreateBillingGroupError>;

    /// <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
    fn create_certificate_from_csr(
        &self,
        input: CreateCertificateFromCsrRequest,
    ) -> RusotoFuture<CreateCertificateFromCsrResponse, CreateCertificateFromCsrError>;

    /// <p><p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn create_domain_configuration(
        &self,
        input: CreateDomainConfigurationRequest,
    ) -> RusotoFuture<CreateDomainConfigurationResponse, CreateDomainConfigurationError>;

    /// <p>Creates a dynamic thing group.</p>
    fn create_dynamic_thing_group(
        &self,
        input: CreateDynamicThingGroupRequest,
    ) -> RusotoFuture<CreateDynamicThingGroupResponse, CreateDynamicThingGroupError>;

    /// <p>Creates a job.</p>
    fn create_job(
        &self,
        input: CreateJobRequest,
    ) -> RusotoFuture<CreateJobResponse, CreateJobError>;

    /// <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
    fn create_keys_and_certificate(
        &self,
        input: CreateKeysAndCertificateRequest,
    ) -> RusotoFuture<CreateKeysAndCertificateResponse, CreateKeysAndCertificateError>;

    /// <p>Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.</p>
    fn create_mitigation_action(
        &self,
        input: CreateMitigationActionRequest,
    ) -> RusotoFuture<CreateMitigationActionResponse, CreateMitigationActionError>;

    /// <p>Creates an AWS IoT OTAUpdate on a target group of things or groups.</p>
    fn create_ota_update(
        &self,
        input: CreateOTAUpdateRequest,
    ) -> RusotoFuture<CreateOTAUpdateResponse, CreateOTAUpdateError>;

    /// <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
    fn create_policy(
        &self,
        input: CreatePolicyRequest,
    ) -> RusotoFuture<CreatePolicyResponse, CreatePolicyError>;

    /// <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    fn create_policy_version(
        &self,
        input: CreatePolicyVersionRequest,
    ) -> RusotoFuture<CreatePolicyVersionResponse, CreatePolicyVersionError>;

    /// <p>Creates a provisioning claim.</p>
    fn create_provisioning_claim(
        &self,
        input: CreateProvisioningClaimRequest,
    ) -> RusotoFuture<CreateProvisioningClaimResponse, CreateProvisioningClaimError>;

    /// <p>Creates a fleet provisioning template.</p>
    fn create_provisioning_template(
        &self,
        input: CreateProvisioningTemplateRequest,
    ) -> RusotoFuture<CreateProvisioningTemplateResponse, CreateProvisioningTemplateError>;

    /// <p>Creates a new version of a fleet provisioning template.</p>
    fn create_provisioning_template_version(
        &self,
        input: CreateProvisioningTemplateVersionRequest,
    ) -> RusotoFuture<
        CreateProvisioningTemplateVersionResponse,
        CreateProvisioningTemplateVersionError,
    >;

    /// <p>Creates a role alias.</p>
    fn create_role_alias(
        &self,
        input: CreateRoleAliasRequest,
    ) -> RusotoFuture<CreateRoleAliasResponse, CreateRoleAliasError>;

    /// <p>Creates a scheduled audit that is run at a specified time interval.</p>
    fn create_scheduled_audit(
        &self,
        input: CreateScheduledAuditRequest,
    ) -> RusotoFuture<CreateScheduledAuditResponse, CreateScheduledAuditError>;

    /// <p>Creates a Device Defender security profile.</p>
    fn create_security_profile(
        &self,
        input: CreateSecurityProfileRequest,
    ) -> RusotoFuture<CreateSecurityProfileResponse, CreateSecurityProfileError>;

    /// <p>Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.</p>
    fn create_stream(
        &self,
        input: CreateStreamRequest,
    ) -> RusotoFuture<CreateStreamResponse, CreateStreamError>;

    /// <p><p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing(
        &self,
        input: CreateThingRequest,
    ) -> RusotoFuture<CreateThingResponse, CreateThingError>;

    /// <p><p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing_group(
        &self,
        input: CreateThingGroupRequest,
    ) -> RusotoFuture<CreateThingGroupResponse, CreateThingGroupError>;

    /// <p>Creates a new thing type.</p>
    fn create_thing_type(
        &self,
        input: CreateThingTypeRequest,
    ) -> RusotoFuture<CreateThingTypeResponse, CreateThingTypeError>;

    /// <p>Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn create_topic_rule(
        &self,
        input: CreateTopicRuleRequest,
    ) -> RusotoFuture<(), CreateTopicRuleError>;

    /// <p>Creates a topic rule destination. The destination must be confirmed prior to use.</p>
    fn create_topic_rule_destination(
        &self,
        input: CreateTopicRuleDestinationRequest,
    ) -> RusotoFuture<CreateTopicRuleDestinationResponse, CreateTopicRuleDestinationError>;

    /// <p>Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. </p>
    fn delete_account_audit_configuration(
        &self,
        input: DeleteAccountAuditConfigurationRequest,
    ) -> RusotoFuture<DeleteAccountAuditConfigurationResponse, DeleteAccountAuditConfigurationError>;

    /// <p>Deletes an authorizer.</p>
    fn delete_authorizer(
        &self,
        input: DeleteAuthorizerRequest,
    ) -> RusotoFuture<DeleteAuthorizerResponse, DeleteAuthorizerError>;

    /// <p>Deletes the billing group.</p>
    fn delete_billing_group(
        &self,
        input: DeleteBillingGroupRequest,
    ) -> RusotoFuture<DeleteBillingGroupResponse, DeleteBillingGroupError>;

    /// <p>Deletes a registered CA certificate.</p>
    fn delete_ca_certificate(
        &self,
        input: DeleteCACertificateRequest,
    ) -> RusotoFuture<DeleteCACertificateResponse, DeleteCACertificateError>;

    /// <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
    fn delete_certificate(
        &self,
        input: DeleteCertificateRequest,
    ) -> RusotoFuture<(), DeleteCertificateError>;

    /// <p><p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn delete_domain_configuration(
        &self,
        input: DeleteDomainConfigurationRequest,
    ) -> RusotoFuture<DeleteDomainConfigurationResponse, DeleteDomainConfigurationError>;

    /// <p>Deletes a dynamic thing group.</p>
    fn delete_dynamic_thing_group(
        &self,
        input: DeleteDynamicThingGroupRequest,
    ) -> RusotoFuture<DeleteDynamicThingGroupResponse, DeleteDynamicThingGroupError>;

    /// <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
    fn delete_job(&self, input: DeleteJobRequest) -> RusotoFuture<(), DeleteJobError>;

    /// <p>Deletes a job execution.</p>
    fn delete_job_execution(
        &self,
        input: DeleteJobExecutionRequest,
    ) -> RusotoFuture<(), DeleteJobExecutionError>;

    /// <p>Deletes a defined mitigation action from your AWS account.</p>
    fn delete_mitigation_action(
        &self,
        input: DeleteMitigationActionRequest,
    ) -> RusotoFuture<DeleteMitigationActionResponse, DeleteMitigationActionError>;

    /// <p>Delete an OTA update.</p>
    fn delete_ota_update(
        &self,
        input: DeleteOTAUpdateRequest,
    ) -> RusotoFuture<DeleteOTAUpdateResponse, DeleteOTAUpdateError>;

    /// <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
    fn delete_policy(&self, input: DeletePolicyRequest) -> RusotoFuture<(), DeletePolicyError>;

    /// <p>Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.</p>
    fn delete_policy_version(
        &self,
        input: DeletePolicyVersionRequest,
    ) -> RusotoFuture<(), DeletePolicyVersionError>;

    /// <p>Deletes a fleet provisioning template.</p>
    fn delete_provisioning_template(
        &self,
        input: DeleteProvisioningTemplateRequest,
    ) -> RusotoFuture<DeleteProvisioningTemplateResponse, DeleteProvisioningTemplateError>;

    /// <p>Deletes a fleet provisioning template version.</p>
    fn delete_provisioning_template_version(
        &self,
        input: DeleteProvisioningTemplateVersionRequest,
    ) -> RusotoFuture<
        DeleteProvisioningTemplateVersionResponse,
        DeleteProvisioningTemplateVersionError,
    >;

    /// <p>Deletes a CA certificate registration code.</p>
    fn delete_registration_code(
        &self,
    ) -> RusotoFuture<DeleteRegistrationCodeResponse, DeleteRegistrationCodeError>;

    /// <p>Deletes a role alias</p>
    fn delete_role_alias(
        &self,
        input: DeleteRoleAliasRequest,
    ) -> RusotoFuture<DeleteRoleAliasResponse, DeleteRoleAliasError>;

    /// <p>Deletes a scheduled audit.</p>
    fn delete_scheduled_audit(
        &self,
        input: DeleteScheduledAuditRequest,
    ) -> RusotoFuture<DeleteScheduledAuditResponse, DeleteScheduledAuditError>;

    /// <p>Deletes a Device Defender security profile.</p>
    fn delete_security_profile(
        &self,
        input: DeleteSecurityProfileRequest,
    ) -> RusotoFuture<DeleteSecurityProfileResponse, DeleteSecurityProfileError>;

    /// <p>Deletes a stream.</p>
    fn delete_stream(
        &self,
        input: DeleteStreamRequest,
    ) -> RusotoFuture<DeleteStreamResponse, DeleteStreamError>;

    /// <p>Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.</p>
    fn delete_thing(
        &self,
        input: DeleteThingRequest,
    ) -> RusotoFuture<DeleteThingResponse, DeleteThingError>;

    /// <p>Deletes a thing group.</p>
    fn delete_thing_group(
        &self,
        input: DeleteThingGroupRequest,
    ) -> RusotoFuture<DeleteThingGroupResponse, DeleteThingGroupError>;

    /// <p>Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.</p>
    fn delete_thing_type(
        &self,
        input: DeleteThingTypeRequest,
    ) -> RusotoFuture<DeleteThingTypeResponse, DeleteThingTypeError>;

    /// <p>Deletes the rule.</p>
    fn delete_topic_rule(
        &self,
        input: DeleteTopicRuleRequest,
    ) -> RusotoFuture<(), DeleteTopicRuleError>;

    /// <p>Deletes a topic rule destination.</p>
    fn delete_topic_rule_destination(
        &self,
        input: DeleteTopicRuleDestinationRequest,
    ) -> RusotoFuture<DeleteTopicRuleDestinationResponse, DeleteTopicRuleDestinationError>;

    /// <p>Deletes a logging level.</p>
    fn delete_v2_logging_level(
        &self,
        input: DeleteV2LoggingLevelRequest,
    ) -> RusotoFuture<(), DeleteV2LoggingLevelError>;

    /// <p>Deprecates a thing type. You can not associate new things with deprecated thing type.</p>
    fn deprecate_thing_type(
        &self,
        input: DeprecateThingTypeRequest,
    ) -> RusotoFuture<DeprecateThingTypeResponse, DeprecateThingTypeError>;

    /// <p>Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn describe_account_audit_configuration(
        &self,
    ) -> RusotoFuture<
        DescribeAccountAuditConfigurationResponse,
        DescribeAccountAuditConfigurationError,
    >;

    /// <p>Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.</p>
    fn describe_audit_finding(
        &self,
        input: DescribeAuditFindingRequest,
    ) -> RusotoFuture<DescribeAuditFindingResponse, DescribeAuditFindingError>;

    /// <p>Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.</p>
    fn describe_audit_mitigation_actions_task(
        &self,
        input: DescribeAuditMitigationActionsTaskRequest,
    ) -> RusotoFuture<
        DescribeAuditMitigationActionsTaskResponse,
        DescribeAuditMitigationActionsTaskError,
    >;

    /// <p>Gets information about a Device Defender audit.</p>
    fn describe_audit_task(
        &self,
        input: DescribeAuditTaskRequest,
    ) -> RusotoFuture<DescribeAuditTaskResponse, DescribeAuditTaskError>;

    /// <p>Describes an authorizer.</p>
    fn describe_authorizer(
        &self,
        input: DescribeAuthorizerRequest,
    ) -> RusotoFuture<DescribeAuthorizerResponse, DescribeAuthorizerError>;

    /// <p>Returns information about a billing group.</p>
    fn describe_billing_group(
        &self,
        input: DescribeBillingGroupRequest,
    ) -> RusotoFuture<DescribeBillingGroupResponse, DescribeBillingGroupError>;

    /// <p>Describes a registered CA certificate.</p>
    fn describe_ca_certificate(
        &self,
        input: DescribeCACertificateRequest,
    ) -> RusotoFuture<DescribeCACertificateResponse, DescribeCACertificateError>;

    /// <p>Gets information about the specified certificate.</p>
    fn describe_certificate(
        &self,
        input: DescribeCertificateRequest,
    ) -> RusotoFuture<DescribeCertificateResponse, DescribeCertificateError>;

    /// <p>Describes the default authorizer.</p>
    fn describe_default_authorizer(
        &self,
    ) -> RusotoFuture<DescribeDefaultAuthorizerResponse, DescribeDefaultAuthorizerError>;

    /// <p><p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn describe_domain_configuration(
        &self,
        input: DescribeDomainConfigurationRequest,
    ) -> RusotoFuture<DescribeDomainConfigurationResponse, DescribeDomainConfigurationError>;

    /// <p>Returns a unique endpoint specific to the AWS account making the call.</p>
    fn describe_endpoint(
        &self,
        input: DescribeEndpointRequest,
    ) -> RusotoFuture<DescribeEndpointResponse, DescribeEndpointError>;

    /// <p>Describes event configurations.</p>
    fn describe_event_configurations(
        &self,
    ) -> RusotoFuture<DescribeEventConfigurationsResponse, DescribeEventConfigurationsError>;

    /// <p>Describes a search index.</p>
    fn describe_index(
        &self,
        input: DescribeIndexRequest,
    ) -> RusotoFuture<DescribeIndexResponse, DescribeIndexError>;

    /// <p>Describes a job.</p>
    fn describe_job(
        &self,
        input: DescribeJobRequest,
    ) -> RusotoFuture<DescribeJobResponse, DescribeJobError>;

    /// <p>Describes a job execution.</p>
    fn describe_job_execution(
        &self,
        input: DescribeJobExecutionRequest,
    ) -> RusotoFuture<DescribeJobExecutionResponse, DescribeJobExecutionError>;

    /// <p>Gets information about a mitigation action.</p>
    fn describe_mitigation_action(
        &self,
        input: DescribeMitigationActionRequest,
    ) -> RusotoFuture<DescribeMitigationActionResponse, DescribeMitigationActionError>;

    /// <p>Returns information about a fleet provisioning template.</p>
    fn describe_provisioning_template(
        &self,
        input: DescribeProvisioningTemplateRequest,
    ) -> RusotoFuture<DescribeProvisioningTemplateResponse, DescribeProvisioningTemplateError>;

    /// <p>Returns information about a fleet provisioning template version.</p>
    fn describe_provisioning_template_version(
        &self,
        input: DescribeProvisioningTemplateVersionRequest,
    ) -> RusotoFuture<
        DescribeProvisioningTemplateVersionResponse,
        DescribeProvisioningTemplateVersionError,
    >;

    /// <p>Describes a role alias.</p>
    fn describe_role_alias(
        &self,
        input: DescribeRoleAliasRequest,
    ) -> RusotoFuture<DescribeRoleAliasResponse, DescribeRoleAliasError>;

    /// <p>Gets information about a scheduled audit.</p>
    fn describe_scheduled_audit(
        &self,
        input: DescribeScheduledAuditRequest,
    ) -> RusotoFuture<DescribeScheduledAuditResponse, DescribeScheduledAuditError>;

    /// <p>Gets information about a Device Defender security profile.</p>
    fn describe_security_profile(
        &self,
        input: DescribeSecurityProfileRequest,
    ) -> RusotoFuture<DescribeSecurityProfileResponse, DescribeSecurityProfileError>;

    /// <p>Gets information about a stream.</p>
    fn describe_stream(
        &self,
        input: DescribeStreamRequest,
    ) -> RusotoFuture<DescribeStreamResponse, DescribeStreamError>;

    /// <p>Gets information about the specified thing.</p>
    fn describe_thing(
        &self,
        input: DescribeThingRequest,
    ) -> RusotoFuture<DescribeThingResponse, DescribeThingError>;

    /// <p>Describe a thing group.</p>
    fn describe_thing_group(
        &self,
        input: DescribeThingGroupRequest,
    ) -> RusotoFuture<DescribeThingGroupResponse, DescribeThingGroupError>;

    /// <p>Describes a bulk thing provisioning task.</p>
    fn describe_thing_registration_task(
        &self,
        input: DescribeThingRegistrationTaskRequest,
    ) -> RusotoFuture<DescribeThingRegistrationTaskResponse, DescribeThingRegistrationTaskError>;

    /// <p>Gets information about the specified thing type.</p>
    fn describe_thing_type(
        &self,
        input: DescribeThingTypeRequest,
    ) -> RusotoFuture<DescribeThingTypeResponse, DescribeThingTypeError>;

    /// <p>Detaches a policy from the specified target.</p>
    fn detach_policy(&self, input: DetachPolicyRequest) -> RusotoFuture<(), DetachPolicyError>;

    /// <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
    fn detach_principal_policy(
        &self,
        input: DetachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), DetachPrincipalPolicyError>;

    /// <p>Disassociates a Device Defender security profile from a thing group or from this account.</p>
    fn detach_security_profile(
        &self,
        input: DetachSecurityProfileRequest,
    ) -> RusotoFuture<DetachSecurityProfileResponse, DetachSecurityProfileError>;

    /// <p><p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note></p>
    fn detach_thing_principal(
        &self,
        input: DetachThingPrincipalRequest,
    ) -> RusotoFuture<DetachThingPrincipalResponse, DetachThingPrincipalError>;

    /// <p>Disables the rule.</p>
    fn disable_topic_rule(
        &self,
        input: DisableTopicRuleRequest,
    ) -> RusotoFuture<(), DisableTopicRuleError>;

    /// <p>Enables the rule.</p>
    fn enable_topic_rule(
        &self,
        input: EnableTopicRuleRequest,
    ) -> RusotoFuture<(), EnableTopicRuleError>;

    /// <p>Returns the approximate count of unique values that match the query.</p>
    fn get_cardinality(
        &self,
        input: GetCardinalityRequest,
    ) -> RusotoFuture<GetCardinalityResponse, GetCardinalityError>;

    /// <p>Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.</p>
    fn get_effective_policies(
        &self,
        input: GetEffectivePoliciesRequest,
    ) -> RusotoFuture<GetEffectivePoliciesResponse, GetEffectivePoliciesError>;

    /// <p>Gets the indexing configuration.</p>
    fn get_indexing_configuration(
        &self,
    ) -> RusotoFuture<GetIndexingConfigurationResponse, GetIndexingConfigurationError>;

    /// <p>Gets a job document.</p>
    fn get_job_document(
        &self,
        input: GetJobDocumentRequest,
    ) -> RusotoFuture<GetJobDocumentResponse, GetJobDocumentError>;

    /// <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
    fn get_logging_options(
        &self,
    ) -> RusotoFuture<GetLoggingOptionsResponse, GetLoggingOptionsError>;

    /// <p>Gets an OTA update.</p>
    fn get_ota_update(
        &self,
        input: GetOTAUpdateRequest,
    ) -> RusotoFuture<GetOTAUpdateResponse, GetOTAUpdateError>;

    /// <p>Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.</p>
    fn get_percentiles(
        &self,
        input: GetPercentilesRequest,
    ) -> RusotoFuture<GetPercentilesResponse, GetPercentilesError>;

    /// <p>Gets information about the specified policy with the policy document of the default version.</p>
    fn get_policy(
        &self,
        input: GetPolicyRequest,
    ) -> RusotoFuture<GetPolicyResponse, GetPolicyError>;

    /// <p>Gets information about the specified policy version.</p>
    fn get_policy_version(
        &self,
        input: GetPolicyVersionRequest,
    ) -> RusotoFuture<GetPolicyVersionResponse, GetPolicyVersionError>;

    /// <p>Gets a registration code used to register a CA certificate with AWS IoT.</p>
    fn get_registration_code(
        &self,
    ) -> RusotoFuture<GetRegistrationCodeResponse, GetRegistrationCodeError>;

    /// <p>Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.</p>
    fn get_statistics(
        &self,
        input: GetStatisticsRequest,
    ) -> RusotoFuture<GetStatisticsResponse, GetStatisticsError>;

    /// <p>Gets information about the rule.</p>
    fn get_topic_rule(
        &self,
        input: GetTopicRuleRequest,
    ) -> RusotoFuture<GetTopicRuleResponse, GetTopicRuleError>;

    /// <p>Gets information about a topic rule destination.</p>
    fn get_topic_rule_destination(
        &self,
        input: GetTopicRuleDestinationRequest,
    ) -> RusotoFuture<GetTopicRuleDestinationResponse, GetTopicRuleDestinationError>;

    /// <p>Gets the fine grained logging options.</p>
    fn get_v2_logging_options(
        &self,
    ) -> RusotoFuture<GetV2LoggingOptionsResponse, GetV2LoggingOptionsError>;

    /// <p>Lists the active violations for a given Device Defender security profile.</p>
    fn list_active_violations(
        &self,
        input: ListActiveViolationsRequest,
    ) -> RusotoFuture<ListActiveViolationsResponse, ListActiveViolationsError>;

    /// <p>Lists the policies attached to the specified thing group.</p>
    fn list_attached_policies(
        &self,
        input: ListAttachedPoliciesRequest,
    ) -> RusotoFuture<ListAttachedPoliciesResponse, ListAttachedPoliciesError>;

    /// <p>Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)</p>
    fn list_audit_findings(
        &self,
        input: ListAuditFindingsRequest,
    ) -> RusotoFuture<ListAuditFindingsResponse, ListAuditFindingsError>;

    /// <p>Gets the status of audit mitigation action tasks that were executed.</p>
    fn list_audit_mitigation_actions_executions(
        &self,
        input: ListAuditMitigationActionsExecutionsRequest,
    ) -> RusotoFuture<
        ListAuditMitigationActionsExecutionsResponse,
        ListAuditMitigationActionsExecutionsError,
    >;

    /// <p>Gets a list of audit mitigation action tasks that match the specified filters.</p>
    fn list_audit_mitigation_actions_tasks(
        &self,
        input: ListAuditMitigationActionsTasksRequest,
    ) -> RusotoFuture<ListAuditMitigationActionsTasksResponse, ListAuditMitigationActionsTasksError>;

    /// <p>Lists the Device Defender audits that have been performed during a given time period.</p>
    fn list_audit_tasks(
        &self,
        input: ListAuditTasksRequest,
    ) -> RusotoFuture<ListAuditTasksResponse, ListAuditTasksError>;

    /// <p>Lists the authorizers registered in your account.</p>
    fn list_authorizers(
        &self,
        input: ListAuthorizersRequest,
    ) -> RusotoFuture<ListAuthorizersResponse, ListAuthorizersError>;

    /// <p>Lists the billing groups you have created.</p>
    fn list_billing_groups(
        &self,
        input: ListBillingGroupsRequest,
    ) -> RusotoFuture<ListBillingGroupsResponse, ListBillingGroupsError>;

    /// <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_ca_certificates(
        &self,
        input: ListCACertificatesRequest,
    ) -> RusotoFuture<ListCACertificatesResponse, ListCACertificatesError>;

    /// <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_certificates(
        &self,
        input: ListCertificatesRequest,
    ) -> RusotoFuture<ListCertificatesResponse, ListCertificatesError>;

    /// <p>List the device certificates signed by the specified CA certificate.</p>
    fn list_certificates_by_ca(
        &self,
        input: ListCertificatesByCARequest,
    ) -> RusotoFuture<ListCertificatesByCAResponse, ListCertificatesByCAError>;

    /// <p><p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn list_domain_configurations(
        &self,
        input: ListDomainConfigurationsRequest,
    ) -> RusotoFuture<ListDomainConfigurationsResponse, ListDomainConfigurationsError>;

    /// <p>Lists the search indices.</p>
    fn list_indices(
        &self,
        input: ListIndicesRequest,
    ) -> RusotoFuture<ListIndicesResponse, ListIndicesError>;

    /// <p>Lists the job executions for a job.</p>
    fn list_job_executions_for_job(
        &self,
        input: ListJobExecutionsForJobRequest,
    ) -> RusotoFuture<ListJobExecutionsForJobResponse, ListJobExecutionsForJobError>;

    /// <p>Lists the job executions for the specified thing.</p>
    fn list_job_executions_for_thing(
        &self,
        input: ListJobExecutionsForThingRequest,
    ) -> RusotoFuture<ListJobExecutionsForThingResponse, ListJobExecutionsForThingError>;

    /// <p>Lists jobs.</p>
    fn list_jobs(&self, input: ListJobsRequest) -> RusotoFuture<ListJobsResponse, ListJobsError>;

    /// <p>Gets a list of all mitigation actions that match the specified filter criteria.</p>
    fn list_mitigation_actions(
        &self,
        input: ListMitigationActionsRequest,
    ) -> RusotoFuture<ListMitigationActionsResponse, ListMitigationActionsError>;

    /// <p>Lists OTA updates.</p>
    fn list_ota_updates(
        &self,
        input: ListOTAUpdatesRequest,
    ) -> RusotoFuture<ListOTAUpdatesResponse, ListOTAUpdatesError>;

    /// <p>Lists certificates that are being transferred but not yet accepted.</p>
    fn list_outgoing_certificates(
        &self,
        input: ListOutgoingCertificatesRequest,
    ) -> RusotoFuture<ListOutgoingCertificatesResponse, ListOutgoingCertificatesError>;

    /// <p>Lists your policies.</p>
    fn list_policies(
        &self,
        input: ListPoliciesRequest,
    ) -> RusotoFuture<ListPoliciesResponse, ListPoliciesError>;

    /// <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
    fn list_policy_principals(
        &self,
        input: ListPolicyPrincipalsRequest,
    ) -> RusotoFuture<ListPolicyPrincipalsResponse, ListPolicyPrincipalsError>;

    /// <p>Lists the versions of the specified policy and identifies the default version.</p>
    fn list_policy_versions(
        &self,
        input: ListPolicyVersionsRequest,
    ) -> RusotoFuture<ListPolicyVersionsResponse, ListPolicyVersionsError>;

    /// <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
    fn list_principal_policies(
        &self,
        input: ListPrincipalPoliciesRequest,
    ) -> RusotoFuture<ListPrincipalPoliciesResponse, ListPrincipalPoliciesError>;

    /// <p>Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. </p>
    fn list_principal_things(
        &self,
        input: ListPrincipalThingsRequest,
    ) -> RusotoFuture<ListPrincipalThingsResponse, ListPrincipalThingsError>;

    /// <p>A list of fleet provisioning template versions.</p>
    fn list_provisioning_template_versions(
        &self,
        input: ListProvisioningTemplateVersionsRequest,
    ) -> RusotoFuture<ListProvisioningTemplateVersionsResponse, ListProvisioningTemplateVersionsError>;

    /// <p>Lists the fleet provisioning templates in your AWS account.</p>
    fn list_provisioning_templates(
        &self,
        input: ListProvisioningTemplatesRequest,
    ) -> RusotoFuture<ListProvisioningTemplatesResponse, ListProvisioningTemplatesError>;

    /// <p>Lists the role aliases registered in your account.</p>
    fn list_role_aliases(
        &self,
        input: ListRoleAliasesRequest,
    ) -> RusotoFuture<ListRoleAliasesResponse, ListRoleAliasesError>;

    /// <p>Lists all of your scheduled audits.</p>
    fn list_scheduled_audits(
        &self,
        input: ListScheduledAuditsRequest,
    ) -> RusotoFuture<ListScheduledAuditsResponse, ListScheduledAuditsError>;

    /// <p>Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.</p>
    fn list_security_profiles(
        &self,
        input: ListSecurityProfilesRequest,
    ) -> RusotoFuture<ListSecurityProfilesResponse, ListSecurityProfilesError>;

    /// <p>Lists the Device Defender security profiles attached to a target (thing group).</p>
    fn list_security_profiles_for_target(
        &self,
        input: ListSecurityProfilesForTargetRequest,
    ) -> RusotoFuture<ListSecurityProfilesForTargetResponse, ListSecurityProfilesForTargetError>;

    /// <p>Lists all of the streams in your AWS account.</p>
    fn list_streams(
        &self,
        input: ListStreamsRequest,
    ) -> RusotoFuture<ListStreamsResponse, ListStreamsError>;

    /// <p>Lists the tags (metadata) you have assigned to the resource.</p>
    fn list_tags_for_resource(
        &self,
        input: ListTagsForResourceRequest,
    ) -> RusotoFuture<ListTagsForResourceResponse, ListTagsForResourceError>;

    /// <p>List targets for the specified policy.</p>
    fn list_targets_for_policy(
        &self,
        input: ListTargetsForPolicyRequest,
    ) -> RusotoFuture<ListTargetsForPolicyResponse, ListTargetsForPolicyError>;

    /// <p>Lists the targets (thing groups) associated with a given Device Defender security profile.</p>
    fn list_targets_for_security_profile(
        &self,
        input: ListTargetsForSecurityProfileRequest,
    ) -> RusotoFuture<ListTargetsForSecurityProfileResponse, ListTargetsForSecurityProfileError>;

    /// <p>List the thing groups in your account.</p>
    fn list_thing_groups(
        &self,
        input: ListThingGroupsRequest,
    ) -> RusotoFuture<ListThingGroupsResponse, ListThingGroupsError>;

    /// <p>List the thing groups to which the specified thing belongs.</p>
    fn list_thing_groups_for_thing(
        &self,
        input: ListThingGroupsForThingRequest,
    ) -> RusotoFuture<ListThingGroupsForThingResponse, ListThingGroupsForThingError>;

    /// <p>Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p>
    fn list_thing_principals(
        &self,
        input: ListThingPrincipalsRequest,
    ) -> RusotoFuture<ListThingPrincipalsResponse, ListThingPrincipalsError>;

    /// <p>Information about the thing registration tasks.</p>
    fn list_thing_registration_task_reports(
        &self,
        input: ListThingRegistrationTaskReportsRequest,
    ) -> RusotoFuture<ListThingRegistrationTaskReportsResponse, ListThingRegistrationTaskReportsError>;

    /// <p>List bulk thing provisioning tasks.</p>
    fn list_thing_registration_tasks(
        &self,
        input: ListThingRegistrationTasksRequest,
    ) -> RusotoFuture<ListThingRegistrationTasksResponse, ListThingRegistrationTasksError>;

    /// <p>Lists the existing thing types.</p>
    fn list_thing_types(
        &self,
        input: ListThingTypesRequest,
    ) -> RusotoFuture<ListThingTypesResponse, ListThingTypesError>;

    /// <p>Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. </p>
    fn list_things(
        &self,
        input: ListThingsRequest,
    ) -> RusotoFuture<ListThingsResponse, ListThingsError>;

    /// <p>Lists the things you have added to the given billing group.</p>
    fn list_things_in_billing_group(
        &self,
        input: ListThingsInBillingGroupRequest,
    ) -> RusotoFuture<ListThingsInBillingGroupResponse, ListThingsInBillingGroupError>;

    /// <p>Lists the things in the specified group.</p>
    fn list_things_in_thing_group(
        &self,
        input: ListThingsInThingGroupRequest,
    ) -> RusotoFuture<ListThingsInThingGroupResponse, ListThingsInThingGroupError>;

    /// <p>Lists all the topic rule destinations in your AWS account.</p>
    fn list_topic_rule_destinations(
        &self,
        input: ListTopicRuleDestinationsRequest,
    ) -> RusotoFuture<ListTopicRuleDestinationsResponse, ListTopicRuleDestinationsError>;

    /// <p>Lists the rules for the specific topic.</p>
    fn list_topic_rules(
        &self,
        input: ListTopicRulesRequest,
    ) -> RusotoFuture<ListTopicRulesResponse, ListTopicRulesError>;

    /// <p>Lists logging levels.</p>
    fn list_v2_logging_levels(
        &self,
        input: ListV2LoggingLevelsRequest,
    ) -> RusotoFuture<ListV2LoggingLevelsResponse, ListV2LoggingLevelsError>;

    /// <p>Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).</p>
    fn list_violation_events(
        &self,
        input: ListViolationEventsRequest,
    ) -> RusotoFuture<ListViolationEventsResponse, ListViolationEventsError>;

    /// <p>Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.</p>
    fn register_ca_certificate(
        &self,
        input: RegisterCACertificateRequest,
    ) -> RusotoFuture<RegisterCACertificateResponse, RegisterCACertificateError>;

    /// <p>Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.</p>
    fn register_certificate(
        &self,
        input: RegisterCertificateRequest,
    ) -> RusotoFuture<RegisterCertificateResponse, RegisterCertificateError>;

    /// <p>Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.</p>
    fn register_thing(
        &self,
        input: RegisterThingRequest,
    ) -> RusotoFuture<RegisterThingResponse, RegisterThingError>;

    /// <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
    fn reject_certificate_transfer(
        &self,
        input: RejectCertificateTransferRequest,
    ) -> RusotoFuture<(), RejectCertificateTransferError>;

    /// <p>Removes the given thing from the billing group.</p>
    fn remove_thing_from_billing_group(
        &self,
        input: RemoveThingFromBillingGroupRequest,
    ) -> RusotoFuture<RemoveThingFromBillingGroupResponse, RemoveThingFromBillingGroupError>;

    /// <p>Remove the specified thing from the specified group.</p>
    fn remove_thing_from_thing_group(
        &self,
        input: RemoveThingFromThingGroupRequest,
    ) -> RusotoFuture<RemoveThingFromThingGroupResponse, RemoveThingFromThingGroupError>;

    /// <p>Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn replace_topic_rule(
        &self,
        input: ReplaceTopicRuleRequest,
    ) -> RusotoFuture<(), ReplaceTopicRuleError>;

    /// <p>The query search index.</p>
    fn search_index(
        &self,
        input: SearchIndexRequest,
    ) -> RusotoFuture<SearchIndexResponse, SearchIndexError>;

    /// <p>Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.</p>
    fn set_default_authorizer(
        &self,
        input: SetDefaultAuthorizerRequest,
    ) -> RusotoFuture<SetDefaultAuthorizerResponse, SetDefaultAuthorizerError>;

    /// <p>Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.</p>
    fn set_default_policy_version(
        &self,
        input: SetDefaultPolicyVersionRequest,
    ) -> RusotoFuture<(), SetDefaultPolicyVersionError>;

    /// <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
    fn set_logging_options(
        &self,
        input: SetLoggingOptionsRequest,
    ) -> RusotoFuture<(), SetLoggingOptionsError>;

    /// <p>Sets the logging level.</p>
    fn set_v2_logging_level(
        &self,
        input: SetV2LoggingLevelRequest,
    ) -> RusotoFuture<(), SetV2LoggingLevelError>;

    /// <p>Sets the logging options for the V2 logging service.</p>
    fn set_v2_logging_options(
        &self,
        input: SetV2LoggingOptionsRequest,
    ) -> RusotoFuture<(), SetV2LoggingOptionsError>;

    /// <p>Starts a task that applies a set of mitigation actions to the specified target.</p>
    fn start_audit_mitigation_actions_task(
        &self,
        input: StartAuditMitigationActionsTaskRequest,
    ) -> RusotoFuture<StartAuditMitigationActionsTaskResponse, StartAuditMitigationActionsTaskError>;

    /// <p>Starts an on-demand Device Defender audit.</p>
    fn start_on_demand_audit_task(
        &self,
        input: StartOnDemandAuditTaskRequest,
    ) -> RusotoFuture<StartOnDemandAuditTaskResponse, StartOnDemandAuditTaskError>;

    /// <p>Creates a bulk thing provisioning task.</p>
    fn start_thing_registration_task(
        &self,
        input: StartThingRegistrationTaskRequest,
    ) -> RusotoFuture<StartThingRegistrationTaskResponse, StartThingRegistrationTaskError>;

    /// <p>Cancels a bulk thing provisioning task.</p>
    fn stop_thing_registration_task(
        &self,
        input: StopThingRegistrationTaskRequest,
    ) -> RusotoFuture<StopThingRegistrationTaskResponse, StopThingRegistrationTaskError>;

    /// <p>Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.</p>
    fn tag_resource(
        &self,
        input: TagResourceRequest,
    ) -> RusotoFuture<TagResourceResponse, TagResourceError>;

    /// <p>Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_authorization(
        &self,
        input: TestAuthorizationRequest,
    ) -> RusotoFuture<TestAuthorizationResponse, TestAuthorizationError>;

    /// <p>Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_invoke_authorizer(
        &self,
        input: TestInvokeAuthorizerRequest,
    ) -> RusotoFuture<TestInvokeAuthorizerResponse, TestInvokeAuthorizerError>;

    /// <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
    fn transfer_certificate(
        &self,
        input: TransferCertificateRequest,
    ) -> RusotoFuture<TransferCertificateResponse, TransferCertificateError>;

    /// <p>Removes the given tags (metadata) from the resource.</p>
    fn untag_resource(
        &self,
        input: UntagResourceRequest,
    ) -> RusotoFuture<UntagResourceResponse, UntagResourceError>;

    /// <p>Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn update_account_audit_configuration(
        &self,
        input: UpdateAccountAuditConfigurationRequest,
    ) -> RusotoFuture<UpdateAccountAuditConfigurationResponse, UpdateAccountAuditConfigurationError>;

    /// <p>Updates an authorizer.</p>
    fn update_authorizer(
        &self,
        input: UpdateAuthorizerRequest,
    ) -> RusotoFuture<UpdateAuthorizerResponse, UpdateAuthorizerError>;

    /// <p>Updates information about the billing group.</p>
    fn update_billing_group(
        &self,
        input: UpdateBillingGroupRequest,
    ) -> RusotoFuture<UpdateBillingGroupResponse, UpdateBillingGroupError>;

    /// <p>Updates a registered CA certificate.</p>
    fn update_ca_certificate(
        &self,
        input: UpdateCACertificateRequest,
    ) -> RusotoFuture<(), UpdateCACertificateError>;

    /// <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
    fn update_certificate(
        &self,
        input: UpdateCertificateRequest,
    ) -> RusotoFuture<(), UpdateCertificateError>;

    /// <p><p>Updates values stored in the domain configuration. Domain configurations for default endpoints can&#39;t be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn update_domain_configuration(
        &self,
        input: UpdateDomainConfigurationRequest,
    ) -> RusotoFuture<UpdateDomainConfigurationResponse, UpdateDomainConfigurationError>;

    /// <p>Updates a dynamic thing group.</p>
    fn update_dynamic_thing_group(
        &self,
        input: UpdateDynamicThingGroupRequest,
    ) -> RusotoFuture<UpdateDynamicThingGroupResponse, UpdateDynamicThingGroupError>;

    /// <p>Updates the event configurations.</p>
    fn update_event_configurations(
        &self,
        input: UpdateEventConfigurationsRequest,
    ) -> RusotoFuture<UpdateEventConfigurationsResponse, UpdateEventConfigurationsError>;

    /// <p>Updates the search configuration.</p>
    fn update_indexing_configuration(
        &self,
        input: UpdateIndexingConfigurationRequest,
    ) -> RusotoFuture<UpdateIndexingConfigurationResponse, UpdateIndexingConfigurationError>;

    /// <p>Updates supported fields of the specified job.</p>
    fn update_job(&self, input: UpdateJobRequest) -> RusotoFuture<(), UpdateJobError>;

    /// <p>Updates the definition for the specified mitigation action.</p>
    fn update_mitigation_action(
        &self,
        input: UpdateMitigationActionRequest,
    ) -> RusotoFuture<UpdateMitigationActionResponse, UpdateMitigationActionError>;

    /// <p>Updates a fleet provisioning template.</p>
    fn update_provisioning_template(
        &self,
        input: UpdateProvisioningTemplateRequest,
    ) -> RusotoFuture<UpdateProvisioningTemplateResponse, UpdateProvisioningTemplateError>;

    /// <p>Updates a role alias.</p>
    fn update_role_alias(
        &self,
        input: UpdateRoleAliasRequest,
    ) -> RusotoFuture<UpdateRoleAliasResponse, UpdateRoleAliasError>;

    /// <p>Updates a scheduled audit, including which checks are performed and how often the audit takes place.</p>
    fn update_scheduled_audit(
        &self,
        input: UpdateScheduledAuditRequest,
    ) -> RusotoFuture<UpdateScheduledAuditResponse, UpdateScheduledAuditError>;

    /// <p>Updates a Device Defender security profile.</p>
    fn update_security_profile(
        &self,
        input: UpdateSecurityProfileRequest,
    ) -> RusotoFuture<UpdateSecurityProfileResponse, UpdateSecurityProfileError>;

    /// <p>Updates an existing stream. The stream version will be incremented by one.</p>
    fn update_stream(
        &self,
        input: UpdateStreamRequest,
    ) -> RusotoFuture<UpdateStreamResponse, UpdateStreamError>;

    /// <p>Updates the data for a thing.</p>
    fn update_thing(
        &self,
        input: UpdateThingRequest,
    ) -> RusotoFuture<UpdateThingResponse, UpdateThingError>;

    /// <p>Update a thing group.</p>
    fn update_thing_group(
        &self,
        input: UpdateThingGroupRequest,
    ) -> RusotoFuture<UpdateThingGroupResponse, UpdateThingGroupError>;

    /// <p>Updates the groups to which the thing belongs.</p>
    fn update_thing_groups_for_thing(
        &self,
        input: UpdateThingGroupsForThingRequest,
    ) -> RusotoFuture<UpdateThingGroupsForThingResponse, UpdateThingGroupsForThingError>;

    /// <p>Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.</p>
    fn update_topic_rule_destination(
        &self,
        input: UpdateTopicRuleDestinationRequest,
    ) -> RusotoFuture<UpdateTopicRuleDestinationResponse, UpdateTopicRuleDestinationError>;

    /// <p>Validates a Device Defender security profile behaviors specification.</p>
    fn validate_security_profile_behaviors(
        &self,
        input: ValidateSecurityProfileBehaviorsRequest,
    ) -> RusotoFuture<ValidateSecurityProfileBehaviorsResponse, ValidateSecurityProfileBehaviorsError>;
}
/// A client for the AWS IoT API.
#[derive(Clone)]
pub struct IotClient {
    client: Client,
    region: region::Region,
}

impl IotClient {
    /// Creates a client backed by the default tokio event loop.
    ///
    /// The client will use the default credentials provider and tls client.
    pub fn new(region: region::Region) -> IotClient {
        Self::new_with_client(Client::shared(), region)
    }

    pub fn new_with<P, D>(
        request_dispatcher: D,
        credentials_provider: P,
        region: region::Region,
    ) -> IotClient
    where
        P: ProvideAwsCredentials + Send + Sync + 'static,
        P::Future: Send,
        D: DispatchSignedRequest + Send + Sync + 'static,
        D::Future: Send,
    {
        Self::new_with_client(
            Client::new_with(credentials_provider, request_dispatcher),
            region,
        )
    }

    pub fn new_with_client(client: Client, region: region::Region) -> IotClient {
        IotClient { client, region }
    }
}

impl Iot for IotClient {
    /// <p>Accepts a pending certificate transfer. The default state of the certificate is INACTIVE.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p>
    fn accept_certificate_transfer(
        &self,
        input: AcceptCertificateTransferRequest,
    ) -> RusotoFuture<(), AcceptCertificateTransferError> {
        let request_uri = format!(
            "/accept-certificate-transfer/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(AcceptCertificateTransferError::from_response(response))
                }))
            }
        })
    }

    /// <p>Adds a thing to a billing group.</p>
    fn add_thing_to_billing_group(
        &self,
        input: AddThingToBillingGroupRequest,
    ) -> RusotoFuture<AddThingToBillingGroupResponse, AddThingToBillingGroupError> {
        let request_uri = "/billing-groups/addThingToBillingGroup";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<AddThingToBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AddThingToBillingGroupError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Adds a thing to a thing group.</p>
    fn add_thing_to_thing_group(
        &self,
        input: AddThingToThingGroupRequest,
    ) -> RusotoFuture<AddThingToThingGroupResponse, AddThingToThingGroupError> {
        let request_uri = "/thing-groups/addThingToThingGroup";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<AddThingToThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AddThingToThingGroupError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p><p>Associates a group with a continuous job. The following criteria must be met: </p> <ul> <li> <p>The job must have been created with the <code>targetSelection</code> field set to &quot;CONTINUOUS&quot;.</p> </li> <li> <p>The job status must currently be &quot;IN_PROGRESS&quot;.</p> </li> <li> <p>The total number of targets associated with a job must not exceed 100.</p> </li> </ul></p>
    fn associate_targets_with_job(
        &self,
        input: AssociateTargetsWithJobRequest,
    ) -> RusotoFuture<AssociateTargetsWithJobResponse, AssociateTargetsWithJobError> {
        let request_uri = format!("/jobs/{job_id}/targets", job_id = input.job_id);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<AssociateTargetsWithJobResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(AssociateTargetsWithJobError::from_response(response))
                }))
            }
        })
    }

    /// <p>Attaches a policy to the specified target.</p>
    fn attach_policy(&self, input: AttachPolicyRequest) -> RusotoFuture<(), AttachPolicyError> {
        let request_uri = format!(
            "/target-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(AttachPolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Attaches the specified policy to the specified principal (certificate or other credential).</p> <p> <b>Note:</b> This API is deprecated. Please use <a>AttachPolicy</a> instead.</p>
    fn attach_principal_policy(
        &self,
        input: AttachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), AttachPrincipalPolicyError> {
        let request_uri = format!(
            "/principal-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AttachPrincipalPolicyError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Associates a Device Defender security profile with a thing group or this account. Each thing group or account can have up to five security profiles associated with it.</p>
    fn attach_security_profile(
        &self,
        input: AttachSecurityProfileRequest,
    ) -> RusotoFuture<AttachSecurityProfileResponse, AttachSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}/targets",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put(
            "securityProfileTargetArn",
            &input.security_profile_target_arn,
        );
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<AttachSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AttachSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Attaches the specified principal to the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p>
    fn attach_thing_principal(
        &self,
        input: AttachThingPrincipalRequest,
    ) -> RusotoFuture<AttachThingPrincipalResponse, AttachThingPrincipalError> {
        let request_uri = format!(
            "/things/{thing_name}/principals",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<AttachThingPrincipalResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(AttachThingPrincipalError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Cancels a mitigation action task that is in progress. If the task is not in progress, an InvalidRequestException occurs.</p>
    fn cancel_audit_mitigation_actions_task(
        &self,
        input: CancelAuditMitigationActionsTaskRequest,
    ) -> RusotoFuture<CancelAuditMitigationActionsTaskResponse, CancelAuditMitigationActionsTaskError>
    {
        let request_uri = format!(
            "/audit/mitigationactions/tasks/{task_id}/cancel",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CancelAuditMitigationActionsTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CancelAuditMitigationActionsTaskError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Cancels an audit that is in progress. The audit can be either scheduled or on-demand. If the audit is not in progress, an "InvalidRequestException" occurs.</p>
    fn cancel_audit_task(
        &self,
        input: CancelAuditTaskRequest,
    ) -> RusotoFuture<CancelAuditTaskResponse, CancelAuditTaskError> {
        let request_uri = format!("/audit/tasks/{task_id}/cancel", task_id = input.task_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CancelAuditTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CancelAuditTaskError::from_response(response))),
                )
            }
        })
    }

    /// <p>Cancels a pending transfer for the specified certificate.</p> <p> <b>Note</b> Only the transfer source account can use this operation to cancel a transfer. (Transfer destinations can use <a>RejectCertificateTransfer</a> instead.) After transfer, AWS IoT returns the certificate to the source account in the INACTIVE state. After the destination account has accepted the transfer, the transfer cannot be cancelled.</p> <p>After a certificate transfer is cancelled, the status of the certificate changes from PENDING_TRANSFER to INACTIVE.</p>
    fn cancel_certificate_transfer(
        &self,
        input: CancelCertificateTransferRequest,
    ) -> RusotoFuture<(), CancelCertificateTransferError> {
        let request_uri = format!(
            "/cancel-certificate-transfer/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CancelCertificateTransferError::from_response(response))
                }))
            }
        })
    }

    /// <p>Cancels a job.</p>
    fn cancel_job(
        &self,
        input: CancelJobRequest,
    ) -> RusotoFuture<CancelJobResponse, CancelJobError> {
        let request_uri = format!("/jobs/{job_id}/cancel", job_id = input.job_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CancelJobResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CancelJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Cancels the execution of a job for a given thing.</p>
    fn cancel_job_execution(
        &self,
        input: CancelJobExecutionRequest,
    ) -> RusotoFuture<(), CancelJobExecutionError> {
        let request_uri = format!(
            "/things/{thing_name}/jobs/{job_id}/cancel",
            job_id = input.job_id,
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CancelJobExecutionError::from_response(response))),
                )
            }
        })
    }

    /// <p>Clears the default authorizer.</p>
    fn clear_default_authorizer(
        &self,
    ) -> RusotoFuture<ClearDefaultAuthorizerResponse, ClearDefaultAuthorizerError> {
        let request_uri = "/default-authorizer";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ClearDefaultAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ClearDefaultAuthorizerError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Confirms a topic rule destination. When you create a rule requiring a destination, AWS IoT sends a confirmation message to the endpoint or base address you specify. The message includes a token which you pass back when calling <code>ConfirmTopicRuleDestination</code> to confirm that you own or have access to the endpoint.</p>
    fn confirm_topic_rule_destination(
        &self,
        input: ConfirmTopicRuleDestinationRequest,
    ) -> RusotoFuture<ConfirmTopicRuleDestinationResponse, ConfirmTopicRuleDestinationError> {
        let request_uri = format!(
            "/confirmdestination/{confirmation_token}",
            confirmation_token = input.confirmation_token
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ConfirmTopicRuleDestinationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ConfirmTopicRuleDestinationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates an authorizer.</p>
    fn create_authorizer(
        &self,
        input: CreateAuthorizerRequest,
    ) -> RusotoFuture<CreateAuthorizerResponse, CreateAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a billing group.</p>
    fn create_billing_group(
        &self,
        input: CreateBillingGroupRequest,
    ) -> RusotoFuture<CreateBillingGroupResponse, CreateBillingGroupError> {
        let request_uri = format!(
            "/billing-groups/{billing_group_name}",
            billing_group_name = input.billing_group_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateBillingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates an X.509 certificate using the specified certificate signing request.</p> <p> <b>Note:</b> The CSR must include a public key that is either an RSA key with a length of at least 2048 bits or an ECC key from NIST P-256 or NIST P-384 curves. </p> <p> <b>Note:</b> Reusing the same certificate signing request (CSR) results in a distinct certificate.</p> <p>You can create multiple certificates in a batch by creating a directory, copying multiple .csr files into that directory, and then specifying that directory on the command line. The following commands show how to create a batch of certificates given a batch of CSRs.</p> <p>Assuming a set of CSRs are located inside of the directory my-csr-directory:</p> <p>On Linux and OS X, the command is:</p> <p>$ ls my-csr-directory/ | xargs -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>This command lists all of the CSRs in my-csr-directory and pipes each CSR file name to the aws iot create-certificate-from-csr AWS CLI command to create a certificate for the corresponding CSR.</p> <p>The aws iot create-certificate-from-csr part of the command can also be run in parallel to speed up the certificate creation process:</p> <p>$ ls my-csr-directory/ | xargs -P 10 -I {} aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/{}</p> <p>On Windows PowerShell, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; ls -Name my-csr-directory | %{aws iot create-certificate-from-csr --certificate-signing-request file://my-csr-directory/$_}</p> <p>On a Windows command prompt, the command to create certificates for all CSRs in my-csr-directory is:</p> <p>&gt; forfiles /p my-csr-directory /c "cmd /c aws iot create-certificate-from-csr --certificate-signing-request file://@path"</p>
    fn create_certificate_from_csr(
        &self,
        input: CreateCertificateFromCsrRequest,
    ) -> RusotoFuture<CreateCertificateFromCsrResponse, CreateCertificateFromCsrError> {
        let request_uri = "/certificates";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateCertificateFromCsrResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateCertificateFromCsrError::from_response(response))
                }))
            }
        })
    }

    /// <p><p>Creates a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn create_domain_configuration(
        &self,
        input: CreateDomainConfigurationRequest,
    ) -> RusotoFuture<CreateDomainConfigurationResponse, CreateDomainConfigurationError> {
        let request_uri = format!(
            "/domainConfigurations/{domain_configuration_name}",
            domain_configuration_name = input.domain_configuration_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateDomainConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateDomainConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates a dynamic thing group.</p>
    fn create_dynamic_thing_group(
        &self,
        input: CreateDynamicThingGroupRequest,
    ) -> RusotoFuture<CreateDynamicThingGroupResponse, CreateDynamicThingGroupError> {
        let request_uri = format!(
            "/dynamic-thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateDynamicThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateDynamicThingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates a job.</p>
    fn create_job(
        &self,
        input: CreateJobRequest,
    ) -> RusotoFuture<CreateJobResponse, CreateJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateJobResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a 2048-bit RSA key pair and issues an X.509 certificate using the issued public key. You can also call <code>CreateKeysAndCertificate</code> over MQTT from a device, for more information, see <a href="https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api">Provisioning MQTT API</a>.</p> <p> <b>Note</b> This is the only time AWS IoT issues the private key for this certificate, so it is important to keep it in a secure location.</p>
    fn create_keys_and_certificate(
        &self,
        input: CreateKeysAndCertificateRequest,
    ) -> RusotoFuture<CreateKeysAndCertificateResponse, CreateKeysAndCertificateError> {
        let request_uri = "/keys-and-certificate";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateKeysAndCertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateKeysAndCertificateError::from_response(response))
                }))
            }
        })
    }

    /// <p>Defines an action that can be applied to audit findings by using StartAuditMitigationActionsTask. Each mitigation action can apply only one type of change.</p>
    fn create_mitigation_action(
        &self,
        input: CreateMitigationActionRequest,
    ) -> RusotoFuture<CreateMitigationActionResponse, CreateMitigationActionError> {
        let request_uri = format!(
            "/mitigationactions/actions/{action_name}",
            action_name = input.action_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateMitigationActionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreateMitigationActionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates an AWS IoT OTAUpdate on a target group of things or groups.</p>
    fn create_ota_update(
        &self,
        input: CreateOTAUpdateRequest,
    ) -> RusotoFuture<CreateOTAUpdateResponse, CreateOTAUpdateError> {
        let request_uri = format!(
            "/otaUpdates/{ota_update_id}",
            ota_update_id = input.ota_update_id
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateOTAUpdateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateOTAUpdateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates an AWS IoT policy.</p> <p>The created policy is the default version for the policy. This operation creates a policy version with a version identifier of <b>1</b> and sets <b>1</b> as the policy's default version.</p>
    fn create_policy(
        &self,
        input: CreatePolicyRequest,
    ) -> RusotoFuture<CreatePolicyResponse, CreatePolicyError> {
        let request_uri = format!("/policies/{policy_name}", policy_name = input.policy_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreatePolicyResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreatePolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a new version of the specified AWS IoT policy. To update a policy, create a new policy version. A managed policy can have up to five versions. If the policy has five versions, you must use <a>DeletePolicyVersion</a> to delete an existing version before you create a new one.</p> <p>Optionally, you can set the new version as the policy's default version. The default version is the operative version (that is, the version that is in effect for the certificates to which the policy is attached).</p>
    fn create_policy_version(
        &self,
        input: CreatePolicyVersionRequest,
    ) -> RusotoFuture<CreatePolicyVersionResponse, CreatePolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_default {
            params.put("setAsDefault", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreatePolicyVersionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreatePolicyVersionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a provisioning claim.</p>
    fn create_provisioning_claim(
        &self,
        input: CreateProvisioningClaimRequest,
    ) -> RusotoFuture<CreateProvisioningClaimResponse, CreateProvisioningClaimError> {
        let request_uri = format!(
            "/provisioning-templates/{template_name}/provisioning-claim",
            template_name = input.template_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateProvisioningClaimResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateProvisioningClaimError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates a fleet provisioning template.</p>
    fn create_provisioning_template(
        &self,
        input: CreateProvisioningTemplateRequest,
    ) -> RusotoFuture<CreateProvisioningTemplateResponse, CreateProvisioningTemplateError> {
        let request_uri = "/provisioning-templates";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateProvisioningTemplateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateProvisioningTemplateError::from_response(response))
                }))
            }
        })
    }

    /// <p>Creates a new version of a fleet provisioning template.</p>
    fn create_provisioning_template_version(
        &self,
        input: CreateProvisioningTemplateVersionRequest,
    ) -> RusotoFuture<
        CreateProvisioningTemplateVersionResponse,
        CreateProvisioningTemplateVersionError,
    > {
        let request_uri = format!(
            "/provisioning-templates/{template_name}/versions",
            template_name = input.template_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.set_as_default {
            params.put("setAsDefault", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateProvisioningTemplateVersionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateProvisioningTemplateVersionError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Creates a role alias.</p>
    fn create_role_alias(
        &self,
        input: CreateRoleAliasRequest,
    ) -> RusotoFuture<CreateRoleAliasResponse, CreateRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateRoleAliasResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a scheduled audit that is run at a specified time interval.</p>
    fn create_scheduled_audit(
        &self,
        input: CreateScheduledAuditRequest,
    ) -> RusotoFuture<CreateScheduledAuditResponse, CreateScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateScheduledAuditResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreateScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a Device Defender security profile.</p>
    fn create_security_profile(
        &self,
        input: CreateSecurityProfileRequest,
    ) -> RusotoFuture<CreateSecurityProfileResponse, CreateSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(CreateSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a stream for delivering one or more large files in chunks over MQTT. A stream transports data bytes in chunks or blocks packaged as MQTT messages from a source like S3. You can have one or more files associated with a stream.</p>
    fn create_stream(
        &self,
        input: CreateStreamRequest,
    ) -> RusotoFuture<CreateStreamResponse, CreateStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateStreamResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p><p>Creates a thing record in the registry. If this call is made multiple times using the same thing name and configuration, the call will succeed. If this call is made with the same thing name but different configuration a <code>ResourceAlreadyExistsException</code> is thrown.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing(
        &self,
        input: CreateThingRequest,
    ) -> RusotoFuture<CreateThingResponse, CreateThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateThingError::from_response(response))),
                )
            }
        })
    }

    /// <p><p>Create a thing group.</p> <note> <p>This is a control plane operation. See <a href="https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html">Authorization</a> for information about authorizing control plane actions.</p> </note></p>
    fn create_thing_group(
        &self,
        input: CreateThingGroupRequest,
    ) -> RusotoFuture<CreateThingGroupResponse, CreateThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a new thing type.</p>
    fn create_thing_type(
        &self,
        input: CreateThingTypeRequest,
    ) -> RusotoFuture<CreateThingTypeResponse, CreateThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateThingTypeResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn create_topic_rule(
        &self,
        input: CreateTopicRuleRequest,
    ) -> RusotoFuture<(), CreateTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input.topic_rule_payload).unwrap());
        request.set_payload(encoded);

        if let Some(ref tags) = input.tags {
            request.add_header("x-amz-tagging", &tags.to_string());
        }

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(CreateTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Creates a topic rule destination. The destination must be confirmed prior to use.</p>
    fn create_topic_rule_destination(
        &self,
        input: CreateTopicRuleDestinationRequest,
    ) -> RusotoFuture<CreateTopicRuleDestinationResponse, CreateTopicRuleDestinationError> {
        let request_uri = "/destinations";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<CreateTopicRuleDestinationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(CreateTopicRuleDestinationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Restores the default settings for Device Defender audits for this account. Any configuration data you entered is deleted and all audit checks are reset to disabled. </p>
    fn delete_account_audit_configuration(
        &self,
        input: DeleteAccountAuditConfigurationRequest,
    ) -> RusotoFuture<DeleteAccountAuditConfigurationResponse, DeleteAccountAuditConfigurationError>
    {
        let request_uri = "/audit/configuration";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.delete_scheduled_audits {
            params.put("deleteScheduledAudits", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteAccountAuditConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteAccountAuditConfigurationError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Deletes an authorizer.</p>
    fn delete_authorizer(
        &self,
        input: DeleteAuthorizerRequest,
    ) -> RusotoFuture<DeleteAuthorizerResponse, DeleteAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the billing group.</p>
    fn delete_billing_group(
        &self,
        input: DeleteBillingGroupRequest,
    ) -> RusotoFuture<DeleteBillingGroupResponse, DeleteBillingGroupError> {
        let request_uri = format!(
            "/billing-groups/{billing_group_name}",
            billing_group_name = input.billing_group_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteBillingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a registered CA certificate.</p>
    fn delete_ca_certificate(
        &self,
        input: DeleteCACertificateRequest,
    ) -> RusotoFuture<DeleteCACertificateResponse, DeleteCACertificateError> {
        let request_uri = format!(
            "/cacertificate/{ca_certificate_id}",
            ca_certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteCACertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes the specified certificate.</p> <p>A certificate cannot be deleted if it has a policy or IoT thing attached to it or if its status is set to ACTIVE. To delete a certificate, first use the <a>DetachPrincipalPolicy</a> API to detach all policies. Next, use the <a>UpdateCertificate</a> API to set the certificate to the INACTIVE status.</p>
    fn delete_certificate(
        &self,
        input: DeleteCertificateRequest,
    ) -> RusotoFuture<(), DeleteCertificateError> {
        let request_uri = format!(
            "/certificates/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.force_delete {
            params.put("forceDelete", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteCertificateError::from_response(response))),
                )
            }
        })
    }

    /// <p><p>Deletes the specified domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn delete_domain_configuration(
        &self,
        input: DeleteDomainConfigurationRequest,
    ) -> RusotoFuture<DeleteDomainConfigurationResponse, DeleteDomainConfigurationError> {
        let request_uri = format!(
            "/domainConfigurations/{domain_configuration_name}",
            domain_configuration_name = input.domain_configuration_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteDomainConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteDomainConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Deletes a dynamic thing group.</p>
    fn delete_dynamic_thing_group(
        &self,
        input: DeleteDynamicThingGroupRequest,
    ) -> RusotoFuture<DeleteDynamicThingGroupResponse, DeleteDynamicThingGroupError> {
        let request_uri = format!(
            "/dynamic-thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteDynamicThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteDynamicThingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Deletes a job and its related job executions.</p> <p>Deleting a job may take time, depending on the number of job executions created for the job and various other factors. While the job is being deleted, the status of the job will be shown as "DELETION_IN_PROGRESS". Attempting to delete or cancel a job whose status is already "DELETION_IN_PROGRESS" will result in an error.</p> <p>Only 10 jobs may have status "DELETION_IN_PROGRESS" at the same time, or a LimitExceededException will occur.</p>
    fn delete_job(&self, input: DeleteJobRequest) -> RusotoFuture<(), DeleteJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a job execution.</p>
    fn delete_job_execution(
        &self,
        input: DeleteJobExecutionRequest,
    ) -> RusotoFuture<(), DeleteJobExecutionError> {
        let request_uri = format!(
            "/things/{thing_name}/jobs/{job_id}/executionNumber/{execution_number}",
            execution_number = input.execution_number,
            job_id = input.job_id,
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.force {
            params.put("force", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteJobExecutionError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a defined mitigation action from your AWS account.</p>
    fn delete_mitigation_action(
        &self,
        input: DeleteMitigationActionRequest,
    ) -> RusotoFuture<DeleteMitigationActionResponse, DeleteMitigationActionError> {
        let request_uri = format!(
            "/mitigationactions/actions/{action_name}",
            action_name = input.action_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteMitigationActionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteMitigationActionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Delete an OTA update.</p>
    fn delete_ota_update(
        &self,
        input: DeleteOTAUpdateRequest,
    ) -> RusotoFuture<DeleteOTAUpdateResponse, DeleteOTAUpdateError> {
        let request_uri = format!(
            "/otaUpdates/{ota_update_id}",
            ota_update_id = input.ota_update_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.delete_stream {
            params.put("deleteStream", x);
        }
        if let Some(ref x) = input.force_delete_aws_job {
            params.put("forceDeleteAWSJob", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteOTAUpdateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteOTAUpdateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified policy.</p> <p>A policy cannot be deleted if it has non-default versions or it is attached to any certificate.</p> <p>To delete a policy, use the DeletePolicyVersion API to delete all non-default versions of the policy; use the DetachPrincipalPolicy API to detach the policy from any certificate; and then use the DeletePolicy API to delete the policy.</p> <p>When a policy is deleted using DeletePolicy, its default version is deleted with it.</p>
    fn delete_policy(&self, input: DeletePolicyRequest) -> RusotoFuture<(), DeletePolicyError> {
        let request_uri = format!("/policies/{policy_name}", policy_name = input.policy_name);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeletePolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified version of the specified policy. You cannot delete the default version of a policy using this API. To delete the default version of a policy, use <a>DeletePolicy</a>. To find out which version of a policy is marked as the default version, use ListPolicyVersions.</p>
    fn delete_policy_version(
        &self,
        input: DeletePolicyVersionRequest,
    ) -> RusotoFuture<(), DeletePolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version/{policy_version_id}",
            policy_name = input.policy_name,
            policy_version_id = input.policy_version_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeletePolicyVersionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a fleet provisioning template.</p>
    fn delete_provisioning_template(
        &self,
        input: DeleteProvisioningTemplateRequest,
    ) -> RusotoFuture<DeleteProvisioningTemplateResponse, DeleteProvisioningTemplateError> {
        let request_uri = format!(
            "/provisioning-templates/{template_name}",
            template_name = input.template_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteProvisioningTemplateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteProvisioningTemplateError::from_response(response))
                }))
            }
        })
    }

    /// <p>Deletes a fleet provisioning template version.</p>
    fn delete_provisioning_template_version(
        &self,
        input: DeleteProvisioningTemplateVersionRequest,
    ) -> RusotoFuture<
        DeleteProvisioningTemplateVersionResponse,
        DeleteProvisioningTemplateVersionError,
    > {
        let request_uri = format!(
            "/provisioning-templates/{template_name}/versions/{version_id}",
            template_name = input.template_name,
            version_id = input.version_id
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteProvisioningTemplateVersionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteProvisioningTemplateVersionError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Deletes a CA certificate registration code.</p>
    fn delete_registration_code(
        &self,
    ) -> RusotoFuture<DeleteRegistrationCodeResponse, DeleteRegistrationCodeError> {
        let request_uri = "/registrationcode";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteRegistrationCodeResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteRegistrationCodeError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a role alias</p>
    fn delete_role_alias(
        &self,
        input: DeleteRoleAliasRequest,
    ) -> RusotoFuture<DeleteRoleAliasResponse, DeleteRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteRoleAliasResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a scheduled audit.</p>
    fn delete_scheduled_audit(
        &self,
        input: DeleteScheduledAuditRequest,
    ) -> RusotoFuture<DeleteScheduledAuditResponse, DeleteScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteScheduledAuditResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a Device Defender security profile.</p>
    fn delete_security_profile(
        &self,
        input: DeleteSecurityProfileRequest,
    ) -> RusotoFuture<DeleteSecurityProfileResponse, DeleteSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deletes a stream.</p>
    fn delete_stream(
        &self,
        input: DeleteStreamRequest,
    ) -> RusotoFuture<DeleteStreamResponse, DeleteStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteStreamResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified thing. Returns successfully with no error if the deletion is successful or you specify a thing that doesn't exist.</p>
    fn delete_thing(
        &self,
        input: DeleteThingRequest,
    ) -> RusotoFuture<DeleteThingResponse, DeleteThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a thing group.</p>
    fn delete_thing_group(
        &self,
        input: DeleteThingGroupRequest,
    ) -> RusotoFuture<DeleteThingGroupResponse, DeleteThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the specified thing type. You cannot delete a thing type if it has things associated with it. To delete a thing type, first mark it as deprecated by calling <a>DeprecateThingType</a>, then remove any associated things by calling <a>UpdateThing</a> to change the thing type on any associated thing, and finally use <a>DeleteThingType</a> to delete the thing type.</p>
    fn delete_thing_type(
        &self,
        input: DeleteThingTypeRequest,
    ) -> RusotoFuture<DeleteThingTypeResponse, DeleteThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteThingTypeResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes the rule.</p>
    fn delete_topic_rule(
        &self,
        input: DeleteTopicRuleRequest,
    ) -> RusotoFuture<(), DeleteTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeleteTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Deletes a topic rule destination.</p>
    fn delete_topic_rule_destination(
        &self,
        input: DeleteTopicRuleDestinationRequest,
    ) -> RusotoFuture<DeleteTopicRuleDestinationResponse, DeleteTopicRuleDestinationError> {
        let request_uri = format!("/destinations/{arn}", arn = input.arn);

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeleteTopicRuleDestinationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DeleteTopicRuleDestinationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Deletes a logging level.</p>
    fn delete_v2_logging_level(
        &self,
        input: DeleteV2LoggingLevelRequest,
    ) -> RusotoFuture<(), DeleteV2LoggingLevelError> {
        let request_uri = "/v2LoggingLevel";

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("targetName", &input.target_name);
        params.put("targetType", &input.target_type);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DeleteV2LoggingLevelError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Deprecates a thing type. You can not associate new things with deprecated thing type.</p>
    fn deprecate_thing_type(
        &self,
        input: DeprecateThingTypeRequest,
    ) -> RusotoFuture<DeprecateThingTypeResponse, DeprecateThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}/deprecate",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DeprecateThingTypeResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DeprecateThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn describe_account_audit_configuration(
        &self,
    ) -> RusotoFuture<
        DescribeAccountAuditConfigurationResponse,
        DescribeAccountAuditConfigurationError,
    > {
        let request_uri = "/audit/configuration";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeAccountAuditConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeAccountAuditConfigurationError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Gets information about a single audit finding. Properties include the reason for noncompliance, the severity of the issue, and when the audit that returned the finding was started.</p>
    fn describe_audit_finding(
        &self,
        input: DescribeAuditFindingRequest,
    ) -> RusotoFuture<DescribeAuditFindingResponse, DescribeAuditFindingError> {
        let request_uri = format!(
            "/audit/findings/{finding_id}",
            finding_id = input.finding_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeAuditFindingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeAuditFindingError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about an audit mitigation task that is used to apply mitigation actions to a set of audit findings. Properties include the actions being applied, the audit checks to which they're being applied, the task status, and aggregated task statistics.</p>
    fn describe_audit_mitigation_actions_task(
        &self,
        input: DescribeAuditMitigationActionsTaskRequest,
    ) -> RusotoFuture<
        DescribeAuditMitigationActionsTaskResponse,
        DescribeAuditMitigationActionsTaskError,
    > {
        let request_uri = format!(
            "/audit/mitigationactions/tasks/{task_id}",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeAuditMitigationActionsTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeAuditMitigationActionsTaskError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Gets information about a Device Defender audit.</p>
    fn describe_audit_task(
        &self,
        input: DescribeAuditTaskRequest,
    ) -> RusotoFuture<DescribeAuditTaskResponse, DescribeAuditTaskError> {
        let request_uri = format!("/audit/tasks/{task_id}", task_id = input.task_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeAuditTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeAuditTaskError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes an authorizer.</p>
    fn describe_authorizer(
        &self,
        input: DescribeAuthorizerRequest,
    ) -> RusotoFuture<DescribeAuthorizerResponse, DescribeAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Returns information about a billing group.</p>
    fn describe_billing_group(
        &self,
        input: DescribeBillingGroupRequest,
    ) -> RusotoFuture<DescribeBillingGroupResponse, DescribeBillingGroupError> {
        let request_uri = format!(
            "/billing-groups/{billing_group_name}",
            billing_group_name = input.billing_group_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeBillingGroupError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Describes a registered CA certificate.</p>
    fn describe_ca_certificate(
        &self,
        input: DescribeCACertificateRequest,
    ) -> RusotoFuture<DescribeCACertificateResponse, DescribeCACertificateError> {
        let request_uri = format!(
            "/cacertificate/{ca_certificate_id}",
            ca_certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeCACertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about the specified certificate.</p>
    fn describe_certificate(
        &self,
        input: DescribeCertificateRequest,
    ) -> RusotoFuture<DescribeCertificateResponse, DescribeCertificateError> {
        let request_uri = format!(
            "/certificates/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeCertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeCertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Describes the default authorizer.</p>
    fn describe_default_authorizer(
        &self,
    ) -> RusotoFuture<DescribeDefaultAuthorizerResponse, DescribeDefaultAuthorizerError> {
        let request_uri = "/default-authorizer";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeDefaultAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeDefaultAuthorizerError::from_response(response))
                }))
            }
        })
    }

    /// <p><p>Gets summary information about a domain configuration.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn describe_domain_configuration(
        &self,
        input: DescribeDomainConfigurationRequest,
    ) -> RusotoFuture<DescribeDomainConfigurationResponse, DescribeDomainConfigurationError> {
        let request_uri = format!(
            "/domainConfigurations/{domain_configuration_name}",
            domain_configuration_name = input.domain_configuration_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeDomainConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeDomainConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Returns a unique endpoint specific to the AWS account making the call.</p>
    fn describe_endpoint(
        &self,
        input: DescribeEndpointRequest,
    ) -> RusotoFuture<DescribeEndpointResponse, DescribeEndpointError> {
        let request_uri = "/endpoint";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.endpoint_type {
            params.put("endpointType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeEndpointResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeEndpointError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes event configurations.</p>
    fn describe_event_configurations(
        &self,
    ) -> RusotoFuture<DescribeEventConfigurationsResponse, DescribeEventConfigurationsError> {
        let request_uri = "/event-configurations";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeEventConfigurationsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeEventConfigurationsError::from_response(response))
                }))
            }
        })
    }

    /// <p>Describes a search index.</p>
    fn describe_index(
        &self,
        input: DescribeIndexRequest,
    ) -> RusotoFuture<DescribeIndexResponse, DescribeIndexError> {
        let request_uri = format!("/indices/{index_name}", index_name = input.index_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeIndexResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeIndexError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a job.</p>
    fn describe_job(
        &self,
        input: DescribeJobRequest,
    ) -> RusotoFuture<DescribeJobResponse, DescribeJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeJobResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a job execution.</p>
    fn describe_job_execution(
        &self,
        input: DescribeJobExecutionRequest,
    ) -> RusotoFuture<DescribeJobExecutionResponse, DescribeJobExecutionError> {
        let request_uri = format!(
            "/things/{thing_name}/jobs/{job_id}",
            job_id = input.job_id,
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.execution_number {
            params.put("executionNumber", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeJobExecutionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeJobExecutionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about a mitigation action.</p>
    fn describe_mitigation_action(
        &self,
        input: DescribeMitigationActionRequest,
    ) -> RusotoFuture<DescribeMitigationActionResponse, DescribeMitigationActionError> {
        let request_uri = format!(
            "/mitigationactions/actions/{action_name}",
            action_name = input.action_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeMitigationActionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeMitigationActionError::from_response(response))
                }))
            }
        })
    }

    /// <p>Returns information about a fleet provisioning template.</p>
    fn describe_provisioning_template(
        &self,
        input: DescribeProvisioningTemplateRequest,
    ) -> RusotoFuture<DescribeProvisioningTemplateResponse, DescribeProvisioningTemplateError> {
        let request_uri = format!(
            "/provisioning-templates/{template_name}",
            template_name = input.template_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeProvisioningTemplateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeProvisioningTemplateError::from_response(response))
                }))
            }
        })
    }

    /// <p>Returns information about a fleet provisioning template version.</p>
    fn describe_provisioning_template_version(
        &self,
        input: DescribeProvisioningTemplateVersionRequest,
    ) -> RusotoFuture<
        DescribeProvisioningTemplateVersionResponse,
        DescribeProvisioningTemplateVersionError,
    > {
        let request_uri = format!(
            "/provisioning-templates/{template_name}/versions/{version_id}",
            template_name = input.template_name,
            version_id = input.version_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeProvisioningTemplateVersionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeProvisioningTemplateVersionError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Describes a role alias.</p>
    fn describe_role_alias(
        &self,
        input: DescribeRoleAliasRequest,
    ) -> RusotoFuture<DescribeRoleAliasResponse, DescribeRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeRoleAliasResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about a scheduled audit.</p>
    fn describe_scheduled_audit(
        &self,
        input: DescribeScheduledAuditRequest,
    ) -> RusotoFuture<DescribeScheduledAuditResponse, DescribeScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeScheduledAuditResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DescribeScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets information about a Device Defender security profile.</p>
    fn describe_security_profile(
        &self,
        input: DescribeSecurityProfileRequest,
    ) -> RusotoFuture<DescribeSecurityProfileResponse, DescribeSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeSecurityProfileError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets information about a stream.</p>
    fn describe_stream(
        &self,
        input: DescribeStreamRequest,
    ) -> RusotoFuture<DescribeStreamResponse, DescribeStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeStreamResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the specified thing.</p>
    fn describe_thing(
        &self,
        input: DescribeThingRequest,
    ) -> RusotoFuture<DescribeThingResponse, DescribeThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describe a thing group.</p>
    fn describe_thing_group(
        &self,
        input: DescribeThingGroupRequest,
    ) -> RusotoFuture<DescribeThingGroupResponse, DescribeThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Describes a bulk thing provisioning task.</p>
    fn describe_thing_registration_task(
        &self,
        input: DescribeThingRegistrationTaskRequest,
    ) -> RusotoFuture<DescribeThingRegistrationTaskResponse, DescribeThingRegistrationTaskError>
    {
        let request_uri = format!(
            "/thing-registration-tasks/{task_id}",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeThingRegistrationTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(DescribeThingRegistrationTaskError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets information about the specified thing type.</p>
    fn describe_thing_type(
        &self,
        input: DescribeThingTypeRequest,
    ) -> RusotoFuture<DescribeThingTypeResponse, DescribeThingTypeError> {
        let request_uri = format!(
            "/thing-types/{thing_type_name}",
            thing_type_name = input.thing_type_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DescribeThingTypeResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DescribeThingTypeError::from_response(response))),
                )
            }
        })
    }

    /// <p>Detaches a policy from the specified target.</p>
    fn detach_policy(&self, input: DetachPolicyRequest) -> RusotoFuture<(), DetachPolicyError> {
        let request_uri = format!(
            "/target-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DetachPolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Removes the specified policy from the specified certificate.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>DetachPolicy</a> instead.</p>
    fn detach_principal_policy(
        &self,
        input: DetachPrincipalPolicyRequest,
    ) -> RusotoFuture<(), DetachPrincipalPolicyError> {
        let request_uri = format!(
            "/principal-policies/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DetachPrincipalPolicyError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Disassociates a Device Defender security profile from a thing group or from this account.</p>
    fn detach_security_profile(
        &self,
        input: DetachSecurityProfileRequest,
    ) -> RusotoFuture<DetachSecurityProfileResponse, DetachSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}/targets",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put(
            "securityProfileTargetArn",
            &input.security_profile_target_arn,
        );
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DetachSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DetachSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p><p>Detaches the specified principal from the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p> <note> <p>This call is asynchronous. It might take several seconds for the detachment to propagate.</p> </note></p>
    fn detach_thing_principal(
        &self,
        input: DetachThingPrincipalRequest,
    ) -> RusotoFuture<DetachThingPrincipalResponse, DetachThingPrincipalError> {
        let request_uri = format!(
            "/things/{thing_name}/principals",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("DELETE", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-principal", &input.principal);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<DetachThingPrincipalResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(DetachThingPrincipalError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Disables the rule.</p>
    fn disable_topic_rule(
        &self,
        input: DisableTopicRuleRequest,
    ) -> RusotoFuture<(), DisableTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}/disable", rule_name = input.rule_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(DisableTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Enables the rule.</p>
    fn enable_topic_rule(
        &self,
        input: EnableTopicRuleRequest,
    ) -> RusotoFuture<(), EnableTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}/enable", rule_name = input.rule_name);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(EnableTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Returns the approximate count of unique values that match the query.</p>
    fn get_cardinality(
        &self,
        input: GetCardinalityRequest,
    ) -> RusotoFuture<GetCardinalityResponse, GetCardinalityError> {
        let request_uri = "/indices/cardinality";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetCardinalityResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetCardinalityError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets a list of the policies that have an effect on the authorization behavior of the specified device when it connects to the AWS IoT device gateway.</p>
    fn get_effective_policies(
        &self,
        input: GetEffectivePoliciesRequest,
    ) -> RusotoFuture<GetEffectivePoliciesResponse, GetEffectivePoliciesError> {
        let request_uri = "/effective-policies";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.thing_name {
            params.put("thingName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetEffectivePoliciesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(GetEffectivePoliciesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Gets the indexing configuration.</p>
    fn get_indexing_configuration(
        &self,
    ) -> RusotoFuture<GetIndexingConfigurationResponse, GetIndexingConfigurationError> {
        let request_uri = "/indexing/config";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetIndexingConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(GetIndexingConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets a job document.</p>
    fn get_job_document(
        &self,
        input: GetJobDocumentRequest,
    ) -> RusotoFuture<GetJobDocumentResponse, GetJobDocumentError> {
        let request_uri = format!("/jobs/{job_id}/job-document", job_id = input.job_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetJobDocumentResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetJobDocumentError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>GetV2LoggingOptions</code> instead.</p>
    fn get_logging_options(
        &self,
    ) -> RusotoFuture<GetLoggingOptionsResponse, GetLoggingOptionsError> {
        let request_uri = "/loggingOptions";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetLoggingOptionsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetLoggingOptionsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets an OTA update.</p>
    fn get_ota_update(
        &self,
        input: GetOTAUpdateRequest,
    ) -> RusotoFuture<GetOTAUpdateResponse, GetOTAUpdateError> {
        let request_uri = format!(
            "/otaUpdates/{ota_update_id}",
            ota_update_id = input.ota_update_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetOTAUpdateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetOTAUpdateError::from_response(response))),
                )
            }
        })
    }

    /// <p>Groups the aggregated values that match the query into percentile groupings. The default percentile groupings are: 1,5,25,50,75,95,99, although you can specify your own when you call <code>GetPercentiles</code>. This function returns a value for each percentile group specified (or the default percentile groupings). The percentile group "1" contains the aggregated field value that occurs in approximately one percent of the values that match the query. The percentile group "5" contains the aggregated field value that occurs in approximately five percent of the values that match the query, and so on. The result is an approximation, the more values that match the query, the more accurate the percentile values.</p>
    fn get_percentiles(
        &self,
        input: GetPercentilesRequest,
    ) -> RusotoFuture<GetPercentilesResponse, GetPercentilesError> {
        let request_uri = "/indices/percentiles";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetPercentilesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetPercentilesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the specified policy with the policy document of the default version.</p>
    fn get_policy(
        &self,
        input: GetPolicyRequest,
    ) -> RusotoFuture<GetPolicyResponse, GetPolicyError> {
        let request_uri = format!("/policies/{policy_name}", policy_name = input.policy_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetPolicyResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetPolicyError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the specified policy version.</p>
    fn get_policy_version(
        &self,
        input: GetPolicyVersionRequest,
    ) -> RusotoFuture<GetPolicyVersionResponse, GetPolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version/{policy_version_id}",
            policy_name = input.policy_name,
            policy_version_id = input.policy_version_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetPolicyVersionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetPolicyVersionError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets a registration code used to register a CA certificate with AWS IoT.</p>
    fn get_registration_code(
        &self,
    ) -> RusotoFuture<GetRegistrationCodeResponse, GetRegistrationCodeError> {
        let request_uri = "/registrationcode";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetRegistrationCodeResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(GetRegistrationCodeError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Returns the count, average, sum, minimum, maximum, sum of squares, variance, and standard deviation for the specified aggregated field. If the aggregation field is of type <code>String</code>, only the count statistic is returned.</p>
    fn get_statistics(
        &self,
        input: GetStatisticsRequest,
    ) -> RusotoFuture<GetStatisticsResponse, GetStatisticsError> {
        let request_uri = "/indices/statistics";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetStatisticsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetStatisticsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about the rule.</p>
    fn get_topic_rule(
        &self,
        input: GetTopicRuleRequest,
    ) -> RusotoFuture<GetTopicRuleResponse, GetTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetTopicRuleResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(GetTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets information about a topic rule destination.</p>
    fn get_topic_rule_destination(
        &self,
        input: GetTopicRuleDestinationRequest,
    ) -> RusotoFuture<GetTopicRuleDestinationResponse, GetTopicRuleDestinationError> {
        let request_uri = format!("/destinations/{arn}", arn = input.arn);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetTopicRuleDestinationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(GetTopicRuleDestinationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Gets the fine grained logging options.</p>
    fn get_v2_logging_options(
        &self,
    ) -> RusotoFuture<GetV2LoggingOptionsResponse, GetV2LoggingOptionsError> {
        let request_uri = "/v2LoggingOptions";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<GetV2LoggingOptionsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(GetV2LoggingOptionsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the active violations for a given Device Defender security profile.</p>
    fn list_active_violations(
        &self,
        input: ListActiveViolationsRequest,
    ) -> RusotoFuture<ListActiveViolationsResponse, ListActiveViolationsError> {
        let request_uri = "/active-violations";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.security_profile_name {
            params.put("securityProfileName", x);
        }
        if let Some(ref x) = input.thing_name {
            params.put("thingName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListActiveViolationsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListActiveViolationsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the policies attached to the specified thing group.</p>
    fn list_attached_policies(
        &self,
        input: ListAttachedPoliciesRequest,
    ) -> RusotoFuture<ListAttachedPoliciesResponse, ListAttachedPoliciesError> {
        let request_uri = format!("/attached-policies/{target}", target = input.target);

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListAttachedPoliciesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListAttachedPoliciesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the findings (results) of a Device Defender audit or of the audits performed during a specified time period. (Findings are retained for 180 days.)</p>
    fn list_audit_findings(
        &self,
        input: ListAuditFindingsRequest,
    ) -> RusotoFuture<ListAuditFindingsResponse, ListAuditFindingsError> {
        let request_uri = "/audit/findings";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListAuditFindingsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListAuditFindingsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets the status of audit mitigation action tasks that were executed.</p>
    fn list_audit_mitigation_actions_executions(
        &self,
        input: ListAuditMitigationActionsExecutionsRequest,
    ) -> RusotoFuture<
        ListAuditMitigationActionsExecutionsResponse,
        ListAuditMitigationActionsExecutionsError,
    > {
        let request_uri = "/audit/mitigationactions/executions";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.action_status {
            params.put("actionStatus", x);
        }
        params.put("findingId", &input.finding_id);
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("taskId", &input.task_id);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListAuditMitigationActionsExecutionsResponse, _>(
                    )?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListAuditMitigationActionsExecutionsError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Gets a list of audit mitigation action tasks that match the specified filters.</p>
    fn list_audit_mitigation_actions_tasks(
        &self,
        input: ListAuditMitigationActionsTasksRequest,
    ) -> RusotoFuture<ListAuditMitigationActionsTasksResponse, ListAuditMitigationActionsTasksError>
    {
        let request_uri = "/audit/mitigationactions/tasks";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.audit_task_id {
            params.put("auditTaskId", x);
        }
        params.put("endTime", &input.end_time);
        if let Some(ref x) = input.finding_id {
            params.put("findingId", x);
        }
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("startTime", &input.start_time);
        if let Some(ref x) = input.task_status {
            params.put("taskStatus", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListAuditMitigationActionsTasksResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListAuditMitigationActionsTasksError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Lists the Device Defender audits that have been performed during a given time period.</p>
    fn list_audit_tasks(
        &self,
        input: ListAuditTasksRequest,
    ) -> RusotoFuture<ListAuditTasksResponse, ListAuditTasksError> {
        let request_uri = "/audit/tasks";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("endTime", &input.end_time);
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("startTime", &input.start_time);
        if let Some(ref x) = input.task_status {
            params.put("taskStatus", x);
        }
        if let Some(ref x) = input.task_type {
            params.put("taskType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListAuditTasksResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListAuditTasksError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the authorizers registered in your account.</p>
    fn list_authorizers(
        &self,
        input: ListAuthorizersRequest,
    ) -> RusotoFuture<ListAuthorizersResponse, ListAuthorizersError> {
        let request_uri = "/authorizers/";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListAuthorizersResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListAuthorizersError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the billing groups you have created.</p>
    fn list_billing_groups(
        &self,
        input: ListBillingGroupsRequest,
    ) -> RusotoFuture<ListBillingGroupsResponse, ListBillingGroupsError> {
        let request_uri = "/billing-groups";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.name_prefix_filter {
            params.put("namePrefixFilter", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListBillingGroupsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListBillingGroupsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the CA certificates registered for your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_ca_certificates(
        &self,
        input: ListCACertificatesRequest,
    ) -> RusotoFuture<ListCACertificatesResponse, ListCACertificatesError> {
        let request_uri = "/cacertificates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListCACertificatesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListCACertificatesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the certificates registered in your AWS account.</p> <p>The results are paginated with a default page size of 25. You can use the returned marker to retrieve additional results.</p>
    fn list_certificates(
        &self,
        input: ListCertificatesRequest,
    ) -> RusotoFuture<ListCertificatesResponse, ListCertificatesError> {
        let request_uri = "/certificates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListCertificatesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListCertificatesError::from_response(response))),
                )
            }
        })
    }

    /// <p>List the device certificates signed by the specified CA certificate.</p>
    fn list_certificates_by_ca(
        &self,
        input: ListCertificatesByCARequest,
    ) -> RusotoFuture<ListCertificatesByCAResponse, ListCertificatesByCAError> {
        let request_uri = format!(
            "/certificates-by-ca/{ca_certificate_id}",
            ca_certificate_id = input.ca_certificate_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListCertificatesByCAResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListCertificatesByCAError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p><p>Gets a list of domain configurations for the user. This list is sorted alphabetically by domain configuration name.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn list_domain_configurations(
        &self,
        input: ListDomainConfigurationsRequest,
    ) -> RusotoFuture<ListDomainConfigurationsResponse, ListDomainConfigurationsError> {
        let request_uri = "/domainConfigurations";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        if let Some(ref x) = input.service_type {
            params.put("serviceType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListDomainConfigurationsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListDomainConfigurationsError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the search indices.</p>
    fn list_indices(
        &self,
        input: ListIndicesRequest,
    ) -> RusotoFuture<ListIndicesResponse, ListIndicesError> {
        let request_uri = "/indices";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListIndicesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListIndicesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the job executions for a job.</p>
    fn list_job_executions_for_job(
        &self,
        input: ListJobExecutionsForJobRequest,
    ) -> RusotoFuture<ListJobExecutionsForJobResponse, ListJobExecutionsForJobError> {
        let request_uri = format!("/jobs/{job_id}/things", job_id = input.job_id);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListJobExecutionsForJobResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListJobExecutionsForJobError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the job executions for the specified thing.</p>
    fn list_job_executions_for_thing(
        &self,
        input: ListJobExecutionsForThingRequest,
    ) -> RusotoFuture<ListJobExecutionsForThingResponse, ListJobExecutionsForThingError> {
        let request_uri = format!("/things/{thing_name}/jobs", thing_name = input.thing_name);

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListJobExecutionsForThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListJobExecutionsForThingError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists jobs.</p>
    fn list_jobs(&self, input: ListJobsRequest) -> RusotoFuture<ListJobsResponse, ListJobsError> {
        let request_uri = "/jobs";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        if let Some(ref x) = input.target_selection {
            params.put("targetSelection", x);
        }
        if let Some(ref x) = input.thing_group_id {
            params.put("thingGroupId", x);
        }
        if let Some(ref x) = input.thing_group_name {
            params.put("thingGroupName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListJobsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListJobsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Gets a list of all mitigation actions that match the specified filter criteria.</p>
    fn list_mitigation_actions(
        &self,
        input: ListMitigationActionsRequest,
    ) -> RusotoFuture<ListMitigationActionsResponse, ListMitigationActionsError> {
        let request_uri = "/mitigationactions/actions";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.action_type {
            params.put("actionType", x);
        }
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListMitigationActionsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListMitigationActionsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists OTA updates.</p>
    fn list_ota_updates(
        &self,
        input: ListOTAUpdatesRequest,
    ) -> RusotoFuture<ListOTAUpdatesResponse, ListOTAUpdatesError> {
        let request_uri = "/otaUpdates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.ota_update_status {
            params.put("otaUpdateStatus", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListOTAUpdatesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListOTAUpdatesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists certificates that are being transferred but not yet accepted.</p>
    fn list_outgoing_certificates(
        &self,
        input: ListOutgoingCertificatesRequest,
    ) -> RusotoFuture<ListOutgoingCertificatesResponse, ListOutgoingCertificatesError> {
        let request_uri = "/certificates-out-going";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListOutgoingCertificatesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListOutgoingCertificatesError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists your policies.</p>
    fn list_policies(
        &self,
        input: ListPoliciesRequest,
    ) -> RusotoFuture<ListPoliciesResponse, ListPoliciesError> {
        let request_uri = "/policies";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListPoliciesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListPoliciesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the principals associated with the specified policy.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListTargetsForPolicy</a> instead.</p>
    fn list_policy_principals(
        &self,
        input: ListPolicyPrincipalsRequest,
    ) -> RusotoFuture<ListPolicyPrincipalsResponse, ListPolicyPrincipalsError> {
        let request_uri = "/policy-principals";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-policy", &input.policy_name);
        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListPolicyPrincipalsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListPolicyPrincipalsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the versions of the specified policy and identifies the default version.</p>
    fn list_policy_versions(
        &self,
        input: ListPolicyVersionsRequest,
    ) -> RusotoFuture<ListPolicyVersionsResponse, ListPolicyVersionsError> {
        let request_uri = format!(
            "/policies/{policy_name}/version",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListPolicyVersionsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListPolicyVersionsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the policies attached to the specified principal. If you use an Cognito identity, the ID must be in <a href="https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax">AmazonCognito Identity format</a>.</p> <p> <b>Note:</b> This API is deprecated. Please use <a>ListAttachedPolicies</a> instead.</p>
    fn list_principal_policies(
        &self,
        input: ListPrincipalPoliciesRequest,
    ) -> RusotoFuture<ListPrincipalPoliciesResponse, ListPrincipalPoliciesError> {
        let request_uri = "/principal-policies";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-iot-principal", &input.principal);
        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListPrincipalPoliciesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListPrincipalPoliciesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the things associated with the specified principal. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities. </p>
    fn list_principal_things(
        &self,
        input: ListPrincipalThingsRequest,
    ) -> RusotoFuture<ListPrincipalThingsResponse, ListPrincipalThingsError> {
        let request_uri = "/principals/things";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        request.add_header("x-amzn-principal", &input.principal);
        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListPrincipalThingsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListPrincipalThingsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>A list of fleet provisioning template versions.</p>
    fn list_provisioning_template_versions(
        &self,
        input: ListProvisioningTemplateVersionsRequest,
    ) -> RusotoFuture<ListProvisioningTemplateVersionsResponse, ListProvisioningTemplateVersionsError>
    {
        let request_uri = format!(
            "/provisioning-templates/{template_name}/versions",
            template_name = input.template_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListProvisioningTemplateVersionsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListProvisioningTemplateVersionsError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Lists the fleet provisioning templates in your AWS account.</p>
    fn list_provisioning_templates(
        &self,
        input: ListProvisioningTemplatesRequest,
    ) -> RusotoFuture<ListProvisioningTemplatesResponse, ListProvisioningTemplatesError> {
        let request_uri = "/provisioning-templates";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListProvisioningTemplatesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListProvisioningTemplatesError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the role aliases registered in your account.</p>
    fn list_role_aliases(
        &self,
        input: ListRoleAliasesRequest,
    ) -> RusotoFuture<ListRoleAliasesResponse, ListRoleAliasesError> {
        let request_uri = "/role-aliases";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListRoleAliasesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListRoleAliasesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists all of your scheduled audits.</p>
    fn list_scheduled_audits(
        &self,
        input: ListScheduledAuditsRequest,
    ) -> RusotoFuture<ListScheduledAuditsResponse, ListScheduledAuditsError> {
        let request_uri = "/audit/scheduledaudits";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListScheduledAuditsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListScheduledAuditsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the Device Defender security profiles you have created. You can use filters to list only those security profiles associated with a thing group or only those associated with your account.</p>
    fn list_security_profiles(
        &self,
        input: ListSecurityProfilesRequest,
    ) -> RusotoFuture<ListSecurityProfilesResponse, ListSecurityProfilesError> {
        let request_uri = "/security-profiles";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListSecurityProfilesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListSecurityProfilesError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the Device Defender security profiles attached to a target (thing group).</p>
    fn list_security_profiles_for_target(
        &self,
        input: ListSecurityProfilesForTargetRequest,
    ) -> RusotoFuture<ListSecurityProfilesForTargetResponse, ListSecurityProfilesForTargetError>
    {
        let request_uri = "/security-profiles-for-target";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        params.put(
            "securityProfileTargetArn",
            &input.security_profile_target_arn,
        );
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListSecurityProfilesForTargetResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListSecurityProfilesForTargetError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists all of the streams in your AWS account.</p>
    fn list_streams(
        &self,
        input: ListStreamsRequest,
    ) -> RusotoFuture<ListStreamsResponse, ListStreamsError> {
        let request_uri = "/streams";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.ascending_order {
            params.put("isAscendingOrder", x);
        }
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListStreamsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListStreamsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the tags (metadata) you have assigned to the resource.</p>
    fn list_tags_for_resource(
        &self,
        input: ListTagsForResourceRequest,
    ) -> RusotoFuture<ListTagsForResourceResponse, ListTagsForResourceError> {
        let request_uri = "/tags";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("resourceArn", &input.resource_arn);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListTagsForResourceResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListTagsForResourceError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>List targets for the specified policy.</p>
    fn list_targets_for_policy(
        &self,
        input: ListTargetsForPolicyRequest,
    ) -> RusotoFuture<ListTargetsForPolicyResponse, ListTargetsForPolicyError> {
        let request_uri = format!(
            "/policy-targets/{policy_name}",
            policy_name = input.policy_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.marker {
            params.put("marker", x);
        }
        if let Some(ref x) = input.page_size {
            params.put("pageSize", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListTargetsForPolicyResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListTargetsForPolicyError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the targets (thing groups) associated with a given Device Defender security profile.</p>
    fn list_targets_for_security_profile(
        &self,
        input: ListTargetsForSecurityProfileRequest,
    ) -> RusotoFuture<ListTargetsForSecurityProfileResponse, ListTargetsForSecurityProfileError>
    {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}/targets",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListTargetsForSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListTargetsForSecurityProfileError::from_response(response))
                }))
            }
        })
    }

    /// <p>List the thing groups in your account.</p>
    fn list_thing_groups(
        &self,
        input: ListThingGroupsRequest,
    ) -> RusotoFuture<ListThingGroupsResponse, ListThingGroupsError> {
        let request_uri = "/thing-groups";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.name_prefix_filter {
            params.put("namePrefixFilter", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.parent_group {
            params.put("parentGroup", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingGroupsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListThingGroupsError::from_response(response))),
                )
            }
        })
    }

    /// <p>List the thing groups to which the specified thing belongs.</p>
    fn list_thing_groups_for_thing(
        &self,
        input: ListThingGroupsForThingRequest,
    ) -> RusotoFuture<ListThingGroupsForThingResponse, ListThingGroupsForThingError> {
        let request_uri = format!(
            "/things/{thing_name}/thing-groups",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingGroupsForThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingGroupsForThingError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the principals associated with the specified thing. A principal can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito identities or federated identities.</p>
    fn list_thing_principals(
        &self,
        input: ListThingPrincipalsRequest,
    ) -> RusotoFuture<ListThingPrincipalsResponse, ListThingPrincipalsError> {
        let request_uri = format!(
            "/things/{thing_name}/principals",
            thing_name = input.thing_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingPrincipalsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListThingPrincipalsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Information about the thing registration tasks.</p>
    fn list_thing_registration_task_reports(
        &self,
        input: ListThingRegistrationTaskReportsRequest,
    ) -> RusotoFuture<ListThingRegistrationTaskReportsResponse, ListThingRegistrationTaskReportsError>
    {
        let request_uri = format!(
            "/thing-registration-tasks/{task_id}/reports",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        params.put("reportType", &input.report_type);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingRegistrationTaskReportsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingRegistrationTaskReportsError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>List bulk thing provisioning tasks.</p>
    fn list_thing_registration_tasks(
        &self,
        input: ListThingRegistrationTasksRequest,
    ) -> RusotoFuture<ListThingRegistrationTasksResponse, ListThingRegistrationTasksError> {
        let request_uri = "/thing-registration-tasks";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.status {
            params.put("status", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingRegistrationTasksResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingRegistrationTasksError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the existing thing types.</p>
    fn list_thing_types(
        &self,
        input: ListThingTypesRequest,
    ) -> RusotoFuture<ListThingTypesResponse, ListThingTypesError> {
        let request_uri = "/thing-types";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.thing_type_name {
            params.put("thingTypeName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingTypesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListThingTypesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists your things. Use the <b>attributeName</b> and <b>attributeValue</b> parameters to filter your things. For example, calling <code>ListThings</code> with attributeName=Color and attributeValue=Red retrieves all things in the registry that contain an attribute <b>Color</b> with the value <b>Red</b>. </p>
    fn list_things(
        &self,
        input: ListThingsRequest,
    ) -> RusotoFuture<ListThingsResponse, ListThingsError> {
        let request_uri = "/things";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.attribute_name {
            params.put("attributeName", x);
        }
        if let Some(ref x) = input.attribute_value {
            params.put("attributeValue", x);
        }
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.thing_type_name {
            params.put("thingTypeName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListThingsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists the things you have added to the given billing group.</p>
    fn list_things_in_billing_group(
        &self,
        input: ListThingsInBillingGroupRequest,
    ) -> RusotoFuture<ListThingsInBillingGroupResponse, ListThingsInBillingGroupError> {
        let request_uri = format!(
            "/billing-groups/{billing_group_name}/things",
            billing_group_name = input.billing_group_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingsInBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListThingsInBillingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the things in the specified group.</p>
    fn list_things_in_thing_group(
        &self,
        input: ListThingsInThingGroupRequest,
    ) -> RusotoFuture<ListThingsInThingGroupResponse, ListThingsInThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}/things",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.recursive {
            params.put("recursive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListThingsInThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListThingsInThingGroupError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists all the topic rule destinations in your AWS account.</p>
    fn list_topic_rule_destinations(
        &self,
        input: ListTopicRuleDestinationsRequest,
    ) -> RusotoFuture<ListTopicRuleDestinationsResponse, ListTopicRuleDestinationsError> {
        let request_uri = "/destinations";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListTopicRuleDestinationsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ListTopicRuleDestinationsError::from_response(response))
                }))
            }
        })
    }

    /// <p>Lists the rules for the specific topic.</p>
    fn list_topic_rules(
        &self,
        input: ListTopicRulesRequest,
    ) -> RusotoFuture<ListTopicRulesResponse, ListTopicRulesError> {
        let request_uri = "/rules";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.rule_disabled {
            params.put("ruleDisabled", x);
        }
        if let Some(ref x) = input.topic {
            params.put("topic", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListTopicRulesResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ListTopicRulesError::from_response(response))),
                )
            }
        })
    }

    /// <p>Lists logging levels.</p>
    fn list_v2_logging_levels(
        &self,
        input: ListV2LoggingLevelsRequest,
    ) -> RusotoFuture<ListV2LoggingLevelsResponse, ListV2LoggingLevelsError> {
        let request_uri = "/v2LoggingLevel";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.target_type {
            params.put("targetType", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListV2LoggingLevelsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListV2LoggingLevelsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Lists the Device Defender security profile violations discovered during the given time period. You can use filters to limit the results to those alerts issued for a particular security profile, behavior, or thing (device).</p>
    fn list_violation_events(
        &self,
        input: ListViolationEventsRequest,
    ) -> RusotoFuture<ListViolationEventsResponse, ListViolationEventsError> {
        let request_uri = "/violation-events";

        let mut request = SignedRequest::new("GET", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("endTime", &input.end_time);
        if let Some(ref x) = input.max_results {
            params.put("maxResults", x);
        }
        if let Some(ref x) = input.next_token {
            params.put("nextToken", x);
        }
        if let Some(ref x) = input.security_profile_name {
            params.put("securityProfileName", x);
        }
        params.put("startTime", &input.start_time);
        if let Some(ref x) = input.thing_name {
            params.put("thingName", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ListViolationEventsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(ListViolationEventsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Registers a CA certificate with AWS IoT. This CA certificate can then be used to sign device certificates, which can be then registered with AWS IoT. You can register up to 10 CA certificates per AWS account that have the same subject field. This enables you to have up to 10 certificate authorities sign your device certificates. If you have more than one CA certificate registered, make sure you pass the CA certificate when you register your device certificates with the RegisterCertificate API.</p>
    fn register_ca_certificate(
        &self,
        input: RegisterCACertificateRequest,
    ) -> RusotoFuture<RegisterCACertificateResponse, RegisterCACertificateError> {
        let request_uri = "/cacertificate";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.allow_auto_registration {
            params.put("allowAutoRegistration", x);
        }
        if let Some(ref x) = input.set_as_active {
            params.put("setAsActive", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<RegisterCACertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(RegisterCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Registers a device certificate with AWS IoT. If you have more than one CA certificate that has the same subject field, you must specify the CA certificate that was used to sign the device certificate being registered.</p>
    fn register_certificate(
        &self,
        input: RegisterCertificateRequest,
    ) -> RusotoFuture<RegisterCertificateResponse, RegisterCertificateError> {
        let request_uri = "/certificate/register";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<RegisterCertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(RegisterCertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Provisions a thing in the device registry. RegisterThing calls other AWS IoT control plane APIs. These calls might exceed your account level <a href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot"> AWS IoT Throttling Limits</a> and cause throttle errors. Please contact <a href="https://console.aws.amazon.com/support/home">AWS Customer Support</a> to raise your throttling limits if necessary.</p>
    fn register_thing(
        &self,
        input: RegisterThingRequest,
    ) -> RusotoFuture<RegisterThingResponse, RegisterThingError> {
        let request_uri = "/things";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<RegisterThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(RegisterThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Rejects a pending certificate transfer. After AWS IoT rejects a certificate transfer, the certificate status changes from <b>PENDING_TRANSFER</b> to <b>INACTIVE</b>.</p> <p>To check for pending certificate transfers, call <a>ListCertificates</a> to enumerate your certificates.</p> <p>This operation can only be called by the transfer destination. After it is called, the certificate will be returned to the source's account in the INACTIVE state.</p>
    fn reject_certificate_transfer(
        &self,
        input: RejectCertificateTransferRequest,
    ) -> RusotoFuture<(), RejectCertificateTransferError> {
        let request_uri = format!(
            "/reject-certificate-transfer/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(RejectCertificateTransferError::from_response(response))
                }))
            }
        })
    }

    /// <p>Removes the given thing from the billing group.</p>
    fn remove_thing_from_billing_group(
        &self,
        input: RemoveThingFromBillingGroupRequest,
    ) -> RusotoFuture<RemoveThingFromBillingGroupResponse, RemoveThingFromBillingGroupError> {
        let request_uri = "/billing-groups/removeThingFromBillingGroup";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<RemoveThingFromBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(RemoveThingFromBillingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Remove the specified thing from the specified group.</p>
    fn remove_thing_from_thing_group(
        &self,
        input: RemoveThingFromThingGroupRequest,
    ) -> RusotoFuture<RemoveThingFromThingGroupResponse, RemoveThingFromThingGroupError> {
        let request_uri = "/thing-groups/removeThingFromThingGroup";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<RemoveThingFromThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(RemoveThingFromThingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Replaces the rule. You must specify all parameters for the new rule. Creating rules is an administrator-level action. Any user who has permission to create rules will be able to access data processed by the rule.</p>
    fn replace_topic_rule(
        &self,
        input: ReplaceTopicRuleRequest,
    ) -> RusotoFuture<(), ReplaceTopicRuleError> {
        let request_uri = format!("/rules/{rule_name}", rule_name = input.rule_name);

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input.topic_rule_payload).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(ReplaceTopicRuleError::from_response(response))),
                )
            }
        })
    }

    /// <p>The query search index.</p>
    fn search_index(
        &self,
        input: SearchIndexRequest,
    ) -> RusotoFuture<SearchIndexResponse, SearchIndexError> {
        let request_uri = "/indices/search";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<SearchIndexResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(SearchIndexError::from_response(response))),
                )
            }
        })
    }

    /// <p>Sets the default authorizer. This will be used if a websocket connection is made without specifying an authorizer.</p>
    fn set_default_authorizer(
        &self,
        input: SetDefaultAuthorizerRequest,
    ) -> RusotoFuture<SetDefaultAuthorizerResponse, SetDefaultAuthorizerError> {
        let request_uri = "/default-authorizer";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<SetDefaultAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(SetDefaultAuthorizerError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Sets the specified version of the specified policy as the policy's default (operative) version. This action affects all certificates to which the policy is attached. To list the principals the policy is attached to, use the ListPrincipalPolicy API.</p>
    fn set_default_policy_version(
        &self,
        input: SetDefaultPolicyVersionRequest,
    ) -> RusotoFuture<(), SetDefaultPolicyVersionError> {
        let request_uri = format!(
            "/policies/{policy_name}/version/{policy_version_id}",
            policy_name = input.policy_name,
            policy_version_id = input.policy_version_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(SetDefaultPolicyVersionError::from_response(response))
                }))
            }
        })
    }

    /// <p>Sets the logging options.</p> <p>NOTE: use of this command is not recommended. Use <code>SetV2LoggingOptions</code> instead.</p>
    fn set_logging_options(
        &self,
        input: SetLoggingOptionsRequest,
    ) -> RusotoFuture<(), SetLoggingOptionsError> {
        let request_uri = "/loggingOptions";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input.logging_options_payload).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(SetLoggingOptionsError::from_response(response))),
                )
            }
        })
    }

    /// <p>Sets the logging level.</p>
    fn set_v2_logging_level(
        &self,
        input: SetV2LoggingLevelRequest,
    ) -> RusotoFuture<(), SetV2LoggingLevelError> {
        let request_uri = "/v2LoggingLevel";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(SetV2LoggingLevelError::from_response(response))),
                )
            }
        })
    }

    /// <p>Sets the logging options for the V2 logging service.</p>
    fn set_v2_logging_options(
        &self,
        input: SetV2LoggingOptionsRequest,
    ) -> RusotoFuture<(), SetV2LoggingOptionsError> {
        let request_uri = "/v2LoggingOptions";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(SetV2LoggingOptionsError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Starts a task that applies a set of mitigation actions to the specified target.</p>
    fn start_audit_mitigation_actions_task(
        &self,
        input: StartAuditMitigationActionsTaskRequest,
    ) -> RusotoFuture<StartAuditMitigationActionsTaskResponse, StartAuditMitigationActionsTaskError>
    {
        let request_uri = format!(
            "/audit/mitigationactions/tasks/{task_id}",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<StartAuditMitigationActionsTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(StartAuditMitigationActionsTaskError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Starts an on-demand Device Defender audit.</p>
    fn start_on_demand_audit_task(
        &self,
        input: StartOnDemandAuditTaskRequest,
    ) -> RusotoFuture<StartOnDemandAuditTaskResponse, StartOnDemandAuditTaskError> {
        let request_uri = "/audit/tasks";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<StartOnDemandAuditTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(StartOnDemandAuditTaskError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Creates a bulk thing provisioning task.</p>
    fn start_thing_registration_task(
        &self,
        input: StartThingRegistrationTaskRequest,
    ) -> RusotoFuture<StartThingRegistrationTaskResponse, StartThingRegistrationTaskError> {
        let request_uri = "/thing-registration-tasks";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<StartThingRegistrationTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(StartThingRegistrationTaskError::from_response(response))
                }))
            }
        })
    }

    /// <p>Cancels a bulk thing provisioning task.</p>
    fn stop_thing_registration_task(
        &self,
        input: StopThingRegistrationTaskRequest,
    ) -> RusotoFuture<StopThingRegistrationTaskResponse, StopThingRegistrationTaskError> {
        let request_uri = format!(
            "/thing-registration-tasks/{task_id}/cancel",
            task_id = input.task_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<StopThingRegistrationTaskResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(StopThingRegistrationTaskError::from_response(response))
                }))
            }
        })
    }

    /// <p>Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.</p>
    fn tag_resource(
        &self,
        input: TagResourceRequest,
    ) -> RusotoFuture<TagResourceResponse, TagResourceError> {
        let request_uri = "/tags";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<TagResourceResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(TagResourceError::from_response(response))),
                )
            }
        })
    }

    /// <p>Tests if a specified principal is authorized to perform an AWS IoT action on a specified resource. Use this to test and debug the authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_authorization(
        &self,
        input: TestAuthorizationRequest,
    ) -> RusotoFuture<TestAuthorizationResponse, TestAuthorizationError> {
        let request_uri = "/test-authorization";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.client_id {
            params.put("clientId", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<TestAuthorizationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(TestAuthorizationError::from_response(response))),
                )
            }
        })
    }

    /// <p>Tests a custom authorization behavior by invoking a specified custom authorizer. Use this to test and debug the custom authorization behavior of devices that connect to the AWS IoT device gateway.</p>
    fn test_invoke_authorizer(
        &self,
        input: TestInvokeAuthorizerRequest,
    ) -> RusotoFuture<TestInvokeAuthorizerResponse, TestInvokeAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}/test",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<TestInvokeAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(TestInvokeAuthorizerError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Transfers the specified certificate to the specified AWS account.</p> <p>You can cancel the transfer until it is acknowledged by the recipient.</p> <p>No notification is sent to the transfer destination's account. It is up to the caller to notify the transfer target.</p> <p>The certificate being transferred must not be in the ACTIVE state. You can use the UpdateCertificate API to deactivate it.</p> <p>The certificate must not have any policies attached to it. You can use the DetachPrincipalPolicy API to detach them.</p>
    fn transfer_certificate(
        &self,
        input: TransferCertificateRequest,
    ) -> RusotoFuture<TransferCertificateResponse, TransferCertificateError> {
        let request_uri = format!(
            "/transfer-certificate/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        params.put("targetAwsAccount", &input.target_aws_account);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<TransferCertificateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(TransferCertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Removes the given tags (metadata) from the resource.</p>
    fn untag_resource(
        &self,
        input: UntagResourceRequest,
    ) -> RusotoFuture<UntagResourceResponse, UntagResourceError> {
        let request_uri = "/untag";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UntagResourceResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UntagResourceError::from_response(response))),
                )
            }
        })
    }

    /// <p>Configures or reconfigures the Device Defender audit settings for this account. Settings include how audit notifications are sent and which audit checks are enabled or disabled.</p>
    fn update_account_audit_configuration(
        &self,
        input: UpdateAccountAuditConfigurationRequest,
    ) -> RusotoFuture<UpdateAccountAuditConfigurationResponse, UpdateAccountAuditConfigurationError>
    {
        let request_uri = "/audit/configuration";

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateAccountAuditConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateAccountAuditConfigurationError::from_response(
                        response,
                    ))
                }))
            }
        })
    }

    /// <p>Updates an authorizer.</p>
    fn update_authorizer(
        &self,
        input: UpdateAuthorizerRequest,
    ) -> RusotoFuture<UpdateAuthorizerResponse, UpdateAuthorizerError> {
        let request_uri = format!(
            "/authorizer/{authorizer_name}",
            authorizer_name = input.authorizer_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateAuthorizerResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateAuthorizerError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates information about the billing group.</p>
    fn update_billing_group(
        &self,
        input: UpdateBillingGroupRequest,
    ) -> RusotoFuture<UpdateBillingGroupResponse, UpdateBillingGroupError> {
        let request_uri = format!(
            "/billing-groups/{billing_group_name}",
            billing_group_name = input.billing_group_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateBillingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateBillingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates a registered CA certificate.</p>
    fn update_ca_certificate(
        &self,
        input: UpdateCACertificateRequest,
    ) -> RusotoFuture<(), UpdateCACertificateError> {
        let request_uri = format!(
            "/cacertificate/{ca_certificate_id}",
            ca_certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.new_auto_registration_status {
            params.put("newAutoRegistrationStatus", x);
        }
        if let Some(ref x) = input.new_status {
            params.put("newStatus", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateCACertificateError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates the status of the specified certificate. This operation is idempotent.</p> <p>Moving a certificate from the ACTIVE state (including REVOKED) will not disconnect currently connected devices, but these devices will be unable to reconnect.</p> <p>The ACTIVE state is required to authenticate devices connecting to AWS IoT using a certificate.</p>
    fn update_certificate(
        &self,
        input: UpdateCertificateRequest,
    ) -> RusotoFuture<(), UpdateCertificateError> {
        let request_uri = format!(
            "/certificates/{certificate_id}",
            certificate_id = input.certificate_id
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());

        let mut params = Params::new();
        params.put("newStatus", &input.new_status);
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateCertificateError::from_response(response))),
                )
            }
        })
    }

    /// <p><p>Updates values stored in the domain configuration. Domain configurations for default endpoints can&#39;t be updated.</p> <note> <p>The domain configuration feature is in public preview and is subject to change.</p> </note></p>
    fn update_domain_configuration(
        &self,
        input: UpdateDomainConfigurationRequest,
    ) -> RusotoFuture<UpdateDomainConfigurationResponse, UpdateDomainConfigurationError> {
        let request_uri = format!(
            "/domainConfigurations/{domain_configuration_name}",
            domain_configuration_name = input.domain_configuration_name
        );

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateDomainConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateDomainConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates a dynamic thing group.</p>
    fn update_dynamic_thing_group(
        &self,
        input: UpdateDynamicThingGroupRequest,
    ) -> RusotoFuture<UpdateDynamicThingGroupResponse, UpdateDynamicThingGroupError> {
        let request_uri = format!(
            "/dynamic-thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateDynamicThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateDynamicThingGroupError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates the event configurations.</p>
    fn update_event_configurations(
        &self,
        input: UpdateEventConfigurationsRequest,
    ) -> RusotoFuture<UpdateEventConfigurationsResponse, UpdateEventConfigurationsError> {
        let request_uri = "/event-configurations";

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateEventConfigurationsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateEventConfigurationsError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates the search configuration.</p>
    fn update_indexing_configuration(
        &self,
        input: UpdateIndexingConfigurationRequest,
    ) -> RusotoFuture<UpdateIndexingConfigurationResponse, UpdateIndexingConfigurationError> {
        let request_uri = "/indexing/config";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateIndexingConfigurationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateIndexingConfigurationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates supported fields of the specified job.</p>
    fn update_job(&self, input: UpdateJobRequest) -> RusotoFuture<(), UpdateJobError> {
        let request_uri = format!("/jobs/{job_id}", job_id = input.job_id);

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = ::std::mem::drop(response);

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateJobError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates the definition for the specified mitigation action.</p>
    fn update_mitigation_action(
        &self,
        input: UpdateMitigationActionRequest,
    ) -> RusotoFuture<UpdateMitigationActionResponse, UpdateMitigationActionError> {
        let request_uri = format!(
            "/mitigationactions/actions/{action_name}",
            action_name = input.action_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateMitigationActionResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateMitigationActionError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates a fleet provisioning template.</p>
    fn update_provisioning_template(
        &self,
        input: UpdateProvisioningTemplateRequest,
    ) -> RusotoFuture<UpdateProvisioningTemplateResponse, UpdateProvisioningTemplateError> {
        let request_uri = format!(
            "/provisioning-templates/{template_name}",
            template_name = input.template_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateProvisioningTemplateResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateProvisioningTemplateError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates a role alias.</p>
    fn update_role_alias(
        &self,
        input: UpdateRoleAliasRequest,
    ) -> RusotoFuture<UpdateRoleAliasResponse, UpdateRoleAliasError> {
        let request_uri = format!("/role-aliases/{role_alias}", role_alias = input.role_alias);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateRoleAliasResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateRoleAliasError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates a scheduled audit, including which checks are performed and how often the audit takes place.</p>
    fn update_scheduled_audit(
        &self,
        input: UpdateScheduledAuditRequest,
    ) -> RusotoFuture<UpdateScheduledAuditResponse, UpdateScheduledAuditError> {
        let request_uri = format!(
            "/audit/scheduledaudits/{scheduled_audit_name}",
            scheduled_audit_name = input.scheduled_audit_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateScheduledAuditResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateScheduledAuditError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates a Device Defender security profile.</p>
    fn update_security_profile(
        &self,
        input: UpdateSecurityProfileRequest,
    ) -> RusotoFuture<UpdateSecurityProfileResponse, UpdateSecurityProfileError> {
        let request_uri = format!(
            "/security-profiles/{security_profile_name}",
            security_profile_name = input.security_profile_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        let mut params = Params::new();
        if let Some(ref x) = input.expected_version {
            params.put("expectedVersion", x);
        }
        request.set_params(params);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateSecurityProfileResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response.buffer().from_err().and_then(|response| {
                        Err(UpdateSecurityProfileError::from_response(response))
                    }),
                )
            }
        })
    }

    /// <p>Updates an existing stream. The stream version will be incremented by one.</p>
    fn update_stream(
        &self,
        input: UpdateStreamRequest,
    ) -> RusotoFuture<UpdateStreamResponse, UpdateStreamError> {
        let request_uri = format!("/streams/{stream_id}", stream_id = input.stream_id);

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateStreamResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateStreamError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates the data for a thing.</p>
    fn update_thing(
        &self,
        input: UpdateThingRequest,
    ) -> RusotoFuture<UpdateThingResponse, UpdateThingError> {
        let request_uri = format!("/things/{thing_name}", thing_name = input.thing_name);

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateThingError::from_response(response))),
                )
            }
        })
    }

    /// <p>Update a thing group.</p>
    fn update_thing_group(
        &self,
        input: UpdateThingGroupRequest,
    ) -> RusotoFuture<UpdateThingGroupResponse, UpdateThingGroupError> {
        let request_uri = format!(
            "/thing-groups/{thing_group_name}",
            thing_group_name = input.thing_group_name
        );

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateThingGroupResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(
                    response
                        .buffer()
                        .from_err()
                        .and_then(|response| Err(UpdateThingGroupError::from_response(response))),
                )
            }
        })
    }

    /// <p>Updates the groups to which the thing belongs.</p>
    fn update_thing_groups_for_thing(
        &self,
        input: UpdateThingGroupsForThingRequest,
    ) -> RusotoFuture<UpdateThingGroupsForThingResponse, UpdateThingGroupsForThingError> {
        let request_uri = "/thing-groups/updateThingGroupsForThing";

        let mut request = SignedRequest::new("PUT", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateThingGroupsForThingResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateThingGroupsForThingError::from_response(response))
                }))
            }
        })
    }

    /// <p>Updates a topic rule destination. You use this to change the status, endpoint URL, or confirmation URL of the destination.</p>
    fn update_topic_rule_destination(
        &self,
        input: UpdateTopicRuleDestinationRequest,
    ) -> RusotoFuture<UpdateTopicRuleDestinationResponse, UpdateTopicRuleDestinationError> {
        let request_uri = "/destinations";

        let mut request = SignedRequest::new("PATCH", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<UpdateTopicRuleDestinationResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(UpdateTopicRuleDestinationError::from_response(response))
                }))
            }
        })
    }

    /// <p>Validates a Device Defender security profile behaviors specification.</p>
    fn validate_security_profile_behaviors(
        &self,
        input: ValidateSecurityProfileBehaviorsRequest,
    ) -> RusotoFuture<ValidateSecurityProfileBehaviorsResponse, ValidateSecurityProfileBehaviorsError>
    {
        let request_uri = "/security-profile-behaviors/validate";

        let mut request = SignedRequest::new("POST", "execute-api", &self.region, &request_uri);
        request.set_content_type("application/x-amz-json-1.1".to_owned());

        request.set_endpoint_prefix("iot".to_string());
        let encoded = Some(serde_json::to_vec(&input).unwrap());
        request.set_payload(encoded);

        self.client.sign_and_dispatch(request, |response| {
            if response.status.is_success() {
                Box::new(response.buffer().from_err().and_then(|response| {
                    let result = proto::json::ResponsePayload::new(&response)
                        .deserialize::<ValidateSecurityProfileBehaviorsResponse, _>()?;

                    Ok(result)
                }))
            } else {
                Box::new(response.buffer().from_err().and_then(|response| {
                    Err(ValidateSecurityProfileBehaviorsError::from_response(
                        response,
                    ))
                }))
            }
        })
    }
}
